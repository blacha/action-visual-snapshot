var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@actions/core/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports.toCommandValue = toCommandValue;
  }
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  "node_modules/@actions/core/lib/command.js"(exports) {
    "use strict";
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var os = __importStar(require("os"));
    var utils_1 = require_utils();
    function issueCommand(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os.EOL);
    }
    exports.issueCommand = issueCommand;
    function issue(name, message = "") {
      issueCommand(name, {}, message);
    }
    exports.issue = issue;
    var CMD_STRING = "::";
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s2) {
      return utils_1.toCommandValue(s2).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s2) {
      return utils_1.toCommandValue(s2).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  "node_modules/@actions/core/lib/file-command.js"(exports) {
    "use strict";
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs8 = __importStar(require("fs"));
    var os = __importStar(require("os"));
    var utils_1 = require_utils();
    function issueCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs8.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs8.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: "utf8"
      });
    }
    exports.issueCommand = issueCommand;
  }
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS({
  "node_modules/@actions/core/lib/core.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils();
    var os = __importStar(require("os"));
    var path8 = __importStar(require("path"));
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
    function exportVariable(name, val) {
      const convertedVal = utils_1.toCommandValue(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        const delimiter = "_GitHubActionsFileCommandDelimeter_";
        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
        file_command_1.issueCommand("ENV", commandValue);
      } else {
        command_1.issueCommand("set-env", { name }, convertedVal);
      }
    }
    exports.exportVariable = exportVariable;
    function setSecret(secret) {
      command_1.issueCommand("add-mask", {}, secret);
    }
    exports.setSecret = setSecret;
    function addPath(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        file_command_1.issueCommand("PATH", inputPath);
      } else {
        command_1.issueCommand("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path8.delimiter}${process.env["PATH"]}`;
    }
    exports.addPath = addPath;
    function getInput3(name, options) {
      const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      return val.trim();
    }
    exports.getInput = getInput3;
    function setOutput2(name, value) {
      command_1.issueCommand("set-output", { name }, value);
    }
    exports.setOutput = setOutput2;
    function setCommandEcho(enabled) {
      command_1.issue("echo", enabled ? "on" : "off");
    }
    exports.setCommandEcho = setCommandEcho;
    function setFailed2(message) {
      process.exitCode = ExitCode.Failure;
      error2(message);
    }
    exports.setFailed = setFailed2;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports.isDebug = isDebug;
    function debug5(message) {
      command_1.issueCommand("debug", {}, message);
    }
    exports.debug = debug5;
    function error2(message) {
      command_1.issue("error", message instanceof Error ? message.toString() : message);
    }
    exports.error = error2;
    function warning4(message) {
      command_1.issue("warning", message instanceof Error ? message.toString() : message);
    }
    exports.warning = warning4;
    function info(message) {
      process.stdout.write(message + os.EOL);
    }
    exports.info = info;
    function startGroup8(name) {
      command_1.issue("group", name);
    }
    exports.startGroup = startGroup8;
    function endGroup8() {
      command_1.issue("endgroup");
    }
    exports.endGroup = endGroup8;
    function group(name, fn) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup8(name);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup8();
        }
        return result;
      });
    }
    exports.group = group;
    function saveState(name, value) {
      command_1.issueCommand("save-state", { name }, value);
    }
    exports.saveState = saveState;
    function getState(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports.getState = getState;
  }
});

// node_modules/@actions/github/lib/context.js
var require_context = __commonJS({
  "node_modules/@actions/github/lib/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Context = void 0;
    var fs_1 = require("fs");
    var os_1 = require("os");
    var Context = class {
      constructor() {
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
          if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
            this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
          } else {
            const path8 = process.env.GITHUB_EVENT_PATH;
            process.stdout.write(`GITHUB_EVENT_PATH ${path8} does not exist${os_1.EOL}`);
          }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
      }
      get issue() {
        const payload2 = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (payload2.issue || payload2.pull_request || payload2).number });
      }
      get repo() {
        if (process.env.GITHUB_REPOSITORY) {
          const [owner2, repo2] = process.env.GITHUB_REPOSITORY.split("/");
          return { owner: owner2, repo: repo2 };
        }
        if (this.payload.repository) {
          return {
            owner: this.payload.repository.owner.login,
            repo: this.payload.repository.name
          };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
      }
    };
    exports.Context = Context;
  }
});

// node_modules/@actions/http-client/proxy.js
var require_proxy = __commonJS({
  "node_modules/@actions/http-client/proxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var url = require("url");
    function getProxyUrl(reqUrl) {
      let usingSsl = reqUrl.protocol === "https:";
      let proxyUrl;
      if (checkBypass(reqUrl)) {
        return proxyUrl;
      }
      let proxyVar;
      if (usingSsl) {
        proxyVar = process.env["https_proxy"] || process.env["HTTPS_PROXY"];
      } else {
        proxyVar = process.env["http_proxy"] || process.env["HTTP_PROXY"];
      }
      if (proxyVar) {
        proxyUrl = url.parse(proxyVar);
      }
      return proxyUrl;
    }
    exports.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      let noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      let upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (let upperNoProxyItem of noProxy.split(",").map((x2) => x2.trim().toUpperCase()).filter((x2) => x2)) {
        if (upperReqHosts.some((x2) => x2 === upperNoProxyItem)) {
          return true;
        }
      }
      return false;
    }
    exports.checkBypass = checkBypass;
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/tunnel/lib/tunnel.js"(exports) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http3 = require("http");
    var https2 = require("https");
    var events = require("events");
    var assert = require("assert");
    var util = require("util");
    exports.httpOverHttp = httpOverHttp;
    exports.httpsOverHttp = httpsOverHttp;
    exports.httpOverHttps = httpOverHttps;
    exports.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http3.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http3.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https2.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https2.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http3.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i2 = 0, len = self2.requests.length; i2 < len; ++i2) {
          var pending = self2.requests[i2];
          if (pending.host === options2.host && pending.port === options2.port) {
            self2.requests.splice(i2, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self2 = this;
      var options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push(options);
        return;
      }
      self2.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug5("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug5("tunneling socket could not be established, statusCode=%d", res.statusCode);
          socket.destroy();
          var error2 = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error2.code = "ECONNRESET";
          options.request.emit("error", error2);
          self2.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug5("got illegal response body from proxy");
          socket.destroy();
          var error2 = new Error("got illegal response body from proxy");
          error2.code = "ECONNRESET";
          options.request.emit("error", error2);
          self2.removeSocket(placeholder);
          return;
        }
        debug5("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug5("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
        var error2 = new Error("tunneling socket could not be established, cause=" + cause.message);
        error2.code = "ECONNRESET";
        options.request.emit("error", error2);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self2.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i2 = 1, len = arguments.length; i2 < len; ++i2) {
        var overrides = arguments[i2];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug5;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug5 = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug5 = function() {
      };
    }
    exports.debug = debug5;
  }
});

// node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "node_modules/tunnel/index.js"(exports, module2) {
    module2.exports = require_tunnel();
  }
});

// node_modules/@actions/http-client/index.js
var require_http_client = __commonJS({
  "node_modules/@actions/http-client/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var url = require("url");
    var http3 = require("http");
    var https2 = require("https");
    var pm = require_proxy();
    var tunnel;
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
    var Headers2;
    (function(Headers3) {
      Headers3["Accept"] = "accept";
      Headers3["ContentType"] = "content-type";
    })(Headers2 = exports.Headers || (exports.Headers = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2["ApplicationJson"] = "application/json";
    })(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      let proxyUrl = pm.getProxyUrl(url.parse(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ];
    var HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return new Promise(async (resolve2, reject) => {
          let output = Buffer.alloc(0);
          this.message.on("data", (chunk) => {
            output = Buffer.concat([output, chunk]);
          });
          this.message.on("end", () => {
            resolve2(output.toString());
          });
        });
      }
    };
    exports.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      let parsedUrl = url.parse(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      }
      get(requestUrl, additionalHeaders) {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      }
      del(requestUrl, additionalHeaders) {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      }
      post(requestUrl, data, additionalHeaders) {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      }
      patch(requestUrl, data, additionalHeaders) {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      }
      put(requestUrl, data, additionalHeaders) {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      }
      head(requestUrl, additionalHeaders) {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      }
      async getJson(requestUrl, additionalHeaders = {}) {
        additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson);
        let res = await this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      }
      async postJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.ContentType, MediaTypes.ApplicationJson);
        let res = await this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      }
      async putJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.ContentType, MediaTypes.ApplicationJson);
        let res = await this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      }
      async patchJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.ContentType, MediaTypes.ApplicationJson);
        let res = await this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      }
      async request(verb, requestUrl, data, headers) {
        if (this._disposed) {
          throw new Error("Client has already been disposed.");
        }
        let parsedUrl = url.parse(requestUrl);
        let info = this._prepareRequest(verb, parsedUrl, headers);
        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1 ? this._maxRetries + 1 : 1;
        let numTries = 0;
        let response;
        while (numTries < maxTries) {
          response = await this.requestRaw(info, data);
          if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (let i2 = 0; i2 < this.handlers.length; i2++) {
              if (this.handlers[i2].canHandleAuthentication(response)) {
                authenticationHandler = this.handlers[i2];
                break;
              }
            }
            if (authenticationHandler) {
              return authenticationHandler.handleAuthentication(this, info, data);
            } else {
              return response;
            }
          }
          let redirectsRemaining = this._maxRedirects;
          while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 && this._allowRedirects && redirectsRemaining > 0) {
            const redirectUrl = response.message.headers["location"];
            if (!redirectUrl) {
              break;
            }
            let parsedRedirectUrl = url.parse(redirectUrl);
            if (parsedUrl.protocol == "https:" && parsedUrl.protocol != parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
              throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            }
            await response.readBody();
            if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (let header in headers) {
                if (header.toLowerCase() === "authorization") {
                  delete headers[header];
                }
              }
            }
            info = this._prepareRequest(verb, parsedRedirectUrl, headers);
            response = await this.requestRaw(info, data);
            redirectsRemaining--;
          }
          if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {
            return response;
          }
          numTries += 1;
          if (numTries < maxTries) {
            await response.readBody();
            await this._performExponentialBackoff(numTries);
          }
        }
        return response;
      }
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      requestRaw(info, data) {
        return new Promise((resolve2, reject) => {
          let callbackForResult = function(err, res) {
            if (err) {
              reject(err);
            }
            resolve2(res);
          };
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      }
      requestRawWithCallback(info, data, onResult) {
        let socket;
        if (typeof data === "string") {
          info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        let handleResult = (err, res) => {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        };
        let req = info.httpModule.request(info.options, (msg) => {
          let res = new HttpClientResponse(msg);
          handleResult(null, res);
        });
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error("Request timeout: " + info.options.path), null);
        });
        req.on("error", function(err) {
          handleResult(err, null);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      getAgent(serverUrl) {
        let parsedUrl = url.parse(serverUrl);
        return this._getAgent(parsedUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === "https:";
        info.httpModule = usingSsl ? https2 : http3;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
        info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info.options.headers["user-agent"] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        if (this.handlers) {
          this.handlers.forEach((handler) => {
            handler.prepareRequest(info.options);
          });
        }
        return info;
      }
      _mergeHeaders(headers) {
        const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));
        }
        return lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        let proxyUrl = pm.getProxyUrl(parsedUrl);
        let useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
          agent = this._agent;
        }
        if (!!agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (!!this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http3.globalAgent.maxSockets;
        }
        if (useProxy) {
          if (!tunnel) {
            tunnel = require_tunnel2();
          }
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: {
              proxyAuth: proxyUrl.auth,
              host: proxyUrl.hostname,
              port: proxyUrl.port
            }
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (this._keepAlive && !agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https2.Agent(options) : new http3.Agent(options);
          this._agent = agent;
        }
        if (!agent) {
          agent = usingSsl ? https2.globalAgent : http3.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false
          });
        }
        return agent;
      }
      _performExponentialBackoff(retryNumber) {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve2) => setTimeout(() => resolve2(), ms));
      }
      static dateTimeDeserializer(key, value) {
        if (typeof value === "string") {
          let a = new Date(value);
          if (!isNaN(a.valueOf())) {
            return a;
          }
        }
        return value;
      }
      async _processResponse(res, options) {
        return new Promise(async (resolve2, reject) => {
          const statusCode = res.message.statusCode;
          const response = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode == HttpCodes.NotFound) {
            resolve2(response);
          }
          let obj;
          let contents;
          try {
            contents = await res.readBody();
            if (contents && contents.length > 0) {
              if (options && options.deserializeDates) {
                obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);
              } else {
                obj = JSON.parse(contents);
              }
              response.result = obj;
            }
            response.headers = res.message.headers;
          } catch (err) {
          }
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message) {
              msg = obj.message;
            } else if (contents && contents.length > 0) {
              msg = contents;
            } else {
              msg = "Failed request: (" + statusCode + ")";
            }
            let err = new Error(msg);
            err["statusCode"] = statusCode;
            if (response.result) {
              err["result"] = response.result;
            }
            reject(err);
          } else {
            resolve2(response);
          }
        });
      }
    };
    exports.HttpClient = HttpClient;
  }
});

// node_modules/@actions/github/lib/internal/utils.js
var require_utils2 = __commonJS({
  "node_modules/@actions/github/lib/internal/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;
    var httpClient = __importStar(require_http_client());
    function getAuthString(token2, options) {
      if (!token2 && !options.auth) {
        throw new Error("Parameter token or opts.auth is required");
      } else if (token2 && options.auth) {
        throw new Error("Parameters token and opts.auth may not both be specified");
      }
      return typeof options.auth === "string" ? options.auth : `token ${token2}`;
    }
    exports.getAuthString = getAuthString;
    function getProxyAgent(destinationUrl) {
      const hc = new httpClient.HttpClient();
      return hc.getAgent(destinationUrl);
    }
    exports.getProxyAgent = getProxyAgent;
    function getApiBaseUrl() {
      return process.env["GITHUB_API_URL"] || "https://api.github.com";
    }
    exports.getApiBaseUrl = getApiBaseUrl;
  }
});

// node_modules/@octokit/core/node_modules/universal-user-agent/dist-node/index.js
var require_dist_node = __commonJS({
  "node_modules/@octokit/core/node_modules/universal-user-agent/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getUserAgent() {
      if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
      }
      if (typeof process === "object" && "version" in process) {
        return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
      }
      return "<environment undetectable>";
    }
    exports.getUserAgent = getUserAgent;
  }
});

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS({
  "node_modules/before-after-hook/lib/register.js"(exports, module2) {
    module2.exports = register;
    function register(state, name, method, options) {
      if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!options) {
        options = {};
      }
      if (Array.isArray(name)) {
        return name.reverse().reduce(function(callback, name2) {
          return register.bind(null, state, name2, callback, options);
        }, method)();
      }
      return Promise.resolve().then(function() {
        if (!state.registry[name]) {
          return method(options);
        }
        return state.registry[name].reduce(function(method2, registered) {
          return registered.hook.bind(null, method2, options);
        }, method)();
      });
    }
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({
  "node_modules/before-after-hook/lib/add.js"(exports, module2) {
    module2.exports = addHook;
    function addHook(state, kind, name, hook) {
      var orig = hook;
      if (!state.registry[name]) {
        state.registry[name] = [];
      }
      if (kind === "before") {
        hook = function(method, options) {
          return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
      }
      if (kind === "after") {
        hook = function(method, options) {
          var result;
          return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
            result = result_;
            return orig(result, options);
          }).then(function() {
            return result;
          });
        };
      }
      if (kind === "error") {
        hook = function(method, options) {
          return Promise.resolve().then(method.bind(null, options)).catch(function(error2) {
            return orig(error2, options);
          });
        };
      }
      state.registry[name].push({
        hook,
        orig
      });
    }
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({
  "node_modules/before-after-hook/lib/remove.js"(exports, module2) {
    module2.exports = removeHook;
    function removeHook(state, name, method) {
      if (!state.registry[name]) {
        return;
      }
      var index = state.registry[name].map(function(registered) {
        return registered.orig;
      }).indexOf(method);
      if (index === -1) {
        return;
      }
      state.registry[name].splice(index, 1);
    }
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({
  "node_modules/before-after-hook/index.js"(exports, module2) {
    var register = require_register();
    var addHook = require_add();
    var removeHook = require_remove();
    var bind = Function.bind;
    var bindable = bind.bind(bind);
    function bindApi(hook, state, name) {
      var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
      hook.api = { remove: removeHookRef };
      hook.remove = removeHookRef;
      ["before", "error", "after", "wrap"].forEach(function(kind) {
        var args = name ? [state, kind, name] : [state, kind];
        hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
      });
    }
    function HookSingular() {
      var singularHookName = "h";
      var singularHookState = {
        registry: {}
      };
      var singularHook = register.bind(null, singularHookState, singularHookName);
      bindApi(singularHook, singularHookState, singularHookName);
      return singularHook;
    }
    function HookCollection() {
      var state = {
        registry: {}
      };
      var hook = register.bind(null, state);
      bindApi(hook, state);
      return hook;
    }
    var collectionHookDeprecationMessageDisplayed = false;
    function Hook() {
      if (!collectionHookDeprecationMessageDisplayed) {
        console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
        collectionHookDeprecationMessageDisplayed = true;
      }
      return HookCollection();
    }
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.Singular = Hook.Singular;
    module2.exports.Collection = Hook.Collection;
  }
});

// node_modules/@octokit/endpoint/node_modules/is-plain-object/index.cjs.js
var require_index_cjs = __commonJS({
  "node_modules/@octokit/endpoint/node_modules/is-plain-object/index.cjs.js"(exports, module2) {
    "use strict";
    function isObject(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    }
    function isObjectObject(o) {
      return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    function isPlainObject(o) {
      var ctor, prot;
      if (isObjectObject(o) === false)
        return false;
      ctor = o.constructor;
      if (typeof ctor !== "function")
        return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/macos-release/index.js
var require_macos_release = __commonJS({
  "node_modules/macos-release/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var nameMap = /* @__PURE__ */ new Map([
      [19, "Catalina"],
      [18, "Mojave"],
      [17, "High Sierra"],
      [16, "Sierra"],
      [15, "El Capitan"],
      [14, "Yosemite"],
      [13, "Mavericks"],
      [12, "Mountain Lion"],
      [11, "Lion"],
      [10, "Snow Leopard"],
      [9, "Leopard"],
      [8, "Tiger"],
      [7, "Panther"],
      [6, "Jaguar"],
      [5, "Puma"]
    ]);
    var macosRelease = (release) => {
      release = Number((release || os.release()).split(".")[0]);
      return {
        name: nameMap.get(release),
        version: "10." + (release - 4)
      };
    };
    module2.exports = macosRelease;
    module2.exports.default = macosRelease;
  }
});

// node_modules/nice-try/src/index.js
var require_src = __commonJS({
  "node_modules/nice-try/src/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(fn) {
      try {
        return fn();
      } catch (e2) {
      }
    };
  }
});

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs8 = require("fs");
    function checkPathExt(path8, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i2 = 0; i2 < pathext.length; i2++) {
        var p = pathext[i2].toLowerCase();
        if (p && path8.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat2, path8, options) {
      if (!stat2.isSymbolicLink() && !stat2.isFile()) {
        return false;
      }
      return checkPathExt(path8, options);
    }
    function isexe(path8, options, cb) {
      fs8.stat(path8, function(er, stat2) {
        cb(er, er ? false : checkStat(stat2, path8, options));
      });
    }
    function sync(path8, options) {
      return checkStat(fs8.statSync(path8), path8, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs8 = require("fs");
    function isexe(path8, options, cb) {
      fs8.stat(path8, function(er, stat2) {
        cb(er, er ? false : checkStat(stat2, options));
      });
    }
    function sync(path8, options) {
      return checkStat(fs8.statSync(path8), options);
    }
    function checkStat(stat2, options) {
      return stat2.isFile() && checkMode(stat2, options);
    }
    function checkMode(stat2, options) {
      var mod = stat2.mode;
      var uid = stat2.uid;
      var gid = stat2.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports, module2) {
    var fs8 = require("fs");
    var core10;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core10 = require_windows();
    } else {
      core10 = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path8, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve2, reject) {
          isexe(path8, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve2(is);
            }
          });
        });
      }
      core10(path8, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path8, options) {
      try {
        return core10.sync(path8, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/execa/node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/execa/node_modules/which/which.js"(exports, module2) {
    module2.exports = which;
    which.sync = whichSync;
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path8 = require("path");
    var COLON2 = isWindows ? ";" : ":";
    var isexe = require_isexe();
    function getNotFoundError(cmd) {
      var er = new Error("not found: " + cmd);
      er.code = "ENOENT";
      return er;
    }
    function getPathInfo(cmd, opt) {
      var colon = opt.colon || COLON2;
      var pathEnv = opt.path || process.env.PATH || "";
      var pathExt = [""];
      pathEnv = pathEnv.split(colon);
      var pathExtExe = "";
      if (isWindows) {
        pathEnv.unshift(process.cwd());
        pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
        pathExt = pathExtExe.split(colon);
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
        pathEnv = [""];
      return {
        env: pathEnv,
        ext: pathExt,
        extExe: pathExtExe
      };
    }
    function which(cmd, opt, cb) {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      (function F2(i2, l) {
        if (i2 === l) {
          if (opt.all && found.length)
            return cb(null, found);
          else
            return cb(getNotFoundError(cmd));
        }
        var pathPart = pathEnv[i2];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path8.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        ;
        (function E(ii, ll) {
          if (ii === ll)
            return F2(i2 + 1, l);
          var ext = pathExt[ii];
          isexe(p + ext, { pathExt: pathExtExe }, function(er, is) {
            if (!er && is) {
              if (opt.all)
                found.push(p + ext);
              else
                return cb(null, p + ext);
            }
            return E(ii + 1, ll);
          });
        })(0, pathExt.length);
      })(0, pathEnv.length);
    }
    function whichSync(cmd, opt) {
      opt = opt || {};
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      for (var i2 = 0, l = pathEnv.length; i2 < l; i2++) {
        var pathPart = pathEnv[i2];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path8.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        for (var j = 0, ll = pathExt.length; j < ll; j++) {
          var cur = p + pathExt[j];
          var is;
          try {
            is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    }
  }
});

// node_modules/path-key/index.js
var require_path_key = __commonJS({
  "node_modules/path-key/index.js"(exports, module2) {
    "use strict";
    module2.exports = (opts) => {
      opts = opts || {};
      const env = opts.env || process.env;
      const platform = opts.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(env).find((x2) => x2.toUpperCase() === "PATH") || "Path";
    };
  }
});

// node_modules/execa/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "node_modules/execa/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports, module2) {
    "use strict";
    var path8 = require("path");
    var which = require_which();
    var pathKey = require_path_key()();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      if (hasCustomCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: (parsed.options.env || process.env)[pathKey],
          pathExt: withoutPathExt ? path8.delimiter : void 0
        });
      } catch (e2) {
      } finally {
        process.chdir(cwd);
      }
      if (resolved) {
        resolved = path8.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  }
});

// node_modules/execa/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "node_modules/execa/node_modules/cross-spawn/lib/util/escape.js"(exports, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// node_modules/execa/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "node_modules/execa/node_modules/shebang-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = /^#!.*/;
  }
});

// node_modules/execa/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "node_modules/execa/node_modules/shebang-command/index.js"(exports, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = function(str) {
      var match = str.match(shebangRegex);
      if (!match) {
        return null;
      }
      var arr = match[0].replace(/#! ?/, "").split(" ");
      var bin = arr[0].split("/").pop();
      var arg = arr[1];
      return bin === "env" ? arg : bin + (arg ? " " + arg : "");
    };
  }
});

// node_modules/execa/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "node_modules/execa/node_modules/cross-spawn/lib/util/readShebang.js"(exports, module2) {
    "use strict";
    var fs8 = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      let buffer;
      if (Buffer.alloc) {
        buffer = Buffer.alloc(size);
      } else {
        buffer = new Buffer(size);
        buffer.fill(0);
      }
      let fd;
      try {
        fd = fs8.openSync(command, "r");
        fs8.readSync(fd, buffer, 0, size, 0);
        fs8.closeSync(fd);
      } catch (e2) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// node_modules/execa/node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/execa/node_modules/semver/semver.js"(exports, module2) {
    exports = module2.exports = SemVer;
    var debug5;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug5 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug5 = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports.re = [];
    var src = exports.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i2 = 0; i2 < R; i2++) {
      debug5(i2, src[i2]);
      if (!re[i2]) {
        re[i2] = new RegExp(src[i2]);
      }
    }
    var i2;
    exports.parse = parse2;
    function parse2(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      var r2 = options.loose ? re[LOOSE] : re[FULL];
      if (!r2.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version2, options) {
      var v = parse2(version2, options);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version2, options) {
      var s2 = parse2(version2.trim().replace(/^[=v]+/, ""), options);
      return s2 ? s2.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        if (version2.loose === options.loose) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError("Invalid Version: " + version2);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version2, options);
      }
      debug5("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      var m2 = version2.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m2) {
        throw new TypeError("Invalid Version: " + version2);
      }
      this.raw = version2;
      this.major = +m2[1];
      this.minor = +m2[2];
      this.patch = +m2[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m2[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m2[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m2[5] ? m2[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug5("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i3 = 0;
      do {
        var a = this.prerelease[i3];
        var b = other.prerelease[i3];
        debug5("prerelease compare", i3, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i3);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i3 = this.prerelease.length;
            while (--i3 >= 0) {
              if (typeof this.prerelease[i3] === "number") {
                this.prerelease[i3]++;
                i3 = -2;
              }
            }
            if (i3 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version2, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version2, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v12 = parse2(version1);
        var v2 = parse2(version2);
        var prefix = "";
        if (v12.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v12) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v12[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compare(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.rcompare(a, b, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug5("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug5("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r2 = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m2 = comp.match(r2);
      if (!m2) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m2[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m2[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version2) {
      debug5("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        version2 = new SemVer(version2, this.options);
      }
      return cmp(version2, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug5("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug5("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug5("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug5("caret", comp);
      comp = replaceTildes(comp, options);
      debug5("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug5("xrange", comp);
      comp = replaceStars(comp, options);
      debug5("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r2 = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r2, function(_, M, m2, p, pr) {
        debug5("tilde", comp, _, M, m2, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
        } else if (pr) {
          debug5("replaceTilde pr", pr);
          ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
        }
        debug5("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug5("caret", comp, options);
      var r2 = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r2, function(_, M, m2, p, pr) {
        debug5("caret", comp, _, M, m2, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m2 + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug5("replaceCaret pr", pr);
          if (M === "0") {
            if (m2 === "0") {
              ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + m2 + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug5("no pr");
          if (M === "0") {
            if (m2 === "0") {
              ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + m2 + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m2 + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug5("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug5("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r2 = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r2, function(ret, gtlt, M, m2, p, pr) {
        debug5("xRange", comp, ret, gtlt, M, m2, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m2);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m2 = 0;
              p = 0;
            } else {
              m2 = +m2 + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          ret = gtlt + M + "." + m2 + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
        }
        debug5("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug5("replaceStars", comp, options);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        version2 = new SemVer(version2, this.options);
      }
      for (var i3 = 0; i3 < this.set.length; i3++) {
        if (testSet(this.set[i3], version2, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version2, options) {
      for (var i3 = 0; i3 < set.length; i3++) {
        if (!set[i3].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (i3 = 0; i3 < set.length; i3++) {
          debug5(set[i3].semver);
          if (set[i3].semver === ANY) {
            continue;
          }
          if (set[i3].semver.prerelease.length > 0) {
            var allowed = set[i3].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version2, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i3 = 0; i3 < range.set.length; ++i3) {
        var comparators = range.set[i3];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version2, range, options) {
      return outside(version2, range, "<", options);
    }
    exports.gtr = gtr;
    function gtr(version2, range, options) {
      return outside(version2, range, ">", options);
    }
    exports.outside = outside;
    function outside(version2, range, hilo, options) {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (var i3 = 0; i3 < range.set.length; ++i3) {
        var comparators = range.set[i3];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version2, options) {
      var parsed = parse2(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports.coerce = coerce;
    function coerce(version2) {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      var match = version2.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse2(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// node_modules/execa/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "node_modules/execa/node_modules/cross-spawn/lib/parse.js"(exports, module2) {
    "use strict";
    var path8 = require("path");
    var niceTry = require_src();
    var resolveCommand = require_resolveCommand();
    var escape2 = require_escape();
    var readShebang = require_readShebang();
    var semver = require_semver();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    var supportsShellOption = niceTry(() => semver.satisfies(process.version, "^4.8.0 || ^5.7.0 || >= 6.0.0", true)) || false;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path8.normalize(parsed.command);
        parsed.command = escape2.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape2.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parseShell(parsed) {
      if (supportsShellOption) {
        return parsed;
      }
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      if (isWin) {
        parsed.command = typeof parsed.options.shell === "string" ? parsed.options.shell : process.env.comspec || "cmd.exe";
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.options.windowsVerbatimArguments = true;
      } else {
        if (typeof parsed.options.shell === "string") {
          parsed.command = parsed.options.shell;
        } else if (process.platform === "android") {
          parsed.command = "/system/bin/sh";
        } else {
          parsed.command = "/bin/sh";
        }
        parsed.args = ["-c", shellCommand];
      }
      return parsed;
    }
    function parse2(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parseShell(parsed) : parseNonShell(parsed);
    }
    module2.exports = parse2;
  }
});

// node_modules/execa/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "node_modules/execa/node_modules/cross-spawn/lib/enoent.js"(exports, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp2, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp2.emit;
      cp2.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp2, "error", err);
          }
        }
        return originalEmit.apply(cp2, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// node_modules/execa/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "node_modules/execa/node_modules/cross-spawn/index.js"(exports, module2) {
    "use strict";
    var cp2 = require("child_process");
    var parse2 = require_parse();
    var enoent = require_enoent();
    function spawn(command, args, options) {
      const parsed = parse2(command, args, options);
      const spawned = cp2.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      const parsed = parse2(command, args, options);
      const result = cp2.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse2;
    module2.exports._enoent = enoent;
  }
});

// node_modules/strip-eof/index.js
var require_strip_eof = __commonJS({
  "node_modules/strip-eof/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(x2) {
      var lf = typeof x2 === "string" ? "\n" : "\n".charCodeAt();
      var cr = typeof x2 === "string" ? "\r" : "\r".charCodeAt();
      if (x2[x2.length - 1] === lf) {
        x2 = x2.slice(0, x2.length - 1);
      }
      if (x2[x2.length - 1] === cr) {
        x2 = x2.slice(0, x2.length - 1);
      }
      return x2;
    };
  }
});

// node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS({
  "node_modules/npm-run-path/index.js"(exports, module2) {
    "use strict";
    var path8 = require("path");
    var pathKey = require_path_key();
    module2.exports = (opts) => {
      opts = Object.assign({
        cwd: process.cwd(),
        path: process.env[pathKey()]
      }, opts);
      let prev;
      let pth = path8.resolve(opts.cwd);
      const ret = [];
      while (prev !== pth) {
        ret.push(path8.join(pth, "node_modules/.bin"));
        prev = pth;
        pth = path8.resolve(pth, "..");
      }
      ret.push(path8.dirname(process.execPath));
      return ret.concat(opts.path).join(path8.delimiter);
    };
    module2.exports.env = (opts) => {
      opts = Object.assign({
        env: process.env
      }, opts);
      const env = Object.assign({}, opts.env);
      const path9 = pathKey({ env });
      opts.path = env[path9];
      env[path9] = module2.exports(opts);
      return env;
    };
  }
});

// node_modules/execa/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/execa/node_modules/is-stream/index.js"(exports, module2) {
    "use strict";
    var isStream = module2.exports = function(stream) {
      return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    };
    isStream.writable = function(stream) {
      return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    };
    isStream.readable = function(stream) {
      return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    };
    isStream.duplex = function(stream) {
      return isStream.writable(stream) && isStream.readable(stream);
    };
    isStream.transform = function(stream) {
      return isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f3 = function() {
        if (f3.called)
          return f3.value;
        f3.called = true;
        return f3.value = fn.apply(this, arguments);
      };
      f3.called = false;
      return f3;
    }
    function onceStrict(fn) {
      var f3 = function() {
        if (f3.called)
          throw new Error(f3.onceError);
        f3.called = true;
        return f3.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f3.onceError = name + " shouldn't be called more than once";
      f3.called = false;
      return f3;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports, module2) {
    var once = require_once();
    var noop2 = function() {
    };
    var isRequest2 = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop2);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest2(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports, module2) {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs8 = require("fs");
    var noop2 = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs8)
        return false;
      return (stream instanceof (fs8.ReadStream || noop2) || stream instanceof (fs8.WriteStream || noop2)) && isFn(stream.close);
    };
    var isRequest2 = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop2);
        if (isRequest2(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump2 = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop2) && streams.pop() || noop2;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error2;
      var destroys = streams.map(function(stream, i2) {
        var reading = i2 < streams.length - 1;
        var writing = i2 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error2)
            error2 = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error2);
        });
      });
      return streams.reduce(pipe);
    };
    module2.exports = pump2;
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/get-stream/buffer-stream.js"(exports, module2) {
    "use strict";
    var { PassThrough: PassThrough3 } = require("stream");
    module2.exports = (options) => {
      options = Object.assign({}, options);
      const { array } = options;
      let { encoding } = options;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      let len = 0;
      const ret = [];
      const stream = new PassThrough3({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      stream.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream.getBufferedLength = () => len;
      return stream;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/get-stream/index.js"(exports, module2) {
    "use strict";
    var pump2 = require_pump();
    var bufferStream = require_buffer_stream();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    function getStream(inputStream, options) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options = Object.assign({ maxBuffer: Infinity }, options);
      const { maxBuffer } = options;
      let stream;
      return new Promise((resolve2, reject) => {
        const rejectPromise = (error2) => {
          if (error2) {
            error2.bufferedData = stream.getBufferedValue();
          }
          reject(error2);
        };
        stream = pump2(inputStream, bufferStream(options), (error2) => {
          if (error2) {
            rejectPromise(error2);
            return;
          }
          resolve2();
        });
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      }).then(() => stream.getBufferedValue());
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream, options) => getStream(stream, Object.assign({}, options, { encoding: "buffer" }));
    module2.exports.array = (stream, options) => getStream(stream, Object.assign({}, options, { array: true }));
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then((val) => new Promise((resolve2) => {
        resolve2(onFinally());
      }).then(() => val), (err) => new Promise((resolve2) => {
        resolve2(onFinally());
      }).then(() => {
        throw err;
      }));
    };
  }
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/signals.js"(exports, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    }
    if (process.platform === "linux") {
      module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/signal-exit/index.js"(exports, module2) {
    var assert = require("assert");
    var signals = require_signals();
    var isWin = /^win/i.test(process.platform);
    var EE = require("events");
    if (typeof EE !== "function") {
      EE = EE.EventEmitter;
    }
    var emitter;
    if (process.__signal_exit_emitter__) {
      emitter = process.__signal_exit_emitter__;
    } else {
      emitter = process.__signal_exit_emitter__ = new EE();
      emitter.count = 0;
      emitter.emitted = {};
    }
    if (!emitter.infinite) {
      emitter.setMaxListeners(Infinity);
      emitter.infinite = true;
    }
    module2.exports = function(cb, opts) {
      assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
      if (loaded === false) {
        load();
      }
      var ev = "exit";
      if (opts && opts.alwaysLast) {
        ev = "afterexit";
      }
      var remove = function() {
        emitter.removeListener(ev, cb);
        if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
          unload();
        }
      };
      emitter.on(ev, cb);
      return remove;
    };
    module2.exports.unload = unload;
    function unload() {
      if (!loaded) {
        return;
      }
      loaded = false;
      signals.forEach(function(sig) {
        try {
          process.removeListener(sig, sigListeners[sig]);
        } catch (er) {
        }
      });
      process.emit = originalProcessEmit;
      process.reallyExit = originalProcessReallyExit;
      emitter.count -= 1;
    }
    function emit(event, code, signal) {
      if (emitter.emitted[event]) {
        return;
      }
      emitter.emitted[event] = true;
      emitter.emit(event, code, signal);
    }
    var sigListeners = {};
    signals.forEach(function(sig) {
      sigListeners[sig] = function listener() {
        var listeners = process.listeners(sig);
        if (listeners.length === emitter.count) {
          unload();
          emit("exit", null, sig);
          emit("afterexit", null, sig);
          if (isWin && sig === "SIGHUP") {
            sig = "SIGINT";
          }
          process.kill(process.pid, sig);
        }
      };
    });
    module2.exports.signals = function() {
      return signals;
    };
    module2.exports.load = load;
    var loaded = false;
    function load() {
      if (loaded) {
        return;
      }
      loaded = true;
      emitter.count += 1;
      signals = signals.filter(function(sig) {
        try {
          process.on(sig, sigListeners[sig]);
          return true;
        } catch (er) {
          return false;
        }
      });
      process.emit = processEmit;
      process.reallyExit = processReallyExit;
    }
    var originalProcessReallyExit = process.reallyExit;
    function processReallyExit(code) {
      process.exitCode = code || 0;
      emit("exit", process.exitCode, null);
      emit("afterexit", process.exitCode, null);
      originalProcessReallyExit.call(process, process.exitCode);
    }
    var originalProcessEmit = process.emit;
    function processEmit(ev, arg) {
      if (ev === "exit") {
        if (arg !== void 0) {
          process.exitCode = arg;
        }
        var ret = originalProcessEmit.apply(this, arguments);
        emit("exit", process.exitCode, null);
        emit("afterexit", process.exitCode, null);
        return ret;
      } else {
        return originalProcessEmit.apply(this, arguments);
      }
    }
  }
});

// node_modules/execa/lib/errname.js
var require_errname = __commonJS({
  "node_modules/execa/lib/errname.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var uv;
    if (typeof util.getSystemErrorName === "function") {
      module2.exports = util.getSystemErrorName;
    } else {
      try {
        uv = process.binding("uv");
        if (typeof uv.errname !== "function") {
          throw new TypeError("uv.errname is not a function");
        }
      } catch (err) {
        console.error("execa/lib/errname: unable to establish process.binding('uv')", err);
        uv = null;
      }
      module2.exports = (code) => errname(uv, code);
    }
    module2.exports.__test__ = errname;
    function errname(uv2, code) {
      if (uv2) {
        return uv2.errname(code);
      }
      if (!(code < 0)) {
        throw new Error("err >= 0");
      }
      return `Unknown system error ${code}`;
    }
  }
});

// node_modules/execa/lib/stdio.js
var require_stdio = __commonJS({
  "node_modules/execa/lib/stdio.js"(exports, module2) {
    "use strict";
    var alias = ["stdin", "stdout", "stderr"];
    var hasAlias = (opts) => alias.some((x2) => Boolean(opts[x2]));
    module2.exports = (opts) => {
      if (!opts) {
        return null;
      }
      if (opts.stdio && hasAlias(opts)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${alias.map((x2) => `\`${x2}\``).join(", ")}`);
      }
      if (typeof opts.stdio === "string") {
        return opts.stdio;
      }
      const stdio = opts.stdio || [];
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const result = [];
      const len = Math.max(stdio.length, alias.length);
      for (let i2 = 0; i2 < len; i2++) {
        let value = null;
        if (stdio[i2] !== void 0) {
          value = stdio[i2];
        } else if (opts[alias[i2]] !== void 0) {
          value = opts[alias[i2]];
        }
        result[i2] = value;
      }
      return result;
    };
  }
});

// node_modules/execa/index.js
var require_execa = __commonJS({
  "node_modules/execa/index.js"(exports, module2) {
    "use strict";
    var path8 = require("path");
    var childProcess = require("child_process");
    var crossSpawn = require_cross_spawn();
    var stripEof = require_strip_eof();
    var npmRunPath = require_npm_run_path();
    var isStream = require_is_stream();
    var _getStream = require_get_stream();
    var pFinally = require_p_finally();
    var onExit = require_signal_exit();
    var errname = require_errname();
    var stdio = require_stdio();
    var TEN_MEGABYTES = 1e3 * 1e3 * 10;
    function handleArgs(cmd, args, opts) {
      let parsed;
      opts = Object.assign({
        extendEnv: true,
        env: {}
      }, opts);
      if (opts.extendEnv) {
        opts.env = Object.assign({}, process.env, opts.env);
      }
      if (opts.__winShell === true) {
        delete opts.__winShell;
        parsed = {
          command: cmd,
          args,
          options: opts,
          file: cmd,
          original: {
            cmd,
            args
          }
        };
      } else {
        parsed = crossSpawn._parse(cmd, args, opts);
      }
      opts = Object.assign({
        maxBuffer: TEN_MEGABYTES,
        buffer: true,
        stripEof: true,
        preferLocal: true,
        localDir: parsed.options.cwd || process.cwd(),
        encoding: "utf8",
        reject: true,
        cleanup: true
      }, parsed.options);
      opts.stdio = stdio(opts);
      if (opts.preferLocal) {
        opts.env = npmRunPath.env(Object.assign({}, opts, { cwd: opts.localDir }));
      }
      if (opts.detached) {
        opts.cleanup = false;
      }
      if (process.platform === "win32" && path8.basename(parsed.command) === "cmd.exe") {
        parsed.args.unshift("/q");
      }
      return {
        cmd: parsed.command,
        args: parsed.args,
        opts,
        parsed
      };
    }
    function handleInput(spawned, input) {
      if (input === null || input === void 0) {
        return;
      }
      if (isStream(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    }
    function handleOutput(opts, val) {
      if (val && opts.stripEof) {
        val = stripEof(val);
      }
      return val;
    }
    function handleShell(fn, cmd, opts) {
      let file = "/bin/sh";
      let args = ["-c", cmd];
      opts = Object.assign({}, opts);
      if (process.platform === "win32") {
        opts.__winShell = true;
        file = process.env.comspec || "cmd.exe";
        args = ["/s", "/c", `"${cmd}"`];
        opts.windowsVerbatimArguments = true;
      }
      if (opts.shell) {
        file = opts.shell;
        delete opts.shell;
      }
      return fn(file, args, opts);
    }
    function getStream(process2, stream, { encoding, buffer, maxBuffer }) {
      if (!process2[stream]) {
        return null;
      }
      let ret;
      if (!buffer) {
        ret = new Promise((resolve2, reject) => {
          process2[stream].once("end", resolve2).once("error", reject);
        });
      } else if (encoding) {
        ret = _getStream(process2[stream], {
          encoding,
          maxBuffer
        });
      } else {
        ret = _getStream.buffer(process2[stream], { maxBuffer });
      }
      return ret.catch((err) => {
        err.stream = stream;
        err.message = `${stream} ${err.message}`;
        throw err;
      });
    }
    function makeError(result, options) {
      const { stdout, stderr } = result;
      let err = result.error;
      const { code, signal } = result;
      const { parsed, joinedCmd } = options;
      const timedOut = options.timedOut || false;
      if (!err) {
        let output = "";
        if (Array.isArray(parsed.opts.stdio)) {
          if (parsed.opts.stdio[2] !== "inherit") {
            output += output.length > 0 ? stderr : `
${stderr}`;
          }
          if (parsed.opts.stdio[1] !== "inherit") {
            output += `
${stdout}`;
          }
        } else if (parsed.opts.stdio !== "inherit") {
          output = `
${stderr}${stdout}`;
        }
        err = new Error(`Command failed: ${joinedCmd}${output}`);
        err.code = code < 0 ? errname(code) : code;
      }
      err.stdout = stdout;
      err.stderr = stderr;
      err.failed = true;
      err.signal = signal || null;
      err.cmd = joinedCmd;
      err.timedOut = timedOut;
      return err;
    }
    function joinCmd(cmd, args) {
      let joinedCmd = cmd;
      if (Array.isArray(args) && args.length > 0) {
        joinedCmd += " " + args.join(" ");
      }
      return joinedCmd;
    }
    module2.exports = (cmd, args, opts) => {
      const parsed = handleArgs(cmd, args, opts);
      const { encoding, buffer, maxBuffer } = parsed.opts;
      const joinedCmd = joinCmd(cmd, args);
      let spawned;
      try {
        spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
      } catch (err) {
        return Promise.reject(err);
      }
      let removeExitHandler;
      if (parsed.opts.cleanup) {
        removeExitHandler = onExit(() => {
          spawned.kill();
        });
      }
      let timeoutId = null;
      let timedOut = false;
      const cleanup = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        if (removeExitHandler) {
          removeExitHandler();
        }
      };
      if (parsed.opts.timeout > 0) {
        timeoutId = setTimeout(() => {
          timeoutId = null;
          timedOut = true;
          spawned.kill(parsed.opts.killSignal);
        }, parsed.opts.timeout);
      }
      const processDone = new Promise((resolve2) => {
        spawned.on("exit", (code, signal) => {
          cleanup();
          resolve2({ code, signal });
        });
        spawned.on("error", (err) => {
          cleanup();
          resolve2({ error: err });
        });
        if (spawned.stdin) {
          spawned.stdin.on("error", (err) => {
            cleanup();
            resolve2({ error: err });
          });
        }
      });
      function destroy() {
        if (spawned.stdout) {
          spawned.stdout.destroy();
        }
        if (spawned.stderr) {
          spawned.stderr.destroy();
        }
      }
      const handlePromise = () => pFinally(Promise.all([
        processDone,
        getStream(spawned, "stdout", { encoding, buffer, maxBuffer }),
        getStream(spawned, "stderr", { encoding, buffer, maxBuffer })
      ]).then((arr) => {
        const result = arr[0];
        result.stdout = arr[1];
        result.stderr = arr[2];
        if (result.error || result.code !== 0 || result.signal !== null) {
          const err = makeError(result, {
            joinedCmd,
            parsed,
            timedOut
          });
          err.killed = err.killed || spawned.killed;
          if (!parsed.opts.reject) {
            return err;
          }
          throw err;
        }
        return {
          stdout: handleOutput(parsed.opts, result.stdout),
          stderr: handleOutput(parsed.opts, result.stderr),
          code: 0,
          failed: false,
          killed: false,
          signal: null,
          cmd: joinedCmd,
          timedOut: false
        };
      }), destroy);
      crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);
      handleInput(spawned, parsed.opts.input);
      spawned.then = (onfulfilled, onrejected) => handlePromise().then(onfulfilled, onrejected);
      spawned.catch = (onrejected) => handlePromise().catch(onrejected);
      return spawned;
    };
    module2.exports.stdout = (...args) => module2.exports(...args).then((x2) => x2.stdout);
    module2.exports.stderr = (...args) => module2.exports(...args).then((x2) => x2.stderr);
    module2.exports.shell = (cmd, opts) => handleShell(module2.exports, cmd, opts);
    module2.exports.sync = (cmd, args, opts) => {
      const parsed = handleArgs(cmd, args, opts);
      const joinedCmd = joinCmd(cmd, args);
      if (isStream(parsed.opts.input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
      const result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);
      result.code = result.status;
      if (result.error || result.status !== 0 || result.signal !== null) {
        const err = makeError(result, {
          joinedCmd,
          parsed
        });
        if (!parsed.opts.reject) {
          return err;
        }
        throw err;
      }
      return {
        stdout: handleOutput(parsed.opts, result.stdout),
        stderr: handleOutput(parsed.opts, result.stderr),
        code: 0,
        failed: false,
        signal: null,
        cmd: joinedCmd,
        timedOut: false
      };
    };
    module2.exports.shellSync = (cmd, opts) => handleShell(module2.exports.sync, cmd, opts);
  }
});

// node_modules/windows-release/index.js
var require_windows_release = __commonJS({
  "node_modules/windows-release/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var execa = require_execa();
    var names = /* @__PURE__ */ new Map([
      ["10.0", "10"],
      ["6.3", "8.1"],
      ["6.2", "8"],
      ["6.1", "7"],
      ["6.0", "Vista"],
      ["5.2", "Server 2003"],
      ["5.1", "XP"],
      ["5.0", "2000"],
      ["4.9", "ME"],
      ["4.1", "98"],
      ["4.0", "95"]
    ]);
    var windowsRelease = (release) => {
      const version2 = /\d+\.\d/.exec(release || os.release());
      if (release && !version2) {
        throw new Error("`release` argument doesn't match `n.n`");
      }
      const ver = (version2 || [])[0];
      if ((!release || release === os.release()) && ["6.1", "6.2", "6.3", "10.0"].includes(ver)) {
        let stdout;
        try {
          stdout = execa.sync("wmic", ["os", "get", "Caption"]).stdout || "";
        } catch (_) {
          stdout = execa.sync("powershell", ["(Get-CimInstance -ClassName Win32_OperatingSystem).caption"]).stdout || "";
        }
        const year = (stdout.match(/2008|2012|2016|2019/) || [])[0];
        if (year) {
          return `Server ${year}`;
        }
      }
      return names.get(ver);
    };
    module2.exports = windowsRelease;
  }
});

// node_modules/os-name/index.js
var require_os_name = __commonJS({
  "node_modules/os-name/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var macosRelease = require_macos_release();
    var winRelease = require_windows_release();
    var osName = (platform, release) => {
      if (!platform && release) {
        throw new Error("You can't specify a `release` without specifying `platform`");
      }
      platform = platform || os.platform();
      let id;
      if (platform === "darwin") {
        if (!release && os.platform() === "darwin") {
          release = os.release();
        }
        const prefix = release ? Number(release.split(".")[0]) > 15 ? "macOS" : "OS X" : "macOS";
        id = release ? macosRelease(release).name : "";
        return prefix + (id ? " " + id : "");
      }
      if (platform === "linux") {
        if (!release && os.platform() === "linux") {
          release = os.release();
        }
        id = release ? release.replace(/^(\d+\.\d+).*/, "$1") : "";
        return "Linux" + (id ? " " + id : "");
      }
      if (platform === "win32") {
        if (!release && os.platform() === "win32") {
          release = os.release();
        }
        id = release ? winRelease(release) : "";
        return "Windows" + (id ? " " + id : "");
      }
      return platform;
    };
    module2.exports = osName;
  }
});

// node_modules/universal-user-agent/dist-node/index.js
var require_dist_node2 = __commonJS({
  "node_modules/universal-user-agent/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var osName = _interopDefault(require_os_name());
    function getUserAgent() {
      try {
        return `Node.js/${process.version.substr(1)} (${osName()}; ${process.arch})`;
      } catch (error2) {
        if (/wmic os get Caption/.test(error2.message)) {
          return "Windows <version undetectable>";
        }
        return "<environment undetectable>";
      }
    }
    exports.getUserAgent = getUserAgent;
  }
});

// node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node3 = __commonJS({
  "node_modules/@octokit/endpoint/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var isPlainObject = _interopDefault(require_index_cjs());
    var universalUserAgent = require_dist_node2();
    function lowercaseKeys(object) {
      if (!object) {
        return {};
      }
      return Object.keys(object).reduce((newObj, key) => {
        newObj[key.toLowerCase()] = object[key];
        return newObj;
      }, {});
    }
    function mergeDeep(defaults, options) {
      const result = Object.assign({}, defaults);
      Object.keys(options).forEach((key) => {
        if (isPlainObject(options[key])) {
          if (!(key in defaults))
            Object.assign(result, {
              [key]: options[key]
            });
          else
            result[key] = mergeDeep(defaults[key], options[key]);
        } else {
          Object.assign(result, {
            [key]: options[key]
          });
        }
      });
      return result;
    }
    function merge(defaults, route, options) {
      if (typeof route === "string") {
        let [method, url] = route.split(" ");
        options = Object.assign(url ? {
          method,
          url
        } : {
          url: method
        }, options);
      } else {
        options = Object.assign({}, route);
      }
      options.headers = lowercaseKeys(options.headers);
      const mergedOptions = mergeDeep(defaults || {}, options);
      if (defaults && defaults.mediaType.previews.length) {
        mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
      }
      mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
      return mergedOptions;
    }
    function addQueryParameters(url, parameters) {
      const separator = /\?/.test(url) ? "&" : "?";
      const names = Object.keys(parameters);
      if (names.length === 0) {
        return url;
      }
      return url + separator + names.map((name) => {
        if (name === "q") {
          return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
        }
        return `${name}=${encodeURIComponent(parameters[name])}`;
      }).join("&");
    }
    var urlVariableRegex = /\{[^}]+\}/g;
    function removeNonChars(variableName) {
      return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
    }
    function extractUrlVariableNames(url) {
      const matches = url.match(urlVariableRegex);
      if (!matches) {
        return [];
      }
      return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
    }
    function omit(object, keysToOmit) {
      return Object.keys(object).filter((option) => !keysToOmit.includes(option)).reduce((obj, key) => {
        obj[key] = object[key];
        return obj;
      }, {});
    }
    function encodeReserved(str) {
      return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
          part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
        }
        return part;
      }).join("");
    }
    function encodeUnreserved(str) {
      return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeValue(operator, value, key) {
      value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
      if (key) {
        return encodeUnreserved(key) + "=" + value;
      } else {
        return value;
      }
    }
    function isDefined(value) {
      return value !== void 0 && value !== null;
    }
    function isKeyOperator(operator) {
      return operator === ";" || operator === "&" || operator === "?";
    }
    function getValues(context2, operator, key, modifier) {
      var value = context2[key], result = [];
      if (isDefined(value) && value !== "") {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          value = value.toString();
          if (modifier && modifier !== "*") {
            value = value.substring(0, parseInt(modifier, 10));
          }
          result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
        } else {
          if (modifier === "*") {
            if (Array.isArray(value)) {
              value.filter(isDefined).forEach(function(value2) {
                result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
              });
            } else {
              Object.keys(value).forEach(function(k) {
                if (isDefined(value[k])) {
                  result.push(encodeValue(operator, value[k], k));
                }
              });
            }
          } else {
            const tmp = [];
            if (Array.isArray(value)) {
              value.filter(isDefined).forEach(function(value2) {
                tmp.push(encodeValue(operator, value2));
              });
            } else {
              Object.keys(value).forEach(function(k) {
                if (isDefined(value[k])) {
                  tmp.push(encodeUnreserved(k));
                  tmp.push(encodeValue(operator, value[k].toString()));
                }
              });
            }
            if (isKeyOperator(operator)) {
              result.push(encodeUnreserved(key) + "=" + tmp.join(","));
            } else if (tmp.length !== 0) {
              result.push(tmp.join(","));
            }
          }
        }
      } else {
        if (operator === ";") {
          if (isDefined(value)) {
            result.push(encodeUnreserved(key));
          }
        } else if (value === "" && (operator === "&" || operator === "?")) {
          result.push(encodeUnreserved(key) + "=");
        } else if (value === "") {
          result.push("");
        }
      }
      return result;
    }
    function parseUrl(template2) {
      return {
        expand: expand.bind(null, template2)
      };
    }
    function expand(template2, context2) {
      var operators = ["+", "#", ".", "/", ";", "?", "&"];
      return template2.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
        if (expression) {
          let operator = "";
          const values = [];
          if (operators.indexOf(expression.charAt(0)) !== -1) {
            operator = expression.charAt(0);
            expression = expression.substr(1);
          }
          expression.split(/,/g).forEach(function(variable) {
            var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
            values.push(getValues(context2, operator, tmp[1], tmp[2] || tmp[3]));
          });
          if (operator && operator !== "+") {
            var separator = ",";
            if (operator === "?") {
              separator = "&";
            } else if (operator !== "#") {
              separator = operator;
            }
            return (values.length !== 0 ? operator : "") + values.join(separator);
          } else {
            return values.join(",");
          }
        } else {
          return encodeReserved(literal);
        }
      });
    }
    function parse2(options) {
      let method = options.method.toUpperCase();
      let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{+$1}");
      let headers = Object.assign({}, options.headers);
      let body;
      let parameters = omit(options, ["method", "baseUrl", "url", "headers", "request", "mediaType"]);
      const urlVariableNames = extractUrlVariableNames(url);
      url = parseUrl(url).expand(parameters);
      if (!/^http/.test(url)) {
        url = options.baseUrl + url;
      }
      const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
      const remainingParameters = omit(parameters, omittedParameters);
      const isBinaryRequset = /application\/octet-stream/i.test(headers.accept);
      if (!isBinaryRequset) {
        if (options.mediaType.format) {
          headers.accept = headers.accept.split(/,/).map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
        }
        if (options.mediaType.previews.length) {
          const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
          headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
            const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
            return `application/vnd.github.${preview}-preview${format}`;
          }).join(",");
        }
      }
      if (["GET", "HEAD"].includes(method)) {
        url = addQueryParameters(url, remainingParameters);
      } else {
        if ("data" in remainingParameters) {
          body = remainingParameters.data;
        } else {
          if (Object.keys(remainingParameters).length) {
            body = remainingParameters;
          } else {
            headers["content-length"] = 0;
          }
        }
      }
      if (!headers["content-type"] && typeof body !== "undefined") {
        headers["content-type"] = "application/json; charset=utf-8";
      }
      if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
        body = "";
      }
      return Object.assign({
        method,
        url,
        headers
      }, typeof body !== "undefined" ? {
        body
      } : null, options.request ? {
        request: options.request
      } : null);
    }
    function endpointWithDefaults(defaults, route, options) {
      return parse2(merge(defaults, route, options));
    }
    function withDefaults(oldDefaults, newDefaults) {
      const DEFAULTS2 = merge(oldDefaults, newDefaults);
      const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
      return Object.assign(endpoint2, {
        DEFAULTS: DEFAULTS2,
        defaults: withDefaults.bind(null, DEFAULTS2),
        merge: merge.bind(null, DEFAULTS2),
        parse: parse2
      });
    }
    var VERSION = "6.0.3";
    var userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`;
    var DEFAULTS = {
      method: "GET",
      baseUrl: "https://api.github.com",
      headers: {
        accept: "application/vnd.github.v3+json",
        "user-agent": userAgent
      },
      mediaType: {
        format: "",
        previews: []
      }
    };
    var endpoint = withDefaults(null, DEFAULTS);
    exports.endpoint = endpoint;
  }
});

// node_modules/@octokit/request/node_modules/is-plain-object/index.cjs.js
var require_index_cjs2 = __commonJS({
  "node_modules/@octokit/request/node_modules/is-plain-object/index.cjs.js"(exports, module2) {
    "use strict";
    function isObject(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    }
    function isObjectObject(o) {
      return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    function isPlainObject(o) {
      var ctor, prot;
      if (isObjectObject(o) === false)
        return false;
      ctor = o.constructor;
      if (typeof ctor !== "function")
        return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream3 = _interopDefault(require("stream"));
    var http3 = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var https2 = _interopDefault(require("https"));
    var zlib2 = _interopDefault(require("zlib"));
    var Readable = Stream3.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob4 = class {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i2 = 0; i2 < length; i2++) {
            const element = a[i2];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof Blob4) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob4([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob4.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob4.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError2(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError2.prototype = Object.create(Error.prototype);
    FetchError2.prototype.constructor = FetchError2;
    FetchError2.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e2) {
    }
    var INTERNALS4 = Symbol("Body internals");
    var PassThrough3 = Stream3.PassThrough;
    function Body2(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob2(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream3)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS4] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream3) {
        body.on("error", function(err) {
          const error2 = err.name === "AbortError" ? err : new FetchError2(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS4].error = error2;
        });
      }
    }
    Body2.prototype = {
      get body() {
        return this[INTERNALS4].body;
      },
      get bodyUsed() {
        return this[INTERNALS4].disturbed;
      },
      arrayBuffer() {
        return consumeBody2.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody2.call(this).then(function(buf) {
          return Object.assign(new Blob4([], {
            type: ct.toLowerCase()
          }), {
            [BUFFER]: buf
          });
        });
      },
      json() {
        var _this2 = this;
        return consumeBody2.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body2.Promise.reject(new FetchError2(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      text() {
        return consumeBody2.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      buffer() {
        return consumeBody2.call(this);
      },
      textConverted() {
        var _this3 = this;
        return consumeBody2.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body2.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body2.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body2.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body2.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody2() {
      var _this4 = this;
      if (this[INTERNALS4].disturbed) {
        return Body2.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS4].disturbed = true;
      if (this[INTERNALS4].error) {
        return Body2.Promise.reject(this[INTERNALS4].error);
      }
      let body = this.body;
      if (body === null) {
        return Body2.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob2(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body2.Promise.resolve(body);
      }
      if (!(body instanceof Stream3)) {
        return Body2.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body2.Promise(function(resolve2, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError2(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError2(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError2(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve2(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError2(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob2(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone2(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream3 && typeof body.getBoundary !== "function") {
        p1 = new PassThrough3();
        p2 = new PassThrough3();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS4].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType2(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob2(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream3) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes2(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob2(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream2(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob2(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body2.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers2 = class {
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof Headers2) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i2 = 0;
        while (i2 < pairs.length) {
          var _pairs$i = pairs[i2];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i2++;
        }
      }
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      raw() {
        return this[MAP];
      }
      keys() {
        return createHeadersIterator(this, "key");
      }
      values() {
        return createHeadersIterator(this, "value");
      }
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
    Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers2.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers2();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http3.STATUS_CODES;
    var Response2 = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body2.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers2(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType2(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      clone() {
        return new Response2(clone2(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body2.mixIn(Response2.prototype);
    Object.defineProperties(Response2.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var parse_url = Url.parse;
    var format_url = Url.format;
    var streamDestructionSupported = "destroy" in Stream3.Readable.prototype;
    function isRequest2(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal2(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request2 = class {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest2(input)) {
          if (input && input.href) {
            parsedURL = parse_url(input.href);
          } else {
            parsedURL = parse_url(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parse_url(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest2(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest2(input) && input.body !== null ? clone2(input) : null;
        Body2.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers2(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType2(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest2(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal2(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      clone() {
        return new Request2(this);
      }
    };
    Body2.mixIn(Request2.prototype);
    Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions2(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers2(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream3.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes2(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError2(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError2.prototype = Object.create(Error.prototype);
    AbortError2.prototype.constructor = AbortError2;
    AbortError2.prototype.name = "AbortError";
    var PassThrough$1 = Stream3.PassThrough;
    var resolve_url = Url.resolve;
    function fetch3(url, opts) {
      if (!fetch3.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body2.Promise = fetch3.Promise;
      return new fetch3.Promise(function(resolve2, reject) {
        const request = new Request2(url, opts);
        const options = getNodeRequestOptions2(request);
        const send = (options.protocol === "https:" ? https2 : http3).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error2 = new AbortError2("The user aborted a request.");
          reject(error2);
          if (request.body && request.body instanceof Stream3.Readable) {
            request.body.destroy(error2);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error2);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError2(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError2(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch3.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            const locationURL = location === null ? null : resolve_url(request.url, location);
            switch (request.redirect) {
              case "error":
                reject(new FetchError2(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError2(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers2(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (res.statusCode !== 303 && request.body && getTotalBytes2(request) === null) {
                  reject(new FetchError2("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve2(fetch3(new Request2(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          const zlibOptions = {
            flush: zlib2.Z_SYNC_FLUSH,
            finishFlush: zlib2.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib2.createGunzip(zlibOptions));
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib2.createInflate());
              } else {
                body = body.pipe(zlib2.createInflateRaw());
              }
              response = new Response2(body, response_options);
              resolve2(response);
            });
            return;
          }
          if (codings == "br" && typeof zlib2.createBrotliDecompress === "function") {
            body = body.pipe(zlib2.createBrotliDecompress());
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          response = new Response2(body, response_options);
          resolve2(response);
        });
        writeToStream2(req, request);
      });
    }
    fetch3.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch3.Promise = global.Promise;
    module2.exports = exports = fetch3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = exports;
    exports.Headers = Headers2;
    exports.Request = Request2;
    exports.Response = Response2;
    exports.FetchError = FetchError2;
  }
});

// node_modules/deprecation/dist-node/index.js
var require_dist_node4 = __commonJS({
  "node_modules/deprecation/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Deprecation = class extends Error {
      constructor(message) {
        super(message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "Deprecation";
      }
    };
    exports.Deprecation = Deprecation;
  }
});

// node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node5 = __commonJS({
  "node_modules/@octokit/request-error/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var deprecation = require_dist_node4();
    var once = _interopDefault(require_once());
    var logOnce = once((deprecation2) => console.warn(deprecation2));
    var RequestError = class extends Error {
      constructor(message, statusCode, options) {
        super(message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "HttpError";
        this.status = statusCode;
        Object.defineProperty(this, "code", {
          get() {
            logOnce(new deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
            return statusCode;
          }
        });
        this.headers = options.headers || {};
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
          requestCopy.headers = Object.assign({}, options.request.headers, {
            authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
          });
        }
        requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
      }
    };
    exports.RequestError = RequestError;
  }
});

// node_modules/@octokit/request/dist-node/index.js
var require_dist_node6 = __commonJS({
  "node_modules/@octokit/request/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var endpoint = require_dist_node3();
    var universalUserAgent = require_dist_node2();
    var isPlainObject = _interopDefault(require_index_cjs2());
    var nodeFetch = _interopDefault(require_lib());
    var requestError = require_dist_node5();
    var VERSION = "5.4.5";
    function getBufferResponse(response) {
      return response.arrayBuffer();
    }
    function fetchWrapper(requestOptions) {
      if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
        requestOptions.body = JSON.stringify(requestOptions.body);
      }
      let headers = {};
      let status;
      let url;
      const fetch3 = requestOptions.request && requestOptions.request.fetch || nodeFetch;
      return fetch3(requestOptions.url, Object.assign({
        method: requestOptions.method,
        body: requestOptions.body,
        headers: requestOptions.headers,
        redirect: requestOptions.redirect
      }, requestOptions.request)).then((response) => {
        url = response.url;
        status = response.status;
        for (const keyAndValue of response.headers) {
          headers[keyAndValue[0]] = keyAndValue[1];
        }
        if (status === 204 || status === 205) {
          return;
        }
        if (requestOptions.method === "HEAD") {
          if (status < 400) {
            return;
          }
          throw new requestError.RequestError(response.statusText, status, {
            headers,
            request: requestOptions
          });
        }
        if (status === 304) {
          throw new requestError.RequestError("Not modified", status, {
            headers,
            request: requestOptions
          });
        }
        if (status >= 400) {
          return response.text().then((message) => {
            const error2 = new requestError.RequestError(message, status, {
              headers,
              request: requestOptions
            });
            try {
              let responseBody = JSON.parse(error2.message);
              Object.assign(error2, responseBody);
              let errors = responseBody.errors;
              error2.message = error2.message + ": " + errors.map(JSON.stringify).join(", ");
            } catch (e2) {
            }
            throw error2;
          });
        }
        const contentType = response.headers.get("content-type");
        if (/application\/json/.test(contentType)) {
          return response.json();
        }
        if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
          return response.text();
        }
        return getBufferResponse(response);
      }).then((data) => {
        return {
          status,
          url,
          headers,
          data
        };
      }).catch((error2) => {
        if (error2 instanceof requestError.RequestError) {
          throw error2;
        }
        throw new requestError.RequestError(error2.message, 500, {
          headers,
          request: requestOptions
        });
      });
    }
    function withDefaults(oldEndpoint, newDefaults) {
      const endpoint2 = oldEndpoint.defaults(newDefaults);
      const newApi = function(route, parameters) {
        const endpointOptions = endpoint2.merge(route, parameters);
        if (!endpointOptions.request || !endpointOptions.request.hook) {
          return fetchWrapper(endpoint2.parse(endpointOptions));
        }
        const request2 = (route2, parameters2) => {
          return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
        };
        Object.assign(request2, {
          endpoint: endpoint2,
          defaults: withDefaults.bind(null, endpoint2)
        });
        return endpointOptions.request.hook(request2, endpointOptions);
      };
      return Object.assign(newApi, {
        endpoint: endpoint2,
        defaults: withDefaults.bind(null, endpoint2)
      });
    }
    var request = withDefaults(endpoint.endpoint, {
      headers: {
        "user-agent": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`
      }
    });
    exports.request = request;
  }
});

// node_modules/@octokit/graphql/dist-node/index.js
var require_dist_node7 = __commonJS({
  "node_modules/@octokit/graphql/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var request = require_dist_node6();
    var universalUserAgent = require_dist_node2();
    var VERSION = "4.5.1";
    var GraphqlError = class extends Error {
      constructor(request2, response) {
        const message = response.data.errors[0].message;
        super(message);
        Object.assign(this, response.data);
        this.name = "GraphqlError";
        this.request = request2;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
    var NON_VARIABLE_OPTIONS = ["method", "baseUrl", "url", "headers", "request", "query", "mediaType"];
    function graphql(request2, query, options) {
      options = typeof query === "string" ? options = Object.assign({
        query
      }, options) : options = query;
      const requestOptions = Object.keys(options).reduce((result, key) => {
        if (NON_VARIABLE_OPTIONS.includes(key)) {
          result[key] = options[key];
          return result;
        }
        if (!result.variables) {
          result.variables = {};
        }
        result.variables[key] = options[key];
        return result;
      }, {});
      return request2(requestOptions).then((response) => {
        if (response.data.errors) {
          throw new GraphqlError(requestOptions, {
            data: response.data
          });
        }
        return response.data.data;
      });
    }
    function withDefaults(request$1, newDefaults) {
      const newRequest = request$1.defaults(newDefaults);
      const newApi = (query, options) => {
        return graphql(newRequest, query, options);
      };
      return Object.assign(newApi, {
        defaults: withDefaults.bind(null, newRequest),
        endpoint: request.request.endpoint
      });
    }
    var graphql$1 = withDefaults(request.request, {
      headers: {
        "user-agent": `octokit-graphql.js/${VERSION} ${universalUserAgent.getUserAgent()}`
      },
      method: "POST",
      url: "/graphql"
    });
    function withCustomRequest(customRequest) {
      return withDefaults(customRequest, {
        method: "POST",
        url: "/graphql"
      });
    }
    exports.graphql = graphql$1;
    exports.withCustomRequest = withCustomRequest;
  }
});

// node_modules/@octokit/auth-token/dist-node/index.js
var require_dist_node8 = __commonJS({
  "node_modules/@octokit/auth-token/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function auth(token2) {
      const tokenType = token2.split(/\./).length === 3 ? "app" : /^v\d+\./.test(token2) ? "installation" : "oauth";
      return {
        type: "token",
        token: token2,
        tokenType
      };
    }
    function withAuthorizationPrefix(token2) {
      if (token2.split(/\./).length === 3) {
        return `bearer ${token2}`;
      }
      return `token ${token2}`;
    }
    async function hook(token2, request, route, parameters) {
      const endpoint = request.endpoint.merge(route, parameters);
      endpoint.headers.authorization = withAuthorizationPrefix(token2);
      return request(endpoint);
    }
    var createTokenAuth = function createTokenAuth2(token2) {
      if (!token2) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
      }
      if (typeof token2 !== "string") {
        throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
      }
      token2 = token2.replace(/^(token|bearer) +/i, "");
      return Object.assign(auth.bind(null, token2), {
        hook: hook.bind(null, token2)
      });
    };
    exports.createTokenAuth = createTokenAuth;
  }
});

// node_modules/@octokit/core/dist-node/index.js
var require_dist_node9 = __commonJS({
  "node_modules/@octokit/core/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var universalUserAgent = require_dist_node();
    var beforeAfterHook = require_before_after_hook();
    var request = require_dist_node6();
    var graphql = require_dist_node7();
    var authToken = require_dist_node8();
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        if (i2 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    var VERSION = "3.1.2";
    var Octokit = class {
      constructor(options = {}) {
        const hook = new beforeAfterHook.Collection();
        const requestDefaults = {
          baseUrl: request.request.endpoint.DEFAULTS.baseUrl,
          headers: {},
          request: Object.assign({}, options.request, {
            hook: hook.bind(null, "request")
          }),
          mediaType: {
            previews: [],
            format: ""
          }
        };
        requestDefaults.headers["user-agent"] = [options.userAgent, `octokit-core.js/${VERSION} ${universalUserAgent.getUserAgent()}`].filter(Boolean).join(" ");
        if (options.baseUrl) {
          requestDefaults.baseUrl = options.baseUrl;
        }
        if (options.previews) {
          requestDefaults.mediaType.previews = options.previews;
        }
        if (options.timeZone) {
          requestDefaults.headers["time-zone"] = options.timeZone;
        }
        this.request = request.request.defaults(requestDefaults);
        this.graphql = graphql.withCustomRequest(this.request).defaults(_objectSpread2(_objectSpread2({}, requestDefaults), {}, {
          baseUrl: requestDefaults.baseUrl.replace(/\/api\/v3$/, "/api")
        }));
        this.log = Object.assign({
          debug: () => {
          },
          info: () => {
          },
          warn: console.warn.bind(console),
          error: console.error.bind(console)
        }, options.log);
        this.hook = hook;
        if (!options.authStrategy) {
          if (!options.auth) {
            this.auth = async () => ({
              type: "unauthenticated"
            });
          } else {
            const auth = authToken.createTokenAuth(options.auth);
            hook.wrap("request", auth.hook);
            this.auth = auth;
          }
        } else {
          const auth = options.authStrategy(Object.assign({
            request: this.request
          }, options.auth));
          hook.wrap("request", auth.hook);
          this.auth = auth;
        }
        const classConstructor = this.constructor;
        classConstructor.plugins.forEach((plugin) => {
          Object.assign(this, plugin(this, options));
        });
      }
      static defaults(defaults) {
        const OctokitWithDefaults = class extends this {
          constructor(...args) {
            const options = args[0] || {};
            if (typeof defaults === "function") {
              super(defaults(options));
              return;
            }
            super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null));
          }
        };
        return OctokitWithDefaults;
      }
      static plugin(...newPlugins) {
        var _a;
        const currentPlugins = this.plugins;
        const NewOctokit = (_a = class extends this {
        }, _a.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin))), _a);
        return NewOctokit;
      }
    };
    Octokit.VERSION = VERSION;
    Octokit.plugins = [];
    exports.Octokit = Octokit;
  }
});

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node10 = __commonJS({
  "node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Endpoints = {
      actions: {
        addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
        cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
        createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
        createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
        createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
        createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
        createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
        deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
        deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
        deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
        deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
        deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
        downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
        downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
        downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
        getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
        getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
        getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
        getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
        getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
        getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
        getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
        listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
        listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
        listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
        listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
        listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
        listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
        listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
        listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
        listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
        listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
        listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
        listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
        reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
        removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
        setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"]
      },
      activity: {
        checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
        deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
        deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
        getFeeds: ["GET /feeds"],
        getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
        getThread: ["GET /notifications/threads/{thread_id}"],
        getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
        listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
        listNotificationsForAuthenticatedUser: ["GET /notifications"],
        listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
        listPublicEvents: ["GET /events"],
        listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
        listPublicEventsForUser: ["GET /users/{username}/events/public"],
        listPublicOrgEvents: ["GET /orgs/{org}/events"],
        listReceivedEventsForUser: ["GET /users/{username}/received_events"],
        listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
        listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
        listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
        listReposStarredByAuthenticatedUser: ["GET /user/starred"],
        listReposStarredByUser: ["GET /users/{username}/starred"],
        listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
        listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
        listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
        listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
        markNotificationsAsRead: ["PUT /notifications"],
        markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
        markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
        setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
        setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
        starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
        unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
      },
      apps: {
        addRepoToInstallation: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
        checkToken: ["POST /applications/{client_id}/token"],
        createContentAttachment: ["POST /content_references/{content_reference_id}/attachments", {
          mediaType: {
            previews: ["corsair"]
          }
        }],
        createFromManifest: ["POST /app-manifests/{code}/conversions"],
        createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
        deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
        deleteInstallation: ["DELETE /app/installations/{installation_id}"],
        deleteToken: ["DELETE /applications/{client_id}/token"],
        getAuthenticated: ["GET /app"],
        getBySlug: ["GET /apps/{app_slug}"],
        getInstallation: ["GET /app/installations/{installation_id}"],
        getOrgInstallation: ["GET /orgs/{org}/installation"],
        getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
        getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
        getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
        getUserInstallation: ["GET /users/{username}/installation"],
        listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
        listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
        listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
        listInstallations: ["GET /app/installations"],
        listInstallationsForAuthenticatedUser: ["GET /user/installations"],
        listPlans: ["GET /marketplace_listing/plans"],
        listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
        listReposAccessibleToInstallation: ["GET /installation/repositories"],
        listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
        listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
        removeRepoFromInstallation: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
        resetToken: ["PATCH /applications/{client_id}/token"],
        revokeInstallationAccessToken: ["DELETE /installation/token"],
        suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
        unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"]
      },
      billing: {
        getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
        getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
        getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
        getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
        getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
        getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
      },
      checks: {
        create: ["POST /repos/{owner}/{repo}/check-runs", {
          mediaType: {
            previews: ["antiope"]
          }
        }],
        createSuite: ["POST /repos/{owner}/{repo}/check-suites", {
          mediaType: {
            previews: ["antiope"]
          }
        }],
        get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}", {
          mediaType: {
            previews: ["antiope"]
          }
        }],
        getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}", {
          mediaType: {
            previews: ["antiope"]
          }
        }],
        listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations", {
          mediaType: {
            previews: ["antiope"]
          }
        }],
        listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs", {
          mediaType: {
            previews: ["antiope"]
          }
        }],
        listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs", {
          mediaType: {
            previews: ["antiope"]
          }
        }],
        listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites", {
          mediaType: {
            previews: ["antiope"]
          }
        }],
        rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest", {
          mediaType: {
            previews: ["antiope"]
          }
        }],
        setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences", {
          mediaType: {
            previews: ["antiope"]
          }
        }],
        update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}", {
          mediaType: {
            previews: ["antiope"]
          }
        }]
      },
      codeScanning: {
        getAlert: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}", {}, {
          renamedParameters: {
            alert_id: "alert_number"
          }
        }],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
        listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
        updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
        uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
      },
      codesOfConduct: {
        getAllCodesOfConduct: ["GET /codes_of_conduct", {
          mediaType: {
            previews: ["scarlet-witch"]
          }
        }],
        getConductCode: ["GET /codes_of_conduct/{key}", {
          mediaType: {
            previews: ["scarlet-witch"]
          }
        }],
        getForRepo: ["GET /repos/{owner}/{repo}/community/code_of_conduct", {
          mediaType: {
            previews: ["scarlet-witch"]
          }
        }]
      },
      emojis: {
        get: ["GET /emojis"]
      },
      gists: {
        checkIsStarred: ["GET /gists/{gist_id}/star"],
        create: ["POST /gists"],
        createComment: ["POST /gists/{gist_id}/comments"],
        delete: ["DELETE /gists/{gist_id}"],
        deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
        fork: ["POST /gists/{gist_id}/forks"],
        get: ["GET /gists/{gist_id}"],
        getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
        getRevision: ["GET /gists/{gist_id}/{sha}"],
        list: ["GET /gists"],
        listComments: ["GET /gists/{gist_id}/comments"],
        listCommits: ["GET /gists/{gist_id}/commits"],
        listForUser: ["GET /users/{username}/gists"],
        listForks: ["GET /gists/{gist_id}/forks"],
        listPublic: ["GET /gists/public"],
        listStarred: ["GET /gists/starred"],
        star: ["PUT /gists/{gist_id}/star"],
        unstar: ["DELETE /gists/{gist_id}/star"],
        update: ["PATCH /gists/{gist_id}"],
        updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
      },
      git: {
        createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
        createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
        createRef: ["POST /repos/{owner}/{repo}/git/refs"],
        createTag: ["POST /repos/{owner}/{repo}/git/tags"],
        createTree: ["POST /repos/{owner}/{repo}/git/trees"],
        deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
        getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
        getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
        getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
        getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
        getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
        listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
        updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
      },
      gitignore: {
        getAllTemplates: ["GET /gitignore/templates"],
        getTemplate: ["GET /gitignore/templates/{name}"]
      },
      interactions: {
        getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits", {
          mediaType: {
            previews: ["sombra"]
          }
        }],
        getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits", {
          mediaType: {
            previews: ["sombra"]
          }
        }],
        removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits", {
          mediaType: {
            previews: ["sombra"]
          }
        }],
        removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits", {
          mediaType: {
            previews: ["sombra"]
          }
        }],
        setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits", {
          mediaType: {
            previews: ["sombra"]
          }
        }],
        setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits", {
          mediaType: {
            previews: ["sombra"]
          }
        }]
      },
      issues: {
        addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
        addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
        create: ["POST /repos/{owner}/{repo}/issues"],
        createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        createLabel: ["POST /repos/{owner}/{repo}/labels"],
        createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
        deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
        deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
        get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
        getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
        getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
        getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
        list: ["GET /issues"],
        listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
        listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
        listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
        listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
        listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline", {
          mediaType: {
            previews: ["mockingbird"]
          }
        }],
        listForAuthenticatedUser: ["GET /user/issues"],
        listForOrg: ["GET /orgs/{org}/issues"],
        listForRepo: ["GET /repos/{owner}/{repo}/issues"],
        listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
        listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
        listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
        lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
        removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
        setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
        updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
        updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
      },
      licenses: {
        get: ["GET /licenses/{license}"],
        getAllCommonlyUsed: ["GET /licenses"],
        getForRepo: ["GET /repos/{owner}/{repo}/license"]
      },
      markdown: {
        render: ["POST /markdown"],
        renderRaw: ["POST /markdown/raw", {
          headers: {
            "content-type": "text/plain; charset=utf-8"
          }
        }]
      },
      meta: {
        get: ["GET /meta"]
      },
      migrations: {
        cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
        deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
        getImportStatus: ["GET /repos/{owner}/{repo}/import"],
        getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
        getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        listForAuthenticatedUser: ["GET /user/migrations", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        listForOrg: ["GET /orgs/{org}/migrations", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        listReposForUser: ["GET /user/migrations/{migration_id}/repositories", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
        setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
        startForAuthenticatedUser: ["POST /user/migrations"],
        startForOrg: ["POST /orgs/{org}/migrations"],
        startImport: ["PUT /repos/{owner}/{repo}/import"],
        unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock", {
          mediaType: {
            previews: ["wyandotte"]
          }
        }],
        updateImport: ["PATCH /repos/{owner}/{repo}/import"]
      },
      orgs: {
        blockUser: ["PUT /orgs/{org}/blocks/{username}"],
        checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
        checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
        checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
        convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
        createInvitation: ["POST /orgs/{org}/invitations"],
        createWebhook: ["POST /orgs/{org}/hooks"],
        deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
        get: ["GET /orgs/{org}"],
        getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
        getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
        getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
        list: ["GET /organizations"],
        listAppInstallations: ["GET /orgs/{org}/installations"],
        listBlockedUsers: ["GET /orgs/{org}/blocks"],
        listForAuthenticatedUser: ["GET /user/orgs"],
        listForUser: ["GET /users/{username}/orgs"],
        listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
        listMembers: ["GET /orgs/{org}/members"],
        listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
        listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
        listPendingInvitations: ["GET /orgs/{org}/invitations"],
        listPublicMembers: ["GET /orgs/{org}/public_members"],
        listWebhooks: ["GET /orgs/{org}/hooks"],
        pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
        removeMember: ["DELETE /orgs/{org}/members/{username}"],
        removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
        removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
        removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
        setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
        setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
        unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
        update: ["PATCH /orgs/{org}"],
        updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
        updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"]
      },
      projects: {
        addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        createCard: ["POST /projects/columns/{column_id}/cards", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        createColumn: ["POST /projects/{project_id}/columns", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        createForAuthenticatedUser: ["POST /user/projects", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        createForOrg: ["POST /orgs/{org}/projects", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        createForRepo: ["POST /repos/{owner}/{repo}/projects", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        delete: ["DELETE /projects/{project_id}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        deleteCard: ["DELETE /projects/columns/cards/{card_id}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        deleteColumn: ["DELETE /projects/columns/{column_id}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        get: ["GET /projects/{project_id}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        getCard: ["GET /projects/columns/cards/{card_id}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        getColumn: ["GET /projects/columns/{column_id}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        listCards: ["GET /projects/columns/{column_id}/cards", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        listCollaborators: ["GET /projects/{project_id}/collaborators", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        listColumns: ["GET /projects/{project_id}/columns", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        listForOrg: ["GET /orgs/{org}/projects", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        listForRepo: ["GET /repos/{owner}/{repo}/projects", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        listForUser: ["GET /users/{username}/projects", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        moveCard: ["POST /projects/columns/cards/{card_id}/moves", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        moveColumn: ["POST /projects/columns/{column_id}/moves", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        update: ["PATCH /projects/{project_id}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        updateCard: ["PATCH /projects/columns/cards/{card_id}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        updateColumn: ["PATCH /projects/columns/{column_id}", {
          mediaType: {
            previews: ["inertia"]
          }
        }]
      },
      pulls: {
        checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        create: ["POST /repos/{owner}/{repo}/pulls"],
        createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
        createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
        deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
        get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
        getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        list: ["GET /repos/{owner}/{repo}/pulls"],
        listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
        listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
        listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
        listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
        listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
        listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
        update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
        updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch", {
          mediaType: {
            previews: ["lydian"]
          }
        }],
        updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
      },
      rateLimit: {
        get: ["GET /rate_limit"]
      },
      reactions: {
        createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        deleteLegacy: ["DELETE /reactions/{reaction_id}", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }, {
          deprecated: "octokit.reactions.deleteLegacy() is deprecated, see https://developer.github.com/v3/reactions/#delete-a-reaction-legacy"
        }],
        listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }],
        listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", {
          mediaType: {
            previews: ["squirrel-girl"]
          }
        }]
      },
      repos: {
        acceptInvitation: ["PATCH /user/repository_invitations/{invitation_id}"],
        addAppAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
          mapToData: "apps"
        }],
        addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
        addStatusCheckContexts: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
          mapToData: "contexts"
        }],
        addTeamAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
          mapToData: "teams"
        }],
        addUserAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
          mapToData: "users"
        }],
        checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
        checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts", {
          mediaType: {
            previews: ["dorian"]
          }
        }],
        compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
        createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
        createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
          mediaType: {
            previews: ["zzzax"]
          }
        }],
        createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
        createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
        createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
        createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
        createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
        createForAuthenticatedUser: ["POST /user/repos"],
        createFork: ["POST /repos/{owner}/{repo}/forks"],
        createInOrg: ["POST /orgs/{org}/repos"],
        createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
        createPagesSite: ["POST /repos/{owner}/{repo}/pages", {
          mediaType: {
            previews: ["switcheroo"]
          }
        }],
        createRelease: ["POST /repos/{owner}/{repo}/releases"],
        createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate", {
          mediaType: {
            previews: ["baptiste"]
          }
        }],
        createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
        declineInvitation: ["DELETE /user/repository_invitations/{invitation_id}"],
        delete: ["DELETE /repos/{owner}/{repo}"],
        deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
        deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
        deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
        deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
          mediaType: {
            previews: ["zzzax"]
          }
        }],
        deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
        deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
        deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
        deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
        deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages", {
          mediaType: {
            previews: ["switcheroo"]
          }
        }],
        deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
        deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
        disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes", {
          mediaType: {
            previews: ["london"]
          }
        }],
        disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts", {
          mediaType: {
            previews: ["dorian"]
          }
        }],
        downloadArchive: ["GET /repos/{owner}/{repo}/{archive_format}/{ref}"],
        enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes", {
          mediaType: {
            previews: ["london"]
          }
        }],
        enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts", {
          mediaType: {
            previews: ["dorian"]
          }
        }],
        get: ["GET /repos/{owner}/{repo}"],
        getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
        getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
        getAllTopics: ["GET /repos/{owner}/{repo}/topics", {
          mediaType: {
            previews: ["mercy"]
          }
        }],
        getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
        getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
        getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
        getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
        getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
        getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
        getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
        getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
        getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
        getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
        getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
          mediaType: {
            previews: ["zzzax"]
          }
        }],
        getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile", {
          mediaType: {
            previews: ["black-panther"]
          }
        }],
        getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
        getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
        getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
        getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
        getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
        getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
        getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
        getPages: ["GET /repos/{owner}/{repo}/pages"],
        getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
        getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
        getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
        getReadme: ["GET /repos/{owner}/{repo}/readme"],
        getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
        getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
        getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
        getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
        getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
        getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
        getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
        getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
        listBranches: ["GET /repos/{owner}/{repo}/branches"],
        listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head", {
          mediaType: {
            previews: ["groot"]
          }
        }],
        listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
        listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
        listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
        listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
        listCommits: ["GET /repos/{owner}/{repo}/commits"],
        listContributors: ["GET /repos/{owner}/{repo}/contributors"],
        listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
        listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
        listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
        listForAuthenticatedUser: ["GET /user/repos"],
        listForOrg: ["GET /orgs/{org}/repos"],
        listForUser: ["GET /users/{username}/repos"],
        listForks: ["GET /repos/{owner}/{repo}/forks"],
        listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
        listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
        listLanguages: ["GET /repos/{owner}/{repo}/languages"],
        listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
        listPublic: ["GET /repositories"],
        listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls", {
          mediaType: {
            previews: ["groot"]
          }
        }],
        listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
        listReleases: ["GET /repos/{owner}/{repo}/releases"],
        listTags: ["GET /repos/{owner}/{repo}/tags"],
        listTeams: ["GET /repos/{owner}/{repo}/teams"],
        listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
        merge: ["POST /repos/{owner}/{repo}/merges"],
        pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
        removeAppAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
          mapToData: "apps"
        }],
        removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
        removeStatusCheckContexts: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
          mapToData: "contexts"
        }],
        removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        removeTeamAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
          mapToData: "teams"
        }],
        removeUserAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
          mapToData: "users"
        }],
        replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics", {
          mediaType: {
            previews: ["mercy"]
          }
        }],
        requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
        setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        setAppAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
          mapToData: "apps"
        }],
        setStatusCheckContexts: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
          mapToData: "contexts"
        }],
        setTeamAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
          mapToData: "teams"
        }],
        setUserAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
          mapToData: "users"
        }],
        testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
        transfer: ["POST /repos/{owner}/{repo}/transfer"],
        update: ["PATCH /repos/{owner}/{repo}"],
        updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
        updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
        updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
        updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
        updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
        updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        updateStatusCheckPotection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
        uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", {
          baseUrl: "https://uploads.github.com"
        }]
      },
      search: {
        code: ["GET /search/code"],
        commits: ["GET /search/commits", {
          mediaType: {
            previews: ["cloak"]
          }
        }],
        issuesAndPullRequests: ["GET /search/issues"],
        labels: ["GET /search/labels"],
        repos: ["GET /search/repositories"],
        topics: ["GET /search/topics", {
          mediaType: {
            previews: ["mercy"]
          }
        }],
        users: ["GET /search/users"]
      },
      teams: {
        addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        create: ["POST /orgs/{org}/teams"],
        createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
        createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
        deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
        getByName: ["GET /orgs/{org}/teams/{team_slug}"],
        getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        list: ["GET /orgs/{org}/teams"],
        listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
        listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
        listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
        listForAuthenticatedUser: ["GET /user/teams"],
        listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
        listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
        listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects", {
          mediaType: {
            previews: ["inertia"]
          }
        }],
        listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
        removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
        removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
      },
      users: {
        addEmailForAuthenticated: ["POST /user/emails"],
        block: ["PUT /user/blocks/{username}"],
        checkBlocked: ["GET /user/blocks/{username}"],
        checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
        checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
        createGpgKeyForAuthenticated: ["POST /user/gpg_keys"],
        createPublicSshKeyForAuthenticated: ["POST /user/keys"],
        deleteEmailForAuthenticated: ["DELETE /user/emails"],
        deleteGpgKeyForAuthenticated: ["DELETE /user/gpg_keys/{gpg_key_id}"],
        deletePublicSshKeyForAuthenticated: ["DELETE /user/keys/{key_id}"],
        follow: ["PUT /user/following/{username}"],
        getAuthenticated: ["GET /user"],
        getByUsername: ["GET /users/{username}"],
        getContextForUser: ["GET /users/{username}/hovercard"],
        getGpgKeyForAuthenticated: ["GET /user/gpg_keys/{gpg_key_id}"],
        getPublicSshKeyForAuthenticated: ["GET /user/keys/{key_id}"],
        list: ["GET /users"],
        listBlockedByAuthenticated: ["GET /user/blocks"],
        listEmailsForAuthenticated: ["GET /user/emails"],
        listFollowedByAuthenticated: ["GET /user/following"],
        listFollowersForAuthenticatedUser: ["GET /user/followers"],
        listFollowersForUser: ["GET /users/{username}/followers"],
        listFollowingForUser: ["GET /users/{username}/following"],
        listGpgKeysForAuthenticated: ["GET /user/gpg_keys"],
        listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
        listPublicEmailsForAuthenticated: ["GET /user/public_emails"],
        listPublicKeysForUser: ["GET /users/{username}/keys"],
        listPublicSshKeysForAuthenticated: ["GET /user/keys"],
        setPrimaryEmailVisibilityForAuthenticated: ["PATCH /user/email/visibility"],
        unblock: ["DELETE /user/blocks/{username}"],
        unfollow: ["DELETE /user/following/{username}"],
        updateAuthenticated: ["PATCH /user"]
      }
    };
    var VERSION = "4.2.0";
    function endpointsToMethods(octokit2, endpointsMap) {
      const newMethods = {};
      for (const [scope, endpoints] of Object.entries(endpointsMap)) {
        for (const [methodName, endpoint] of Object.entries(endpoints)) {
          const [route, defaults, decorations] = endpoint;
          const [method, url] = route.split(/ /);
          const endpointDefaults = Object.assign({
            method,
            url
          }, defaults);
          if (!newMethods[scope]) {
            newMethods[scope] = {};
          }
          const scopeMethods = newMethods[scope];
          if (decorations) {
            scopeMethods[methodName] = decorate(octokit2, scope, methodName, endpointDefaults, decorations);
            continue;
          }
          scopeMethods[methodName] = octokit2.request.defaults(endpointDefaults);
        }
      }
      return newMethods;
    }
    function decorate(octokit2, scope, methodName, defaults, decorations) {
      const requestWithDefaults = octokit2.request.defaults(defaults);
      function withDecorations(...args) {
        let options = requestWithDefaults.endpoint.merge(...args);
        if (decorations.mapToData) {
          options = Object.assign({}, options, {
            data: options[decorations.mapToData],
            [decorations.mapToData]: void 0
          });
          return requestWithDefaults(options);
        }
        if (decorations.renamed) {
          const [newScope, newMethodName] = decorations.renamed;
          octokit2.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
        }
        if (decorations.deprecated) {
          octokit2.log.warn(decorations.deprecated);
        }
        if (decorations.renamedParameters) {
          const options2 = requestWithDefaults.endpoint.merge(...args);
          for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
            if (name in options2) {
              octokit2.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
              if (!(alias in options2)) {
                options2[alias] = options2[name];
              }
              delete options2[name];
            }
          }
          return requestWithDefaults(options2);
        }
        return requestWithDefaults(...args);
      }
      return Object.assign(withDecorations, requestWithDefaults);
    }
    function restEndpointMethods(octokit2) {
      return endpointsToMethods(octokit2, Endpoints);
    }
    restEndpointMethods.VERSION = VERSION;
    exports.restEndpointMethods = restEndpointMethods;
  }
});

// node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
var require_dist_node11 = __commonJS({
  "node_modules/@octokit/plugin-paginate-rest/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VERSION = "2.4.0";
    function normalizePaginatedListResponse(response) {
      const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
      if (!responseNeedsNormalization)
        return response;
      const incompleteResults = response.data.incomplete_results;
      const repositorySelection = response.data.repository_selection;
      const totalCount = response.data.total_count;
      delete response.data.incomplete_results;
      delete response.data.repository_selection;
      delete response.data.total_count;
      const namespaceKey = Object.keys(response.data)[0];
      const data = response.data[namespaceKey];
      response.data = data;
      if (typeof incompleteResults !== "undefined") {
        response.data.incomplete_results = incompleteResults;
      }
      if (typeof repositorySelection !== "undefined") {
        response.data.repository_selection = repositorySelection;
      }
      response.data.total_count = totalCount;
      return response;
    }
    function iterator(octokit2, route, parameters) {
      const options = typeof route === "function" ? route.endpoint(parameters) : octokit2.request.endpoint(route, parameters);
      const requestMethod = typeof route === "function" ? route : octokit2.request;
      const method = options.method;
      const headers = options.headers;
      let url = options.url;
      return {
        [Symbol.asyncIterator]: () => ({
          next() {
            if (!url) {
              return Promise.resolve({
                done: true
              });
            }
            return requestMethod({
              method,
              url,
              headers
            }).then(normalizePaginatedListResponse).then((response) => {
              url = ((response.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
              return {
                value: response
              };
            });
          }
        })
      };
    }
    function paginate(octokit2, route, parameters, mapFn) {
      if (typeof parameters === "function") {
        mapFn = parameters;
        parameters = void 0;
      }
      return gather(octokit2, [], iterator(octokit2, route, parameters)[Symbol.asyncIterator](), mapFn);
    }
    function gather(octokit2, results, iterator2, mapFn) {
      return iterator2.next().then((result) => {
        if (result.done) {
          return results;
        }
        let earlyExit = false;
        function done() {
          earlyExit = true;
        }
        results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
        if (earlyExit) {
          return results;
        }
        return gather(octokit2, results, iterator2, mapFn);
      });
    }
    function paginateRest(octokit2) {
      return {
        paginate: Object.assign(paginate.bind(null, octokit2), {
          iterator: iterator.bind(null, octokit2)
        })
      };
    }
    paginateRest.VERSION = VERSION;
    exports.paginateRest = paginateRest;
  }
});

// node_modules/@actions/github/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/@actions/github/lib/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOctokitOptions = exports.GitHub = exports.context = void 0;
    var Context = __importStar(require_context());
    var Utils = __importStar(require_utils2());
    var core_1 = require_dist_node9();
    var plugin_rest_endpoint_methods_1 = require_dist_node10();
    var plugin_paginate_rest_1 = require_dist_node11();
    exports.context = new Context.Context();
    var baseUrl = Utils.getApiBaseUrl();
    var defaults = {
      baseUrl,
      request: {
        agent: Utils.getProxyAgent(baseUrl)
      }
    };
    exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(defaults);
    function getOctokitOptions(token2, options) {
      const opts = Object.assign({}, options || {});
      const auth = Utils.getAuthString(token2, opts);
      if (auth) {
        opts.auth = auth;
      }
      return opts;
    }
    exports.getOctokitOptions = getOctokitOptions;
  }
});

// node_modules/@actions/github/lib/github.js
var require_github = __commonJS({
  "node_modules/@actions/github/lib/github.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOctokit = exports.context = void 0;
    var Context = __importStar(require_context());
    var utils_1 = require_utils3();
    exports.context = new Context.Context();
    function getOctokit2(token2, options) {
      return new utils_1.GitHub(utils_1.getOctokitOptions(token2, options));
    }
    exports.getOctokit = getOctokit2;
  }
});

// node_modules/@actions/glob/lib/internal-glob-options-helper.js
var require_internal_glob_options_helper = __commonJS({
  "node_modules/@actions/glob/lib/internal-glob-options-helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core10 = require_core();
    function getOptions(copy) {
      const result = {
        followSymbolicLinks: true,
        implicitDescendants: true,
        omitBrokenSymbolicLinks: true
      };
      if (copy) {
        if (typeof copy.followSymbolicLinks === "boolean") {
          result.followSymbolicLinks = copy.followSymbolicLinks;
          core10.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
        }
        if (typeof copy.implicitDescendants === "boolean") {
          result.implicitDescendants = copy.implicitDescendants;
          core10.debug(`implicitDescendants '${result.implicitDescendants}'`);
        }
        if (typeof copy.omitBrokenSymbolicLinks === "boolean") {
          result.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
          core10.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
        }
      }
      return result;
    }
    exports.getOptions = getOptions;
  }
});

// node_modules/@actions/glob/lib/internal-path-helper.js
var require_internal_path_helper = __commonJS({
  "node_modules/@actions/glob/lib/internal-path-helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = require("assert");
    var path8 = require("path");
    var IS_WINDOWS = process.platform === "win32";
    function dirname(p) {
      p = safeTrimTrailingSeparator(p);
      if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
        return p;
      }
      let result = path8.dirname(p);
      if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) {
        result = safeTrimTrailingSeparator(result);
      }
      return result;
    }
    exports.dirname = dirname;
    function ensureAbsoluteRoot(root, itemPath) {
      assert(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
      assert(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
      if (hasAbsoluteRoot(itemPath)) {
        return itemPath;
      }
      if (IS_WINDOWS) {
        if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
          let cwd = process.cwd();
          assert(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
          if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
            if (itemPath.length === 2) {
              return `${itemPath[0]}:\\${cwd.substr(3)}`;
            } else {
              if (!cwd.endsWith("\\")) {
                cwd += "\\";
              }
              return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
            }
          } else {
            return `${itemPath[0]}:\\${itemPath.substr(2)}`;
          }
        } else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
          const cwd = process.cwd();
          assert(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
          return `${cwd[0]}:\\${itemPath.substr(1)}`;
        }
      }
      assert(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
      if (root.endsWith("/") || IS_WINDOWS && root.endsWith("\\")) {
      } else {
        root += path8.sep;
      }
      return root + itemPath;
    }
    exports.ensureAbsoluteRoot = ensureAbsoluteRoot;
    function hasAbsoluteRoot(itemPath) {
      assert(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
      itemPath = normalizeSeparators(itemPath);
      if (IS_WINDOWS) {
        return itemPath.startsWith("\\\\") || /^[A-Z]:\\/i.test(itemPath);
      }
      return itemPath.startsWith("/");
    }
    exports.hasAbsoluteRoot = hasAbsoluteRoot;
    function hasRoot(itemPath) {
      assert(itemPath, `isRooted parameter 'itemPath' must not be empty`);
      itemPath = normalizeSeparators(itemPath);
      if (IS_WINDOWS) {
        return itemPath.startsWith("\\") || /^[A-Z]:/i.test(itemPath);
      }
      return itemPath.startsWith("/");
    }
    exports.hasRoot = hasRoot;
    function normalizeSeparators(p) {
      p = p || "";
      if (IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        const isUnc = /^\\\\+[^\\]/.test(p);
        return (isUnc ? "\\" : "") + p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    exports.normalizeSeparators = normalizeSeparators;
    function safeTrimTrailingSeparator(p) {
      if (!p) {
        return "";
      }
      p = normalizeSeparators(p);
      if (!p.endsWith(path8.sep)) {
        return p;
      }
      if (p === path8.sep) {
        return p;
      }
      if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
        return p;
      }
      return p.substr(0, p.length - 1);
    }
    exports.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
  }
});

// node_modules/@actions/glob/lib/internal-match-kind.js
var require_internal_match_kind = __commonJS({
  "node_modules/@actions/glob/lib/internal-match-kind.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MatchKind;
    (function(MatchKind2) {
      MatchKind2[MatchKind2["None"] = 0] = "None";
      MatchKind2[MatchKind2["Directory"] = 1] = "Directory";
      MatchKind2[MatchKind2["File"] = 2] = "File";
      MatchKind2[MatchKind2["All"] = 3] = "All";
    })(MatchKind = exports.MatchKind || (exports.MatchKind = {}));
  }
});

// node_modules/@actions/glob/lib/internal-pattern-helper.js
var require_internal_pattern_helper = __commonJS({
  "node_modules/@actions/glob/lib/internal-pattern-helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pathHelper = require_internal_path_helper();
    var internal_match_kind_1 = require_internal_match_kind();
    var IS_WINDOWS = process.platform === "win32";
    function getSearchPaths(patterns) {
      patterns = patterns.filter((x2) => !x2.negate);
      const searchPathMap = {};
      for (const pattern of patterns) {
        const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
        searchPathMap[key] = "candidate";
      }
      const result = [];
      for (const pattern of patterns) {
        const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
        if (searchPathMap[key] === "included") {
          continue;
        }
        let foundAncestor = false;
        let tempKey = key;
        let parent = pathHelper.dirname(tempKey);
        while (parent !== tempKey) {
          if (searchPathMap[parent]) {
            foundAncestor = true;
            break;
          }
          tempKey = parent;
          parent = pathHelper.dirname(tempKey);
        }
        if (!foundAncestor) {
          result.push(pattern.searchPath);
          searchPathMap[key] = "included";
        }
      }
      return result;
    }
    exports.getSearchPaths = getSearchPaths;
    function match(patterns, itemPath) {
      let result = internal_match_kind_1.MatchKind.None;
      for (const pattern of patterns) {
        if (pattern.negate) {
          result &= ~pattern.match(itemPath);
        } else {
          result |= pattern.match(itemPath);
        }
      }
      return result;
    }
    exports.match = match;
    function partialMatch(patterns, itemPath) {
      return patterns.some((x2) => !x2.negate && x2.partialMatch(itemPath));
    }
    exports.partialMatch = partialMatch;
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i2 = 0; i2 < xs.length; i2++) {
        var x2 = fn(xs[i2], i2);
        if (isArray(x2))
          res.push.apply(res, x2);
        else
          res.push(x2);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r2 = range(a, b, str);
      return r2 && {
        start: r2[0],
        end: r2[1],
        pre: str.slice(0, r2[0]),
        body: str.slice(r2[0] + a.length, r2[1]),
        post: str.slice(r2[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m2 = str.match(reg);
      return m2 ? m2[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i2 = ai;
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result) {
          if (i2 == ai) {
            begs.push(i2);
            ai = str.indexOf(a, i2 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i2 + 1);
          }
          i2 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m2 = balanced("{", "}", str);
      if (!m2)
        return str.split(",");
      var pre = m2.pre;
      var body = m2.body;
      var post = m2.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i2, y) {
      return i2 <= y;
    }
    function gte(i2, y) {
      return i2 >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m2 = balanced("{", "}", str);
      if (!m2 || /\$$/.test(m2.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m2.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m2.post.match(/,.*\}/)) {
          str = m2.pre + "{" + m2.body + escClose + m2.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m2.body.split(/\.\./);
      } else {
        n = parseCommaParts(m2.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m2.post.length ? expand(m2.post, false) : [""];
            return post.map(function(p) {
              return m2.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m2.pre;
      var post = m2.post.length ? expand(m2.post, false) : [""];
      var N;
      if (isSequence) {
        var x2 = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x2;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i2 = x2; test(i2, y); i2 += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i2);
            if (c === "\\")
              c = "";
          } else {
            c = String(i2);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i2 < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path8 = { sep: "/" };
    try {
      path8 = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s2) {
      return s2.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i2, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t2 = {};
      Object.keys(b).forEach(function(k) {
        t2[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t2[k] = a[k];
      });
      return t2;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m2 = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m2.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m2;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path8.sep !== "/") {
        pattern = pattern.split(path8.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s2) {
        return s2.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s2, si, set2) {
        return s2.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s2) {
        return s2.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i2 = 0, l = pattern.length; i2 < l && pattern.charAt(i2) === "!"; i2++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i2 = 0, len = pattern.length, c; i2 < len && (c = pattern.charAt(i2)); i2++) {
        this.debug("%s	%s %s %j", pattern, i2, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i2, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i2 === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i2 - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i2;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i2 === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i2);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t2 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t2 + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i2 = 0; i2 < openParensBefore; i2++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f3) {
        return mm.match(f3);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f3, partial) {
      this.debug("match", f3, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f3 === "";
      if (f3 === "/" && partial)
        return true;
      var options = this.options;
      if (path8.sep !== "/") {
        f3 = f3.split(path8.sep).join("/");
      }
      f3 = f3.split(slashSplit);
      this.debug(this.pattern, "split", f3);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i2;
      for (i2 = f3.length - 1; i2 >= 0; i2--) {
        filename = f3[i2];
        if (filename)
          break;
      }
      for (i2 = 0; i2 < set.length; i2++) {
        var pattern = set[i2];
        var file = f3;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f3 = file[fi];
        this.debug(pattern, p, f3);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f3]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f3.toLowerCase() === p.toLowerCase();
          } else {
            hit = f3 === p;
          }
          this.debug("string match", p, f3, hit);
        } else {
          hit = f3.match(p);
          this.debug("pattern match", p, f3, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s2) {
      return s2.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s2) {
      return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/@actions/glob/lib/internal-path.js
var require_internal_path = __commonJS({
  "node_modules/@actions/glob/lib/internal-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = require("assert");
    var path8 = require("path");
    var pathHelper = require_internal_path_helper();
    var IS_WINDOWS = process.platform === "win32";
    var Path = class {
      constructor(itemPath) {
        this.segments = [];
        if (typeof itemPath === "string") {
          assert(itemPath, `Parameter 'itemPath' must not be empty`);
          itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
          if (!pathHelper.hasRoot(itemPath)) {
            this.segments = itemPath.split(path8.sep);
          } else {
            let remaining = itemPath;
            let dir = pathHelper.dirname(remaining);
            while (dir !== remaining) {
              const basename2 = path8.basename(remaining);
              this.segments.unshift(basename2);
              remaining = dir;
              dir = pathHelper.dirname(remaining);
            }
            this.segments.unshift(remaining);
          }
        } else {
          assert(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
          for (let i2 = 0; i2 < itemPath.length; i2++) {
            let segment = itemPath[i2];
            assert(segment, `Parameter 'itemPath' must not contain any empty segments`);
            segment = pathHelper.normalizeSeparators(itemPath[i2]);
            if (i2 === 0 && pathHelper.hasRoot(segment)) {
              segment = pathHelper.safeTrimTrailingSeparator(segment);
              assert(segment === pathHelper.dirname(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
              this.segments.push(segment);
            } else {
              assert(!segment.includes(path8.sep), `Parameter 'itemPath' contains unexpected path separators`);
              this.segments.push(segment);
            }
          }
        }
      }
      toString() {
        let result = this.segments[0];
        let skipSlash = result.endsWith(path8.sep) || IS_WINDOWS && /^[A-Z]:$/i.test(result);
        for (let i2 = 1; i2 < this.segments.length; i2++) {
          if (skipSlash) {
            skipSlash = false;
          } else {
            result += path8.sep;
          }
          result += this.segments[i2];
        }
        return result;
      }
    };
    exports.Path = Path;
  }
});

// node_modules/@actions/glob/lib/internal-pattern.js
var require_internal_pattern = __commonJS({
  "node_modules/@actions/glob/lib/internal-pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = require("assert");
    var os = require("os");
    var path8 = require("path");
    var pathHelper = require_internal_path_helper();
    var minimatch_1 = require_minimatch();
    var internal_match_kind_1 = require_internal_match_kind();
    var internal_path_1 = require_internal_path();
    var IS_WINDOWS = process.platform === "win32";
    var Pattern = class {
      constructor(patternOrNegate, segments) {
        this.negate = false;
        let pattern;
        if (typeof patternOrNegate === "string") {
          pattern = patternOrNegate.trim();
        } else {
          segments = segments || [];
          assert(segments.length, `Parameter 'segments' must not empty`);
          const root = Pattern.getLiteral(segments[0]);
          assert(root && pathHelper.hasAbsoluteRoot(root), `Parameter 'segments' first element must be a root path`);
          pattern = new internal_path_1.Path(segments).toString().trim();
          if (patternOrNegate) {
            pattern = `!${pattern}`;
          }
        }
        while (pattern.startsWith("!")) {
          this.negate = !this.negate;
          pattern = pattern.substr(1).trim();
        }
        pattern = Pattern.fixupPattern(pattern);
        this.segments = new internal_path_1.Path(pattern).segments;
        this.trailingSeparator = pathHelper.normalizeSeparators(pattern).endsWith(path8.sep);
        pattern = pathHelper.safeTrimTrailingSeparator(pattern);
        let foundGlob = false;
        const searchSegments = this.segments.map((x2) => Pattern.getLiteral(x2)).filter((x2) => !foundGlob && !(foundGlob = x2 === ""));
        this.searchPath = new internal_path_1.Path(searchSegments).toString();
        this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? "i" : "");
        const minimatchOptions = {
          dot: true,
          nobrace: true,
          nocase: IS_WINDOWS,
          nocomment: true,
          noext: true,
          nonegate: true
        };
        pattern = IS_WINDOWS ? pattern.replace(/\\/g, "/") : pattern;
        this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
      }
      match(itemPath) {
        if (this.segments[this.segments.length - 1] === "**") {
          itemPath = pathHelper.normalizeSeparators(itemPath);
          if (!itemPath.endsWith(path8.sep)) {
            itemPath = `${itemPath}${path8.sep}`;
          }
        } else {
          itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        }
        if (this.minimatch.match(itemPath)) {
          return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
        }
        return internal_match_kind_1.MatchKind.None;
      }
      partialMatch(itemPath) {
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        if (pathHelper.dirname(itemPath) === itemPath) {
          return this.rootRegExp.test(itemPath);
        }
        return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
      }
      static globEscape(s2) {
        return (IS_WINDOWS ? s2 : s2.replace(/\\/g, "\\\\")).replace(/(\[)(?=[^/]+\])/g, "[[]").replace(/\?/g, "[?]").replace(/\*/g, "[*]");
      }
      static fixupPattern(pattern) {
        assert(pattern, "pattern cannot be empty");
        const literalSegments = new internal_path_1.Path(pattern).segments.map((x2) => Pattern.getLiteral(x2));
        assert(literalSegments.every((x2, i2) => (x2 !== "." || i2 === 0) && x2 !== ".."), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
        assert(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
        pattern = pathHelper.normalizeSeparators(pattern);
        if (pattern === "." || pattern.startsWith(`.${path8.sep}`)) {
          pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
        } else if (pattern === "~" || pattern.startsWith(`~${path8.sep}`)) {
          const homedir = os.homedir();
          assert(homedir, "Unable to determine HOME directory");
          assert(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
          pattern = Pattern.globEscape(homedir) + pattern.substr(1);
        } else if (IS_WINDOWS && (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
          let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", pattern.substr(0, 2));
          if (pattern.length > 2 && !root.endsWith("\\")) {
            root += "\\";
          }
          pattern = Pattern.globEscape(root) + pattern.substr(2);
        } else if (IS_WINDOWS && (pattern === "\\" || pattern.match(/^\\[^\\]/))) {
          let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", "\\");
          if (!root.endsWith("\\")) {
            root += "\\";
          }
          pattern = Pattern.globEscape(root) + pattern.substr(1);
        } else {
          pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
        }
        return pathHelper.normalizeSeparators(pattern);
      }
      static getLiteral(segment) {
        let literal = "";
        for (let i2 = 0; i2 < segment.length; i2++) {
          const c = segment[i2];
          if (c === "\\" && !IS_WINDOWS && i2 + 1 < segment.length) {
            literal += segment[++i2];
            continue;
          } else if (c === "*" || c === "?") {
            return "";
          } else if (c === "[" && i2 + 1 < segment.length) {
            let set = "";
            let closed = -1;
            for (let i22 = i2 + 1; i22 < segment.length; i22++) {
              const c2 = segment[i22];
              if (c2 === "\\" && !IS_WINDOWS && i22 + 1 < segment.length) {
                set += segment[++i22];
                continue;
              } else if (c2 === "]") {
                closed = i22;
                break;
              } else {
                set += c2;
              }
            }
            if (closed >= 0) {
              if (set.length > 1) {
                return "";
              }
              if (set) {
                literal += set;
                i2 = closed;
                continue;
              }
            }
          }
          literal += c;
        }
        return literal;
      }
      static regExpEscape(s2) {
        return s2.replace(/[[\\^$.|?*+()]/g, "\\$&");
      }
    };
    exports.Pattern = Pattern;
  }
});

// node_modules/@actions/glob/lib/internal-search-state.js
var require_internal_search_state = __commonJS({
  "node_modules/@actions/glob/lib/internal-search-state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SearchState = class {
      constructor(path8, level) {
        this.path = path8;
        this.level = level;
      }
    };
    exports.SearchState = SearchState;
  }
});

// node_modules/@actions/glob/lib/internal-globber.js
var require_internal_globber = __commonJS({
  "node_modules/@actions/glob/lib/internal-globber.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m2 = o[Symbol.asyncIterator], i2;
      return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n) {
        i2[n] = o[n] && function(v) {
          return new Promise(function(resolve2, reject) {
            v = o[n](v), settle(resolve2, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve2, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve2({ value: v2, done: d });
        }, reject);
      }
    };
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function verb(n) {
        if (g[n])
          i2[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e2) {
          settle(q[0][3], e2);
        }
      }
      function step(r2) {
        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f3, v) {
        if (f3(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var core10 = require_core();
    var fs8 = require("fs");
    var globOptionsHelper = require_internal_glob_options_helper();
    var path8 = require("path");
    var patternHelper = require_internal_pattern_helper();
    var internal_match_kind_1 = require_internal_match_kind();
    var internal_pattern_1 = require_internal_pattern();
    var internal_search_state_1 = require_internal_search_state();
    var IS_WINDOWS = process.platform === "win32";
    var DefaultGlobber = class {
      constructor(options) {
        this.patterns = [];
        this.searchPaths = [];
        this.options = globOptionsHelper.getOptions(options);
      }
      getSearchPaths() {
        return this.searchPaths.slice();
      }
      glob() {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
          const result = [];
          try {
            for (var _b = __asyncValues(this.globGenerator()), _c; _c = yield _b.next(), !_c.done; ) {
              const itemPath = _c.value;
              result.push(itemPath);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                yield _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return result;
        });
      }
      globGenerator() {
        return __asyncGenerator(this, arguments, function* globGenerator_1() {
          const options = globOptionsHelper.getOptions(this.options);
          const patterns = [];
          for (const pattern of this.patterns) {
            patterns.push(pattern);
            if (options.implicitDescendants && (pattern.trailingSeparator || pattern.segments[pattern.segments.length - 1] !== "**")) {
              patterns.push(new internal_pattern_1.Pattern(pattern.negate, pattern.segments.concat("**")));
            }
          }
          const stack = [];
          for (const searchPath of patternHelper.getSearchPaths(patterns)) {
            core10.debug(`Search path '${searchPath}'`);
            try {
              yield __await(fs8.promises.lstat(searchPath));
            } catch (err) {
              if (err.code === "ENOENT") {
                continue;
              }
              throw err;
            }
            stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
          }
          const traversalChain = [];
          while (stack.length) {
            const item = stack.pop();
            const match = patternHelper.match(patterns, item.path);
            const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
            if (!match && !partialMatch) {
              continue;
            }
            const stats = yield __await(DefaultGlobber.stat(item, options, traversalChain));
            if (!stats) {
              continue;
            }
            if (stats.isDirectory()) {
              if (match & internal_match_kind_1.MatchKind.Directory) {
                yield yield __await(item.path);
              } else if (!partialMatch) {
                continue;
              }
              const childLevel = item.level + 1;
              const childItems = (yield __await(fs8.promises.readdir(item.path))).map((x2) => new internal_search_state_1.SearchState(path8.join(item.path, x2), childLevel));
              stack.push(...childItems.reverse());
            } else if (match & internal_match_kind_1.MatchKind.File) {
              yield yield __await(item.path);
            }
          }
        });
      }
      static create(patterns, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const result = new DefaultGlobber(options);
          if (IS_WINDOWS) {
            patterns = patterns.replace(/\r\n/g, "\n");
            patterns = patterns.replace(/\r/g, "\n");
          }
          const lines = patterns.split("\n").map((x2) => x2.trim());
          for (const line of lines) {
            if (!line || line.startsWith("#")) {
              continue;
            } else {
              result.patterns.push(new internal_pattern_1.Pattern(line));
            }
          }
          result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
          return result;
        });
      }
      static stat(item, options, traversalChain) {
        return __awaiter(this, void 0, void 0, function* () {
          let stats;
          if (options.followSymbolicLinks) {
            try {
              stats = yield fs8.promises.stat(item.path);
            } catch (err) {
              if (err.code === "ENOENT") {
                if (options.omitBrokenSymbolicLinks) {
                  core10.debug(`Broken symlink '${item.path}'`);
                  return void 0;
                }
                throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
              }
              throw err;
            }
          } else {
            stats = yield fs8.promises.lstat(item.path);
          }
          if (stats.isDirectory() && options.followSymbolicLinks) {
            const realPath = yield fs8.promises.realpath(item.path);
            while (traversalChain.length >= item.level) {
              traversalChain.pop();
            }
            if (traversalChain.some((x2) => x2 === realPath)) {
              core10.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
              return void 0;
            }
            traversalChain.push(realPath);
          }
          return stats;
        });
      }
    };
    exports.DefaultGlobber = DefaultGlobber;
  }
});

// node_modules/@actions/glob/lib/glob.js
var require_glob = __commonJS({
  "node_modules/@actions/glob/lib/glob.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var internal_globber_1 = require_internal_globber();
    function create8(patterns, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield internal_globber_1.DefaultGlobber.create(patterns, options);
      });
    }
    exports.create = create8;
  }
});

// node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS({
  "node_modules/@actions/io/lib/io-util.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert_1 = require("assert");
    var fs8 = require("fs");
    var path8 = require("path");
    _a = fs8.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
    exports.IS_WINDOWS = process.platform === "win32";
    function exists(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield exports.stat(fsPath);
        } catch (err) {
          if (err.code === "ENOENT") {
            return false;
          }
          throw err;
        }
        return true;
      });
    }
    exports.exists = exists;
    function isDirectory(fsPath, useStat = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
        return stats.isDirectory();
      });
    }
    exports.isDirectory = isDirectory;
    function isRooted(p) {
      p = normalizeSeparators(p);
      if (!p) {
        throw new Error('isRooted() parameter "p" cannot be empty');
      }
      if (exports.IS_WINDOWS) {
        return p.startsWith("\\") || /^[A-Z]:/i.test(p);
      }
      return p.startsWith("/");
    }
    exports.isRooted = isRooted;
    function mkdirP5(fsPath, maxDepth = 1e3, depth = 1) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(fsPath, "a path argument must be provided");
        fsPath = path8.resolve(fsPath);
        if (depth >= maxDepth)
          return exports.mkdir(fsPath);
        try {
          yield exports.mkdir(fsPath);
          return;
        } catch (err) {
          switch (err.code) {
            case "ENOENT": {
              yield mkdirP5(path8.dirname(fsPath), maxDepth, depth + 1);
              yield exports.mkdir(fsPath);
              return;
            }
            default: {
              let stats;
              try {
                stats = yield exports.stat(fsPath);
              } catch (err2) {
                throw err;
              }
              if (!stats.isDirectory())
                throw err;
            }
          }
        }
      });
    }
    exports.mkdirP = mkdirP5;
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter(this, void 0, void 0, function* () {
        let stats = void 0;
        try {
          stats = yield exports.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports.IS_WINDOWS) {
            const upperExt = path8.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
              return filePath;
            }
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
        const originalFilePath = filePath;
        for (const extension of extensions) {
          filePath = originalFilePath + extension;
          stats = void 0;
          try {
            stats = yield exports.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports.IS_WINDOWS) {
              try {
                const directory = path8.dirname(filePath);
                const upperName = path8.basename(filePath).toUpperCase();
                for (const actualName of yield exports.readdir(directory)) {
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path8.join(directory, actualName);
                    break;
                  }
                }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
        }
        return "";
      });
    }
    exports.tryGetExecutablePath = tryGetExecutablePath;
    function normalizeSeparators(p) {
      p = p || "";
      if (exports.IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        return p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats) {
      return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
    }
  }
});

// node_modules/@actions/io/lib/io.js
var require_io = __commonJS({
  "node_modules/@actions/io/lib/io.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var childProcess = require("child_process");
    var path8 = require("path");
    var util_1 = require("util");
    var ioUtil = require_io_util();
    var exec4 = util_1.promisify(childProcess.exec);
    function cp2(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const { force, recursive } = readCopyOptions(options);
        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
        if (destStat && destStat.isFile() && !force) {
          return;
        }
        const newDest = destStat && destStat.isDirectory() ? path8.join(dest, path8.basename(source)) : dest;
        if (!(yield ioUtil.exists(source))) {
          throw new Error(`no such file or directory: ${source}`);
        }
        const sourceStat = yield ioUtil.stat(source);
        if (sourceStat.isDirectory()) {
          if (!recursive) {
            throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
          } else {
            yield cpDirRecursive(source, newDest, 0, force);
          }
        } else {
          if (path8.relative(source, newDest) === "") {
            throw new Error(`'${newDest}' and '${source}' are the same file`);
          }
          yield copyFile(source, newDest, force);
        }
      });
    }
    exports.cp = cp2;
    function mv(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (yield ioUtil.exists(dest)) {
          let destExists = true;
          if (yield ioUtil.isDirectory(dest)) {
            dest = path8.join(dest, path8.basename(source));
            destExists = yield ioUtil.exists(dest);
          }
          if (destExists) {
            if (options.force == null || options.force) {
              yield rmRF(dest);
            } else {
              throw new Error("Destination already exists");
            }
          }
        }
        yield mkdirP5(path8.dirname(dest));
        yield ioUtil.rename(source, dest);
      });
    }
    exports.mv = mv;
    function rmRF(inputPath) {
      return __awaiter(this, void 0, void 0, function* () {
        if (ioUtil.IS_WINDOWS) {
          try {
            if (yield ioUtil.isDirectory(inputPath, true)) {
              yield exec4(`rd /s /q "${inputPath}"`);
            } else {
              yield exec4(`del /f /a "${inputPath}"`);
            }
          } catch (err) {
            if (err.code !== "ENOENT")
              throw err;
          }
          try {
            yield ioUtil.unlink(inputPath);
          } catch (err) {
            if (err.code !== "ENOENT")
              throw err;
          }
        } else {
          let isDir = false;
          try {
            isDir = yield ioUtil.isDirectory(inputPath);
          } catch (err) {
            if (err.code !== "ENOENT")
              throw err;
            return;
          }
          if (isDir) {
            yield exec4(`rm -rf "${inputPath}"`);
          } else {
            yield ioUtil.unlink(inputPath);
          }
        }
      });
    }
    exports.rmRF = rmRF;
    function mkdirP5(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        yield ioUtil.mkdirP(fsPath);
      });
    }
    exports.mkdirP = mkdirP5;
    function which(tool, check) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        if (check) {
          const result = yield which(tool, false);
          if (!result) {
            if (ioUtil.IS_WINDOWS) {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
            } else {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
            }
          }
        }
        try {
          const extensions = [];
          if (ioUtil.IS_WINDOWS && process.env.PATHEXT) {
            for (const extension of process.env.PATHEXT.split(path8.delimiter)) {
              if (extension) {
                extensions.push(extension);
              }
            }
          }
          if (ioUtil.isRooted(tool)) {
            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
            if (filePath) {
              return filePath;
            }
            return "";
          }
          if (tool.includes("/") || ioUtil.IS_WINDOWS && tool.includes("\\")) {
            return "";
          }
          const directories = [];
          if (process.env.PATH) {
            for (const p of process.env.PATH.split(path8.delimiter)) {
              if (p) {
                directories.push(p);
              }
            }
          }
          for (const directory of directories) {
            const filePath = yield ioUtil.tryGetExecutablePath(directory + path8.sep + tool, extensions);
            if (filePath) {
              return filePath;
            }
          }
          return "";
        } catch (err) {
          throw new Error(`which failed with message ${err.message}`);
        }
      });
    }
    exports.which = which;
    function readCopyOptions(options) {
      const force = options.force == null ? true : options.force;
      const recursive = Boolean(options.recursive);
      return { force, recursive };
    }
    function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if (currentDepth >= 255)
          return;
        currentDepth++;
        yield mkdirP5(destDir);
        const files = yield ioUtil.readdir(sourceDir);
        for (const fileName of files) {
          const srcFile = `${sourceDir}/${fileName}`;
          const destFile = `${destDir}/${fileName}`;
          const srcFileStat = yield ioUtil.lstat(srcFile);
          if (srcFileStat.isDirectory()) {
            yield cpDirRecursive(srcFile, destFile, currentDepth, force);
          } else {
            yield copyFile(srcFile, destFile, force);
          }
        }
        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
      });
    }
    function copyFile(srcFile, destFile, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
          try {
            yield ioUtil.lstat(destFile);
            yield ioUtil.unlink(destFile);
          } catch (e2) {
            if (e2.code === "EPERM") {
              yield ioUtil.chmod(destFile, "0666");
              yield ioUtil.unlink(destFile);
            }
          }
          const symlinkFull = yield ioUtil.readlink(srcFile);
          yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
        } else if (!(yield ioUtil.exists(destFile)) || force) {
          yield ioUtil.copyFile(srcFile, destFile);
        }
      });
    }
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports, function(exports2) {
      "use strict";
      const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
      function noop2() {
        return void 0;
      }
      function getGlobals() {
        if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      const globals = getGlobals();
      function typeIsObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      const rethrowAssertionErrorRejection = noop2;
      const originalPromise = Promise;
      const originalPromiseThen = Promise.prototype.then;
      const originalPromiseResolve = Promise.resolve.bind(originalPromise);
      const originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      const queueMicrotask = (() => {
        const globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask === "function") {
          return globalQueueMicrotask;
        }
        const resolvedPromise = promiseResolvedWith(void 0);
        return (fn) => PerformPromiseThen(resolvedPromise, fn);
      })();
      function reflectCall(F2, V, args) {
        if (typeof F2 !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F2, V, args);
      }
      function promiseCall(F2, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F2, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      const QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        get length() {
          return this._size;
        }
        push(element) {
          const oldBack = this._back;
          let newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        }
        shift() {
          const oldFront = this._front;
          let newFront = oldFront;
          const oldCursor = this._cursor;
          let newCursor = oldCursor + 1;
          const elements = oldFront._elements;
          const element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        }
        forEach(callback) {
          let i2 = this._cursor;
          let node = this._front;
          let elements = node._elements;
          while (i2 !== elements.length || node._next !== void 0) {
            if (i2 === elements.length) {
              node = node._next;
              elements = node._elements;
              i2 = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i2]);
            ++i2;
          }
        }
        peek() {
          const front = this._front;
          const cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        if (reader._ownerReadableStream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        reader._ownerReadableStream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve2, reject) => {
          reader._closedPromise_resolve = resolve2;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
      const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
      const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
      const PullSteps = SymbolPolyfill("[[PullSteps]]");
      const NumberIsFinite = Number.isFinite || function(x2) {
        return typeof x2 === "number" && isFinite(x2);
      };
      const MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x2) {
        return typeof x2 === "object" || typeof x2 === "function";
      }
      function assertDictionary(obj, context2) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(`${context2} is not an object.`);
        }
      }
      function assertFunction(x2, context2) {
        if (typeof x2 !== "function") {
          throw new TypeError(`${context2} is not a function.`);
        }
      }
      function isObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      function assertObject(x2, context2) {
        if (!isObject(x2)) {
          throw new TypeError(`${context2} is not an object.`);
        }
      }
      function assertRequiredArgument(x2, position, context2) {
        if (x2 === void 0) {
          throw new TypeError(`Parameter ${position} is required in '${context2}'.`);
        }
      }
      function assertRequiredField(x2, field, context2) {
        if (x2 === void 0) {
          throw new TypeError(`${field} is required in '${context2}'.`);
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function integerPart(x2) {
        return censorNegativeZero(MathTrunc(x2));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context2) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x2 = Number(value);
        x2 = censorNegativeZero(x2);
        if (!NumberIsFinite(x2)) {
          throw new TypeError(`${context2} is not a finite number`);
        }
        x2 = integerPart(x2);
        if (x2 < lowerBound || x2 > upperBound) {
          throw new TypeError(`${context2} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x2) || x2 === 0) {
          return 0;
        }
        return x2;
      }
      function assertReadableStream(x2, context2) {
        if (!IsReadableStream(x2)) {
          throw new TypeError(`${context2} is not a ReadableStream.`);
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        get closed() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        cancel(reason = void 0) {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve2, reject) => {
            resolvePromise = resolve2;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: () => resolvePromise({ value: void 0, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        }
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
      }
      const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
      }).prototype);
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        next() {
          const nextSteps = () => this._nextSteps();
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        }
        return(value) {
          const returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          const reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("iterate"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve2, reject) => {
            resolvePromise = resolve2;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0;
              queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        }
        _returnSteps(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          const reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("finish iterating"));
          }
          if (!this._preventCancel) {
            const result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, () => ({ value, done: true }));
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        }
      }
      const ReadableStreamAsyncIteratorPrototype = {
        next() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      if (AsyncIteratorPrototype !== void 0) {
        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      }
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
      }
      const NumberIsNaN = Number.isNaN || function(x2) {
        return x2 !== x2;
      };
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O) {
        return O;
      }
      function IsDetachedBuffer(O) {
        return false;
      }
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice) {
          return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
      }
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get view() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer))
            ;
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get byobRequest() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        get desiredSize() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        close() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
          }
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError(`chunk's buffer must have non-zero byteLength`);
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        error(e2 = void 0) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e2);
        }
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        }
        [PullSteps](readRequest) {
          const stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            const entry = this._queue.shift();
            this._queueTotalSize -= entry.byteLength;
            ReadableByteStreamControllerHandleQueueDrain(this);
            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
            readRequest._chunkSteps(view);
            return;
          }
          const autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            const pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
          return false;
        }
        return x2 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }, (e2) => {
          ReadableByteStreamControllerError(controller, e2);
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === "closed") {
          done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const elementSize = pullIntoDescriptor.elementSize;
        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        if (maxAlignedBytes > currentAlignedBytes) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          const headOfQueue = queue.peek();
          const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        let elementSize = 1;
        if (view.constructor !== DataView) {
          elementSize = view.constructor.BYTES_PER_ELEMENT;
        }
        const ctor = view.constructor;
        const buffer = TransferArrayBuffer(view.buffer);
        const pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled > 0) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            throw e2;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        const buffer = chunk.buffer;
        const byteOffset = chunk.byteOffset;
        const byteLength = chunk.byteLength;
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer))
            ;
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
        }
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        if (ReadableStreamHasDefaultReader(stream)) {
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e2) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, (r2) => {
          ReadableByteStreamControllerError(controller, r2);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm = () => void 0;
        let pullAlgorithm = () => promiseResolvedWith(void 0);
        let cancelAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = () => underlyingByteSource.start(controller);
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = () => underlyingByteSource.pull(controller);
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        get closed() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        cancel(reason = void 0) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve2, reject) => {
            resolvePromise = resolve2;
            rejectPromise = reject;
          });
          const readIntoRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
          return promise;
        }
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readIntoRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
        }
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
          return () => 1;
        }
        return size;
      }
      function convertQueuingStrategy(init, context2) {
        assertDictionary(init, context2);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        const size = init === null || init === void 0 ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context2} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context2) {
        assertFunction(fn, context2);
        return (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context2) {
        assertDictionary(original, context2);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context2} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context2} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context2} has member 'start' that`),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context2} has member 'write' that`),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x2, context2) {
        if (!IsWritableStream(x2)) {
          throw new TypeError(`${context2} is not a WritableStream.`);
        }
      }
      function isAbortSignal2(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a) {
          return false;
        }
      }
      const supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          const type = underlyingSink.type;
          if (type !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        get locked() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        }
        abort(reason = void 0) {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        }
        close() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        }
        getWriter() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
          return false;
        }
        return x2 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        const promise = newPromise((resolve2, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve2,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve2, reject) => {
          const closeRequest = {
            _resolve: resolve2,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve2, reject) => {
          const writeRequest = {
            _resolve: resolve2,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error2) {
        const state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error2);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, (reason) => {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error2) {
        stream._inFlightWriteRequest._reject(error2);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error2);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        const state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error2) {
        stream._inFlightCloseRequest._reject(error2);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error2);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error2);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          const state = stream._state;
          if (state === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            const storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        get closed() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        get ready() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        }
        abort(reason = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        }
        close() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        }
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error2);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error2);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error2);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error2);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        const state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      const closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get abortReason() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        }
        get signal() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        }
        error(e2 = void 0) {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          const state = this._controlledWritableStream._state;
          if (state !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e2);
        }
        [AbortSteps](reason) {
          const result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (r2) => {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r2);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm = () => void 0;
        let writeAlgorithm = () => promiseResolvedWith(void 0);
        let closeAlgorithm = () => promiseResolvedWith(void 0);
        let abortAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingSink.start !== void 0) {
          startAlgorithm = () => underlyingSink.start(controller);
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = () => underlyingSink.close();
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = (reason) => underlyingSink.abort(reason);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        const state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error2);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          const state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (reason) => {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error2) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error2);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve2, reject) => {
          writer._closedPromise_resolve = resolve2;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve2, reject) => {
          writer._readyPromise_resolve = resolve2;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a) {
          return false;
        }
      }
      function createDOMExceptionPolyfill() {
        const ctor = function DOMException3(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        let currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve2, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = () => {
              const error2 = new DOMException$1("Aborted", "AbortError");
              const actions = [];
              if (!preventAbort) {
                actions.push(() => {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error2);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(() => {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error2);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, () => {
              return newPromise((resolveRead, rejectRead) => {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: (chunk) => {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);
                    resolveRead(false);
                  },
                  _closeSteps: () => resolveRead(true),
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            if (!preventAbort) {
              shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesClosed(source, reader._closedPromise, () => {
            if (!preventClose) {
              shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
            } else {
              shutdown();
            }
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
            } else {
              shutdown(true, destClosed);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            const oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
            }
          }
          function shutdown(isError, error2) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
            } else {
              finalize(isError, error2);
            }
          }
          function finalize(isError, error2) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error2);
            } else {
              resolve2(void 0);
            }
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        close() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        error(e2 = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e2);
        }
        [CancelSteps](reason) {
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        [PullSteps](readRequest) {
          const stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
        }, (e2) => {
          ReadableStreamDefaultControllerError(controller, e2);
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, (r2) => {
          ReadableStreamDefaultControllerError(controller, r2);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm = () => void 0;
        let pullAlgorithm = () => promiseResolvedWith(void 0);
        let cancelAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingSource.start !== void 0) {
          startAlgorithm = () => underlyingSource.start(controller);
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = () => underlyingSource.pull(controller);
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve2) => {
          resolveCancelPromise = resolve2;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const readRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgain = false;
                const chunk1 = chunk;
                const chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r2) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve2) => {
          resolveCancelPromise = resolve2;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r2) => {
            if (thisReader !== reader) {
              return;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r2);
            ReadableByteStreamControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          const readRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const chunk1 = chunk;
                let chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          const byobBranch = forBranch2 ? branch2 : branch1;
          const otherBranch = forBranch2 ? branch1 : branch2;
          const readIntoRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: (chunk) => {
              reading = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context2) {
        assertDictionary(source, context2);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context2} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context2} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context2} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context2} has member 'start' that`),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context2} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context2) {
        type = `${type}`;
        if (type !== "bytes") {
          throw new TypeError(`${context2} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
      }
      function convertReaderOptions(options, context2) {
        assertDictionary(options, context2);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context2} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context2) {
        mode = `${mode}`;
        if (mode !== "byob") {
          throw new TypeError(`${context2} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
      }
      function convertIteratorOptions(options, context2) {
        assertDictionary(options, context2);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context2) {
        assertDictionary(options, context2);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, `${context2} has member 'signal' that`);
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context2) {
        if (!isAbortSignal2(signal)) {
          throw new TypeError(`${context2} is not an AbortSignal.`);
        }
      }
      function convertReadableWritablePair(pair, context2) {
        assertDictionary(pair, context2);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, `${context2} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, `${context2} has member 'writable' that`);
        return { readable, writable };
      }
      class ReadableStream2 {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            const highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        get locked() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        }
        cancel(reason = void 0) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          const options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          const transform = convertReadableWritablePair(rawTransform, "First parameter");
          const options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
          }
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        tee() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          const branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          const options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
      }
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
          value: ReadableStream2.prototype.values,
          writable: true,
          configurable: true
        });
      }
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          reader._readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._closeSteps(void 0);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop2);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach((readRequest) => {
            readRequest._closeSteps();
          });
          reader._readRequests = new SimpleQueue();
        }
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored";
        stream._storedError = e2;
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e2);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach((readRequest) => {
            readRequest._errorSteps(e2);
          });
          reader._readRequests = new SimpleQueue();
        } else {
          reader._readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._errorSteps(e2);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init, context2) {
        assertDictionary(init, context2);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
      };
      try {
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
      } catch (_a) {
      }
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof ByteLengthQueuingStrategy;
      }
      const countSizeFunction = () => {
        return 1;
      };
      try {
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
      } catch (_a) {
      }
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context2) {
        assertDictionary(original, context2);
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context2} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context2} has member 'start' that`),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context2} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          const transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          let startPromise_resolve;
          const startPromise = newPromise((resolve2) => {
            startPromise_resolve = resolve2;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        get readable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        }
        get writable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          TransformStreamErrorWritableAndUnblockWrite(stream, reason);
          return promiseResolvedWith(void 0);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
          return false;
        }
        return x2 instanceof TransformStream;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
        TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise((resolve2) => {
          stream._backpressureChangePromise_resolve = resolve2;
        });
        stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          const readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        }
        terminate() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
          return false;
        }
        return x2 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm = (chunk) => {
          try {
            TransformStreamDefaultControllerEnqueue(controller, chunk);
            return promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        };
        let flushAlgorithm = () => promiseResolvedWith(void 0);
        if (transformer.transform !== void 0) {
          transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = () => transformer.flush(controller);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
          throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r2) => {
          TransformStreamError(controller._controlledTransformStream, r2);
          throw r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error2 = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error2);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
          const backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            const writable = stream._writable;
            const state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        TransformStreamError(stream, reason);
        return promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const readable = stream._readable;
        const controller = stream._transformStreamController;
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        return transformPromiseWith(flushPromise, () => {
          if (readable._state === "errored") {
            throw readable._storedError;
          }
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, (r2) => {
          TransformStreamError(stream, r2);
          throw readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
      }
      function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
      }
      exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports2.CountQueuingStrategy = CountQueuingStrategy;
      exports2.ReadableByteStreamController = ReadableByteStreamController;
      exports2.ReadableStream = ReadableStream2;
      exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports2.TransformStream = TransformStream;
      exports2.TransformStreamDefaultController = TransformStreamDefaultController;
      exports2.WritableStream = WritableStream;
      exports2.WritableStreamDefaultController = WritableStreamDefaultController;
      exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS({
  "node_modules/fetch-blob/streams.cjs"() {
    var POOL_SIZE2 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error2) {
          process2.emitWarning = emitWarning;
          throw error2;
        }
      } catch (error2) {
        Object.assign(globalThis, require_ponyfill_es2018());
      }
    }
    try {
      const { Blob: Blob4 } = require("buffer");
      if (Blob4 && !Blob4.prototype.stream) {
        Blob4.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE2));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
  }
});

// node_modules/fetch-blob/index.js
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0, b = part;
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
var import_streams, POOL_SIZE, _Blob, Blob3, fetch_blob_default;
var init_fetch_blob = __esm({
  "node_modules/fetch-blob/index.js"() {
    import_streams = __toESM(require_streams(), 1);
    POOL_SIZE = 65536;
    _Blob = class Blob2 {
      #parts = [];
      #type = "";
      #size = 0;
      #endings = "transparent";
      constructor(blobParts = [], options = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null)
          options = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob2) {
            part = element;
          } else {
            part = encoder.encode(`${element}`);
          }
          const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (size) {
            this.#size += size;
            this.#parts.push(part);
          }
        }
        this.#endings = `${options.endings === void 0 ? "transparent" : options.endings}`;
        const type = options.type === void 0 ? "" : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      get size() {
        return this.#size;
      }
      get type() {
        return this.#type;
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob2([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob3 = _Blob;
    fetch_blob_default = Blob3;
  }
});

// node_modules/fetch-blob/file.js
var _File, File2, file_default;
var init_file = __esm({
  "node_modules/fetch-blob/file.js"() {
    init_fetch_blob();
    _File = class File extends fetch_blob_default {
      #lastModified = 0;
      #name = "";
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        if (options === null)
          options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    };
    File2 = _File;
    file_default = File2;
  }
});

// node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F2, B = fetch_blob_default) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t, i, h, r, m, f, e, x, FormData;
var init_esm_min = __esm({
  "node_modules/formdata-polyfill/esm.min.js"() {
    init_fetch_blob();
    init_file();
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData = class FormData2 {
      #d = [];
      constructor(...a) {
        if (a.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        this.#d.push(f(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        this.#d = this.#d.filter(([b]) => b !== a);
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = this.#d, l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a)
            return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        this.#d.forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return this.#d.some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this)
          a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f(...a);
        this.#d.forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        this.#d = b;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a] of this)
          yield a;
      }
      *values() {
        for (var [, a] of this)
          yield a;
      }
    };
  }
});

// node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "node_modules/node-domexception/index.js"(exports, module2) {
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    module2.exports = globalThis.DOMException;
  }
});

// node_modules/fetch-blob/from.js
var import_node_fs, import_node_domexception, stat, BlobDataItem;
var init_from = __esm({
  "node_modules/fetch-blob/from.js"() {
    import_node_fs = require("node:fs");
    import_node_domexception = __toESM(require_node_domexception(), 1);
    init_file();
    init_fetch_blob();
    ({ stat } = import_node_fs.promises);
    BlobDataItem = class {
      #path;
      #start;
      constructor(options) {
        this.#path = options.path;
        this.#start = options.start;
        this.size = options.size;
        this.lastModified = options.lastModified;
        this.originalSize = options.originalSize === void 0 ? options.size : options.originalSize;
      }
      slice(start, end) {
        return new BlobDataItem({
          path: this.#path,
          lastModified: this.lastModified,
          originalSize: this.originalSize,
          size: end - start,
          start: this.#start + start
        });
      }
      async *stream() {
        const { mtimeMs, size } = await stat(this.#path);
        if (mtimeMs > this.lastModified || this.originalSize !== size) {
          throw new import_node_domexception.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
        }
        yield* (0, import_node_fs.createReadStream)(this.#path, {
          start: this.#start,
          end: this.#start + this.size - 1
        });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    };
  }
});

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/utils/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new file_default(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var s, S, f2, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/@chunkd/source-http/node_modules/node-fetch/src/utils/multipart-parser.js"() {
    init_from();
    init_esm_min();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f2 = 1;
    F = {
      PART_BOUNDARY: f2,
      LAST_BOUNDARY: f2 *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop = () => {
    };
    MultipartParser = class {
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/aws-sdk/lib/json/builder.js
var require_builder = __commonJS({
  "node_modules/aws-sdk/lib/json/builder.js"(exports, module2) {
    var util = require_util();
    function JsonBuilder() {
    }
    JsonBuilder.prototype.build = function(value, shape) {
      return JSON.stringify(translate(value, shape));
    };
    function translate(value, shape) {
      if (!shape || value === void 0 || value === null)
        return void 0;
      switch (shape.type) {
        case "structure":
          return translateStructure(value, shape);
        case "map":
          return translateMap(value, shape);
        case "list":
          return translateList(value, shape);
        default:
          return translateScalar(value, shape);
      }
    }
    function translateStructure(structure, shape) {
      if (shape.isDocument) {
        return structure;
      }
      var struct = {};
      util.each(structure, function(name, value) {
        var memberShape = shape.members[name];
        if (memberShape) {
          if (memberShape.location !== "body")
            return;
          var locationName = memberShape.isLocationName ? memberShape.name : name;
          var result = translate(value, memberShape);
          if (result !== void 0)
            struct[locationName] = result;
        }
      });
      return struct;
    }
    function translateList(list, shape) {
      var out = [];
      util.arrayEach(list, function(value) {
        var result = translate(value, shape.member);
        if (result !== void 0)
          out.push(result);
      });
      return out;
    }
    function translateMap(map, shape) {
      var out = {};
      util.each(map, function(key, value) {
        var result = translate(value, shape.value);
        if (result !== void 0)
          out[key] = result;
      });
      return out;
    }
    function translateScalar(value, shape) {
      return shape.toWireFormat(value);
    }
    module2.exports = JsonBuilder;
  }
});

// node_modules/aws-sdk/lib/json/parser.js
var require_parser = __commonJS({
  "node_modules/aws-sdk/lib/json/parser.js"(exports, module2) {
    var util = require_util();
    function JsonParser() {
    }
    JsonParser.prototype.parse = function(value, shape) {
      return translate(JSON.parse(value), shape);
    };
    function translate(value, shape) {
      if (!shape || value === void 0)
        return void 0;
      switch (shape.type) {
        case "structure":
          return translateStructure(value, shape);
        case "map":
          return translateMap(value, shape);
        case "list":
          return translateList(value, shape);
        default:
          return translateScalar(value, shape);
      }
    }
    function translateStructure(structure, shape) {
      if (structure == null)
        return void 0;
      if (shape.isDocument)
        return structure;
      var struct = {};
      var shapeMembers = shape.members;
      util.each(shapeMembers, function(name, memberShape) {
        var locationName = memberShape.isLocationName ? memberShape.name : name;
        if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
          var value = structure[locationName];
          var result = translate(value, memberShape);
          if (result !== void 0)
            struct[name] = result;
        }
      });
      return struct;
    }
    function translateList(list, shape) {
      if (list == null)
        return void 0;
      var out = [];
      util.arrayEach(list, function(value) {
        var result = translate(value, shape.member);
        if (result === void 0)
          out.push(null);
        else
          out.push(result);
      });
      return out;
    }
    function translateMap(map, shape) {
      if (map == null)
        return void 0;
      var out = {};
      util.each(map, function(key, value) {
        var result = translate(value, shape.value);
        if (result === void 0)
          out[key] = null;
        else
          out[key] = result;
      });
      return out;
    }
    function translateScalar(value, shape) {
      return shape.toType(value);
    }
    module2.exports = JsonParser;
  }
});

// node_modules/aws-sdk/lib/protocol/helpers.js
var require_helpers = __commonJS({
  "node_modules/aws-sdk/lib/protocol/helpers.js"(exports, module2) {
    var util = require_util();
    var AWS2 = require_core2();
    function populateHostPrefix(request) {
      var enabled = request.service.config.hostPrefixEnabled;
      if (!enabled)
        return request;
      var operationModel = request.service.api.operations[request.operation];
      if (hasEndpointDiscover(request))
        return request;
      if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
        var hostPrefixNotation = operationModel.endpoint.hostPrefix;
        var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
        prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
        validateHostname(request.httpRequest.endpoint.hostname);
      }
      return request;
    }
    function hasEndpointDiscover(request) {
      var api = request.service.api;
      var operationModel = api.operations[request.operation];
      var isEndpointOperation = api.endpointOperation && api.endpointOperation === util.string.lowerFirst(operationModel.name);
      return operationModel.endpointDiscoveryRequired !== "NULL" || isEndpointOperation === true;
    }
    function expandHostPrefix(hostPrefixNotation, params, shape) {
      util.each(shape.members, function(name, member) {
        if (member.hostLabel === true) {
          if (typeof params[name] !== "string" || params[name] === "") {
            throw util.error(new Error(), {
              message: "Parameter " + name + " should be a non-empty string.",
              code: "InvalidParameter"
            });
          }
          var regex = new RegExp("\\{" + name + "\\}", "g");
          hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
        }
      });
      return hostPrefixNotation;
    }
    function prependEndpointPrefix(endpoint, prefix) {
      if (endpoint.host) {
        endpoint.host = prefix + endpoint.host;
      }
      if (endpoint.hostname) {
        endpoint.hostname = prefix + endpoint.hostname;
      }
    }
    function validateHostname(hostname) {
      var labels = hostname.split(".");
      var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
      util.arrayEach(labels, function(label) {
        if (!label.length || label.length < 1 || label.length > 63) {
          throw util.error(new Error(), {
            code: "ValidationError",
            message: "Hostname label length should be between 1 to 63 characters, inclusive."
          });
        }
        if (!hostPattern.test(label)) {
          throw AWS2.util.error(new Error(), { code: "ValidationError", message: label + " is not hostname compatible." });
        }
      });
    }
    module2.exports = {
      populateHostPrefix
    };
  }
});

// node_modules/aws-sdk/lib/protocol/json.js
var require_json = __commonJS({
  "node_modules/aws-sdk/lib/protocol/json.js"(exports, module2) {
    var util = require_util();
    var JsonBuilder = require_builder();
    var JsonParser = require_parser();
    var populateHostPrefix = require_helpers().populateHostPrefix;
    function buildRequest(req) {
      var httpRequest = req.httpRequest;
      var api = req.service.api;
      var target = api.targetPrefix + "." + api.operations[req.operation].name;
      var version2 = api.jsonVersion || "1.0";
      var input = api.operations[req.operation].input;
      var builder = new JsonBuilder();
      if (version2 === 1)
        version2 = "1.0";
      httpRequest.body = builder.build(req.params || {}, input);
      httpRequest.headers["Content-Type"] = "application/x-amz-json-" + version2;
      httpRequest.headers["X-Amz-Target"] = target;
      populateHostPrefix(req);
    }
    function extractError(resp) {
      var error2 = {};
      var httpResponse = resp.httpResponse;
      error2.code = httpResponse.headers["x-amzn-errortype"] || "UnknownError";
      if (typeof error2.code === "string") {
        error2.code = error2.code.split(":")[0];
      }
      if (httpResponse.body.length > 0) {
        try {
          var e2 = JSON.parse(httpResponse.body.toString());
          var code = e2.__type || e2.code || e2.Code;
          if (code) {
            error2.code = code.split("#").pop();
          }
          if (error2.code === "RequestEntityTooLarge") {
            error2.message = "Request body must be less than 1 MB";
          } else {
            error2.message = e2.message || e2.Message || null;
          }
        } catch (e3) {
          error2.statusCode = httpResponse.statusCode;
          error2.message = httpResponse.statusMessage;
        }
      } else {
        error2.statusCode = httpResponse.statusCode;
        error2.message = httpResponse.statusCode.toString();
      }
      resp.error = util.error(new Error(), error2);
    }
    function extractData(resp) {
      var body = resp.httpResponse.body.toString() || "{}";
      if (resp.request.service.config.convertResponseTypes === false) {
        resp.data = JSON.parse(body);
      } else {
        var operation = resp.request.service.api.operations[resp.request.operation];
        var shape = operation.output || {};
        var parser = new JsonParser();
        resp.data = parser.parse(body, shape);
      }
    }
    module2.exports = {
      buildRequest,
      extractError,
      extractData
    };
  }
});

// node_modules/aws-sdk/lib/query/query_param_serializer.js
var require_query_param_serializer = __commonJS({
  "node_modules/aws-sdk/lib/query/query_param_serializer.js"(exports, module2) {
    var util = require_util();
    function QueryParamSerializer() {
    }
    QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
      serializeStructure("", params, shape, fn);
    };
    function ucfirst(shape) {
      if (shape.isQueryName || shape.api.protocol !== "ec2") {
        return shape.name;
      } else {
        return shape.name[0].toUpperCase() + shape.name.substr(1);
      }
    }
    function serializeStructure(prefix, struct, rules, fn) {
      util.each(rules.members, function(name, member) {
        var value = struct[name];
        if (value === null || value === void 0)
          return;
        var memberName = ucfirst(member);
        memberName = prefix ? prefix + "." + memberName : memberName;
        serializeMember(memberName, value, member, fn);
      });
    }
    function serializeMap(name, map, rules, fn) {
      var i2 = 1;
      util.each(map, function(key, value) {
        var prefix = rules.flattened ? "." : ".entry.";
        var position = prefix + i2++ + ".";
        var keyName = position + (rules.key.name || "key");
        var valueName = position + (rules.value.name || "value");
        serializeMember(name + keyName, key, rules.key, fn);
        serializeMember(name + valueName, value, rules.value, fn);
      });
    }
    function serializeList(name, list, rules, fn) {
      var memberRules = rules.member || {};
      if (list.length === 0) {
        fn.call(this, name, null);
        return;
      }
      util.arrayEach(list, function(v, n) {
        var suffix = "." + (n + 1);
        if (rules.api.protocol === "ec2") {
          suffix = suffix + "";
        } else if (rules.flattened) {
          if (memberRules.name) {
            var parts = name.split(".");
            parts.pop();
            parts.push(ucfirst(memberRules));
            name = parts.join(".");
          }
        } else {
          suffix = "." + (memberRules.name ? memberRules.name : "member") + suffix;
        }
        serializeMember(name + suffix, v, memberRules, fn);
      });
    }
    function serializeMember(name, value, rules, fn) {
      if (value === null || value === void 0)
        return;
      if (rules.type === "structure") {
        serializeStructure(name, value, rules, fn);
      } else if (rules.type === "list") {
        serializeList(name, value, rules, fn);
      } else if (rules.type === "map") {
        serializeMap(name, value, rules, fn);
      } else {
        fn(name, rules.toWireFormat(value).toString());
      }
    }
    module2.exports = QueryParamSerializer;
  }
});

// node_modules/aws-sdk/lib/model/collection.js
var require_collection = __commonJS({
  "node_modules/aws-sdk/lib/model/collection.js"(exports, module2) {
    var memoizedProperty = require_util().memoizedProperty;
    function memoize(name, value, factory, nameTr) {
      memoizedProperty(this, nameTr(name), function() {
        return factory(name, value);
      });
    }
    function Collection(iterable, options, factory, nameTr, callback) {
      nameTr = nameTr || String;
      var self2 = this;
      for (var id in iterable) {
        if (Object.prototype.hasOwnProperty.call(iterable, id)) {
          memoize.call(self2, id, iterable[id], factory, nameTr);
          if (callback)
            callback(id, iterable[id]);
        }
      }
    }
    module2.exports = Collection;
  }
});

// node_modules/aws-sdk/lib/model/shape.js
var require_shape = __commonJS({
  "node_modules/aws-sdk/lib/model/shape.js"(exports, module2) {
    var Collection = require_collection();
    var util = require_util();
    function property(obj, name, value) {
      if (value !== null && value !== void 0) {
        util.property.apply(this, arguments);
      }
    }
    function memoizedProperty(obj, name) {
      if (!obj.constructor.prototype[name]) {
        util.memoizedProperty.apply(this, arguments);
      }
    }
    function Shape(shape, options, memberName) {
      options = options || {};
      property(this, "shape", shape.shape);
      property(this, "api", options.api, false);
      property(this, "type", shape.type);
      property(this, "enum", shape.enum);
      property(this, "min", shape.min);
      property(this, "max", shape.max);
      property(this, "pattern", shape.pattern);
      property(this, "location", shape.location || this.location || "body");
      property(this, "name", this.name || shape.xmlName || shape.queryName || shape.locationName || memberName);
      property(this, "isStreaming", shape.streaming || this.isStreaming || false);
      property(this, "requiresLength", shape.requiresLength, false);
      property(this, "isComposite", shape.isComposite || false);
      property(this, "isShape", true, false);
      property(this, "isQueryName", Boolean(shape.queryName), false);
      property(this, "isLocationName", Boolean(shape.locationName), false);
      property(this, "isIdempotent", shape.idempotencyToken === true);
      property(this, "isJsonValue", shape.jsonvalue === true);
      property(this, "isSensitive", shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
      property(this, "isEventStream", Boolean(shape.eventstream), false);
      property(this, "isEvent", Boolean(shape.event), false);
      property(this, "isEventPayload", Boolean(shape.eventpayload), false);
      property(this, "isEventHeader", Boolean(shape.eventheader), false);
      property(this, "isTimestampFormatSet", Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);
      property(this, "endpointDiscoveryId", Boolean(shape.endpointdiscoveryid), false);
      property(this, "hostLabel", Boolean(shape.hostLabel), false);
      if (options.documentation) {
        property(this, "documentation", shape.documentation);
        property(this, "documentationUrl", shape.documentationUrl);
      }
      if (shape.xmlAttribute) {
        property(this, "isXmlAttribute", shape.xmlAttribute || false);
      }
      property(this, "defaultValue", null);
      this.toWireFormat = function(value) {
        if (value === null || value === void 0)
          return "";
        return value;
      };
      this.toType = function(value) {
        return value;
      };
    }
    Shape.normalizedTypes = {
      character: "string",
      double: "float",
      long: "integer",
      short: "integer",
      biginteger: "integer",
      bigdecimal: "float",
      blob: "binary"
    };
    Shape.types = {
      "structure": StructureShape,
      "list": ListShape,
      "map": MapShape,
      "boolean": BooleanShape,
      "timestamp": TimestampShape,
      "float": FloatShape,
      "integer": IntegerShape,
      "string": StringShape,
      "base64": Base64Shape,
      "binary": BinaryShape
    };
    Shape.resolve = function resolve2(shape, options) {
      if (shape.shape) {
        var refShape = options.api.shapes[shape.shape];
        if (!refShape) {
          throw new Error("Cannot find shape reference: " + shape.shape);
        }
        return refShape;
      } else {
        return null;
      }
    };
    Shape.create = function create8(shape, options, memberName) {
      if (shape.isShape)
        return shape;
      var refShape = Shape.resolve(shape, options);
      if (refShape) {
        var filteredKeys = Object.keys(shape);
        if (!options.documentation) {
          filteredKeys = filteredKeys.filter(function(name) {
            return !name.match(/documentation/);
          });
        }
        var InlineShape = function() {
          refShape.constructor.call(this, shape, options, memberName);
        };
        InlineShape.prototype = refShape;
        return new InlineShape();
      } else {
        if (!shape.type) {
          if (shape.members)
            shape.type = "structure";
          else if (shape.member)
            shape.type = "list";
          else if (shape.key)
            shape.type = "map";
          else
            shape.type = "string";
        }
        var origType = shape.type;
        if (Shape.normalizedTypes[shape.type]) {
          shape.type = Shape.normalizedTypes[shape.type];
        }
        if (Shape.types[shape.type]) {
          return new Shape.types[shape.type](shape, options, memberName);
        } else {
          throw new Error("Unrecognized shape type: " + origType);
        }
      }
    };
    function CompositeShape(shape) {
      Shape.apply(this, arguments);
      property(this, "isComposite", true);
      if (shape.flattened) {
        property(this, "flattened", shape.flattened || false);
      }
    }
    function StructureShape(shape, options) {
      var self2 = this;
      var requiredMap = null, firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, "defaultValue", function() {
          return {};
        });
        property(this, "members", {});
        property(this, "memberNames", []);
        property(this, "required", []);
        property(this, "isRequired", function() {
          return false;
        });
        property(this, "isDocument", Boolean(shape.document));
      }
      if (shape.members) {
        property(this, "members", new Collection(shape.members, options, function(name, member) {
          return Shape.create(member, options, name);
        }));
        memoizedProperty(this, "memberNames", function() {
          return shape.xmlOrder || Object.keys(shape.members);
        });
        if (shape.event) {
          memoizedProperty(this, "eventPayloadMemberName", function() {
            var members = self2.members;
            var memberNames = self2.memberNames;
            for (var i2 = 0, iLen = memberNames.length; i2 < iLen; i2++) {
              if (members[memberNames[i2]].isEventPayload) {
                return memberNames[i2];
              }
            }
          });
          memoizedProperty(this, "eventHeaderMemberNames", function() {
            var members = self2.members;
            var memberNames = self2.memberNames;
            var eventHeaderMemberNames = [];
            for (var i2 = 0, iLen = memberNames.length; i2 < iLen; i2++) {
              if (members[memberNames[i2]].isEventHeader) {
                eventHeaderMemberNames.push(memberNames[i2]);
              }
            }
            return eventHeaderMemberNames;
          });
        }
      }
      if (shape.required) {
        property(this, "required", shape.required);
        property(this, "isRequired", function(name) {
          if (!requiredMap) {
            requiredMap = {};
            for (var i2 = 0; i2 < shape.required.length; i2++) {
              requiredMap[shape.required[i2]] = true;
            }
          }
          return requiredMap[name];
        }, false, true);
      }
      property(this, "resultWrapper", shape.resultWrapper || null);
      if (shape.payload) {
        property(this, "payload", shape.payload);
      }
      if (typeof shape.xmlNamespace === "string") {
        property(this, "xmlNamespaceUri", shape.xmlNamespace);
      } else if (typeof shape.xmlNamespace === "object") {
        property(this, "xmlNamespacePrefix", shape.xmlNamespace.prefix);
        property(this, "xmlNamespaceUri", shape.xmlNamespace.uri);
      }
    }
    function ListShape(shape, options) {
      var self2 = this, firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, "defaultValue", function() {
          return [];
        });
      }
      if (shape.member) {
        memoizedProperty(this, "member", function() {
          return Shape.create(shape.member, options);
        });
      }
      if (this.flattened) {
        var oldName = this.name;
        memoizedProperty(this, "name", function() {
          return self2.member.name || oldName;
        });
      }
    }
    function MapShape(shape, options) {
      var firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, "defaultValue", function() {
          return {};
        });
        property(this, "key", Shape.create({ type: "string" }, options));
        property(this, "value", Shape.create({ type: "string" }, options));
      }
      if (shape.key) {
        memoizedProperty(this, "key", function() {
          return Shape.create(shape.key, options);
        });
      }
      if (shape.value) {
        memoizedProperty(this, "value", function() {
          return Shape.create(shape.value, options);
        });
      }
    }
    function TimestampShape(shape) {
      var self2 = this;
      Shape.apply(this, arguments);
      if (shape.timestampFormat) {
        property(this, "timestampFormat", shape.timestampFormat);
      } else if (self2.isTimestampFormatSet && this.timestampFormat) {
        property(this, "timestampFormat", this.timestampFormat);
      } else if (this.location === "header") {
        property(this, "timestampFormat", "rfc822");
      } else if (this.location === "querystring") {
        property(this, "timestampFormat", "iso8601");
      } else if (this.api) {
        switch (this.api.protocol) {
          case "json":
          case "rest-json":
            property(this, "timestampFormat", "unixTimestamp");
            break;
          case "rest-xml":
          case "query":
          case "ec2":
            property(this, "timestampFormat", "iso8601");
            break;
        }
      }
      this.toType = function(value) {
        if (value === null || value === void 0)
          return null;
        if (typeof value.toUTCString === "function")
          return value;
        return typeof value === "string" || typeof value === "number" ? util.date.parseTimestamp(value) : null;
      };
      this.toWireFormat = function(value) {
        return util.date.format(value, self2.timestampFormat);
      };
    }
    function StringShape() {
      Shape.apply(this, arguments);
      var nullLessProtocols = ["rest-xml", "query", "ec2"];
      this.toType = function(value) {
        value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ? value || "" : value;
        if (this.isJsonValue) {
          return JSON.parse(value);
        }
        return value && typeof value.toString === "function" ? value.toString() : value;
      };
      this.toWireFormat = function(value) {
        return this.isJsonValue ? JSON.stringify(value) : value;
      };
    }
    function FloatShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        if (value === null || value === void 0)
          return null;
        return parseFloat(value);
      };
      this.toWireFormat = this.toType;
    }
    function IntegerShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        if (value === null || value === void 0)
          return null;
        return parseInt(value, 10);
      };
      this.toWireFormat = this.toType;
    }
    function BinaryShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        var buf = util.base64.decode(value);
        if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === "function") {
          var secureBuf = util.Buffer.alloc(buf.length, buf);
          buf.fill(0);
          buf = secureBuf;
        }
        return buf;
      };
      this.toWireFormat = util.base64.encode;
    }
    function Base64Shape() {
      BinaryShape.apply(this, arguments);
    }
    function BooleanShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        if (typeof value === "boolean")
          return value;
        if (value === null || value === void 0)
          return null;
        return value === "true";
      };
    }
    Shape.shapes = {
      StructureShape,
      ListShape,
      MapShape,
      StringShape,
      BooleanShape,
      Base64Shape
    };
    module2.exports = Shape;
  }
});

// node_modules/aws-sdk/lib/protocol/query.js
var require_query = __commonJS({
  "node_modules/aws-sdk/lib/protocol/query.js"(exports, module2) {
    var AWS2 = require_core2();
    var util = require_util();
    var QueryParamSerializer = require_query_param_serializer();
    var Shape = require_shape();
    var populateHostPrefix = require_helpers().populateHostPrefix;
    function buildRequest(req) {
      var operation = req.service.api.operations[req.operation];
      var httpRequest = req.httpRequest;
      httpRequest.headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
      httpRequest.params = {
        Version: req.service.api.apiVersion,
        Action: operation.name
      };
      var builder = new QueryParamSerializer();
      builder.serialize(req.params, operation.input, function(name, value) {
        httpRequest.params[name] = value;
      });
      httpRequest.body = util.queryParamsToString(httpRequest.params);
      populateHostPrefix(req);
    }
    function extractError(resp) {
      var data, body = resp.httpResponse.body.toString();
      if (body.match("<UnknownOperationException")) {
        data = {
          Code: "UnknownOperation",
          Message: "Unknown operation " + resp.request.operation
        };
      } else {
        try {
          data = new AWS2.XML.Parser().parse(body);
        } catch (e2) {
          data = {
            Code: resp.httpResponse.statusCode,
            Message: resp.httpResponse.statusMessage
          };
        }
      }
      if (data.requestId && !resp.requestId)
        resp.requestId = data.requestId;
      if (data.Errors)
        data = data.Errors;
      if (data.Error)
        data = data.Error;
      if (data.Code) {
        resp.error = util.error(new Error(), {
          code: data.Code,
          message: data.Message
        });
      } else {
        resp.error = util.error(new Error(), {
          code: resp.httpResponse.statusCode,
          message: null
        });
      }
    }
    function extractData(resp) {
      var req = resp.request;
      var operation = req.service.api.operations[req.operation];
      var shape = operation.output || {};
      var origRules = shape;
      if (origRules.resultWrapper) {
        var tmp = Shape.create({ type: "structure" });
        tmp.members[origRules.resultWrapper] = shape;
        tmp.memberNames = [origRules.resultWrapper];
        util.property(shape, "name", shape.resultWrapper);
        shape = tmp;
      }
      var parser = new AWS2.XML.Parser();
      if (shape && shape.members && !shape.members._XAMZRequestId) {
        var requestIdShape = Shape.create({ type: "string" }, { api: { protocol: "query" } }, "requestId");
        shape.members._XAMZRequestId = requestIdShape;
      }
      var data = parser.parse(resp.httpResponse.body.toString(), shape);
      resp.requestId = data._XAMZRequestId || data.requestId;
      if (data._XAMZRequestId)
        delete data._XAMZRequestId;
      if (origRules.resultWrapper) {
        if (data[origRules.resultWrapper]) {
          util.update(data, data[origRules.resultWrapper]);
          delete data[origRules.resultWrapper];
        }
      }
      resp.data = data;
    }
    module2.exports = {
      buildRequest,
      extractError,
      extractData
    };
  }
});

// node_modules/aws-sdk/lib/protocol/rest.js
var require_rest = __commonJS({
  "node_modules/aws-sdk/lib/protocol/rest.js"(exports, module2) {
    var util = require_util();
    var populateHostPrefix = require_helpers().populateHostPrefix;
    function populateMethod(req) {
      req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
    }
    function generateURI(endpointPath, operationPath, input, params) {
      var uri = [endpointPath, operationPath].join("/");
      uri = uri.replace(/\/+/g, "/");
      var queryString = {}, queryStringSet = false;
      util.each(input.members, function(name, member) {
        var paramValue = params[name];
        if (paramValue === null || paramValue === void 0)
          return;
        if (member.location === "uri") {
          var regex = new RegExp("\\{" + member.name + "(\\+)?\\}");
          uri = uri.replace(regex, function(_, plus) {
            var fn = plus ? util.uriEscapePath : util.uriEscape;
            return fn(String(paramValue));
          });
        } else if (member.location === "querystring") {
          queryStringSet = true;
          if (member.type === "list") {
            queryString[member.name] = paramValue.map(function(val) {
              return util.uriEscape(member.member.toWireFormat(val).toString());
            });
          } else if (member.type === "map") {
            util.each(paramValue, function(key, value) {
              if (Array.isArray(value)) {
                queryString[key] = value.map(function(val) {
                  return util.uriEscape(String(val));
                });
              } else {
                queryString[key] = util.uriEscape(String(value));
              }
            });
          } else {
            queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
          }
        }
      });
      if (queryStringSet) {
        uri += uri.indexOf("?") >= 0 ? "&" : "?";
        var parts = [];
        util.arrayEach(Object.keys(queryString).sort(), function(key) {
          if (!Array.isArray(queryString[key])) {
            queryString[key] = [queryString[key]];
          }
          for (var i2 = 0; i2 < queryString[key].length; i2++) {
            parts.push(util.uriEscape(String(key)) + "=" + queryString[key][i2]);
          }
        });
        uri += parts.join("&");
      }
      return uri;
    }
    function populateURI(req) {
      var operation = req.service.api.operations[req.operation];
      var input = operation.input;
      var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
      req.httpRequest.path = uri;
    }
    function populateHeaders(req) {
      var operation = req.service.api.operations[req.operation];
      util.each(operation.input.members, function(name, member) {
        var value = req.params[name];
        if (value === null || value === void 0)
          return;
        if (member.location === "headers" && member.type === "map") {
          util.each(value, function(key, memberValue) {
            req.httpRequest.headers[member.name + key] = memberValue;
          });
        } else if (member.location === "header") {
          value = member.toWireFormat(value).toString();
          if (member.isJsonValue) {
            value = util.base64.encode(value);
          }
          req.httpRequest.headers[member.name] = value;
        }
      });
    }
    function buildRequest(req) {
      populateMethod(req);
      populateURI(req);
      populateHeaders(req);
      populateHostPrefix(req);
    }
    function extractError() {
    }
    function extractData(resp) {
      var req = resp.request;
      var data = {};
      var r2 = resp.httpResponse;
      var operation = req.service.api.operations[req.operation];
      var output = operation.output;
      var headers = {};
      util.each(r2.headers, function(k, v) {
        headers[k.toLowerCase()] = v;
      });
      util.each(output.members, function(name, member) {
        var header = (member.name || name).toLowerCase();
        if (member.location === "headers" && member.type === "map") {
          data[name] = {};
          var location = member.isLocationName ? member.name : "";
          var pattern = new RegExp("^" + location + "(.+)", "i");
          util.each(r2.headers, function(k, v) {
            var result = k.match(pattern);
            if (result !== null) {
              data[name][result[1]] = v;
            }
          });
        } else if (member.location === "header") {
          if (headers[header] !== void 0) {
            var value = member.isJsonValue ? util.base64.decode(headers[header]) : headers[header];
            data[name] = member.toType(value);
          }
        } else if (member.location === "statusCode") {
          data[name] = parseInt(r2.statusCode, 10);
        }
      });
      resp.data = data;
    }
    module2.exports = {
      buildRequest,
      extractError,
      extractData,
      generateURI
    };
  }
});

// node_modules/aws-sdk/lib/protocol/rest_json.js
var require_rest_json = __commonJS({
  "node_modules/aws-sdk/lib/protocol/rest_json.js"(exports, module2) {
    var util = require_util();
    var Rest = require_rest();
    var Json = require_json();
    var JsonBuilder = require_builder();
    var JsonParser = require_parser();
    function populateBody(req) {
      var builder = new JsonBuilder();
      var input = req.service.api.operations[req.operation].input;
      if (input.payload) {
        var params = {};
        var payloadShape = input.members[input.payload];
        params = req.params[input.payload];
        if (payloadShape.type === "structure") {
          req.httpRequest.body = builder.build(params || {}, payloadShape);
          applyContentTypeHeader(req);
        } else if (params !== void 0) {
          req.httpRequest.body = params;
          if (payloadShape.type === "binary" || payloadShape.isStreaming) {
            applyContentTypeHeader(req, true);
          }
        }
      } else {
        req.httpRequest.body = builder.build(req.params, input);
        applyContentTypeHeader(req);
      }
    }
    function applyContentTypeHeader(req, isBinary) {
      if (!req.httpRequest.headers["Content-Type"]) {
        var type = isBinary ? "binary/octet-stream" : "application/json";
        req.httpRequest.headers["Content-Type"] = type;
      }
    }
    function buildRequest(req) {
      Rest.buildRequest(req);
      if (["GET", "HEAD", "DELETE"].indexOf(req.httpRequest.method) < 0) {
        populateBody(req);
      }
    }
    function extractError(resp) {
      Json.extractError(resp);
    }
    function extractData(resp) {
      Rest.extractData(resp);
      var req = resp.request;
      var operation = req.service.api.operations[req.operation];
      var rules = req.service.api.operations[req.operation].output || {};
      var parser;
      var hasEventOutput = operation.hasEventOutput;
      if (rules.payload) {
        var payloadMember = rules.members[rules.payload];
        var body = resp.httpResponse.body;
        if (payloadMember.isEventStream) {
          parser = new JsonParser();
          resp.data[payload] = util.createEventStream(AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body, parser, payloadMember);
        } else if (payloadMember.type === "structure" || payloadMember.type === "list") {
          var parser = new JsonParser();
          resp.data[rules.payload] = parser.parse(body, payloadMember);
        } else if (payloadMember.type === "binary" || payloadMember.isStreaming) {
          resp.data[rules.payload] = body;
        } else {
          resp.data[rules.payload] = payloadMember.toType(body);
        }
      } else {
        var data = resp.data;
        Json.extractData(resp);
        resp.data = util.merge(data, resp.data);
      }
    }
    module2.exports = {
      buildRequest,
      extractError,
      extractData
    };
  }
});

// node_modules/aws-sdk/lib/protocol/rest_xml.js
var require_rest_xml = __commonJS({
  "node_modules/aws-sdk/lib/protocol/rest_xml.js"(exports, module2) {
    var AWS2 = require_core2();
    var util = require_util();
    var Rest = require_rest();
    function populateBody(req) {
      var input = req.service.api.operations[req.operation].input;
      var builder = new AWS2.XML.Builder();
      var params = req.params;
      var payload2 = input.payload;
      if (payload2) {
        var payloadMember = input.members[payload2];
        params = params[payload2];
        if (params === void 0)
          return;
        if (payloadMember.type === "structure") {
          var rootElement = payloadMember.name;
          req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
        } else {
          req.httpRequest.body = params;
        }
      } else {
        req.httpRequest.body = builder.toXML(params, input, input.name || input.shape || util.string.upperFirst(req.operation) + "Request");
      }
    }
    function buildRequest(req) {
      Rest.buildRequest(req);
      if (["GET", "HEAD"].indexOf(req.httpRequest.method) < 0) {
        populateBody(req);
      }
    }
    function extractError(resp) {
      Rest.extractError(resp);
      var data;
      try {
        data = new AWS2.XML.Parser().parse(resp.httpResponse.body.toString());
      } catch (e2) {
        data = {
          Code: resp.httpResponse.statusCode,
          Message: resp.httpResponse.statusMessage
        };
      }
      if (data.Errors)
        data = data.Errors;
      if (data.Error)
        data = data.Error;
      if (data.Code) {
        resp.error = util.error(new Error(), {
          code: data.Code,
          message: data.Message
        });
      } else {
        resp.error = util.error(new Error(), {
          code: resp.httpResponse.statusCode,
          message: null
        });
      }
    }
    function extractData(resp) {
      Rest.extractData(resp);
      var parser;
      var req = resp.request;
      var body = resp.httpResponse.body;
      var operation = req.service.api.operations[req.operation];
      var output = operation.output;
      var hasEventOutput = operation.hasEventOutput;
      var payload2 = output.payload;
      if (payload2) {
        var payloadMember = output.members[payload2];
        if (payloadMember.isEventStream) {
          parser = new AWS2.XML.Parser();
          resp.data[payload2] = util.createEventStream(AWS2.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body, parser, payloadMember);
        } else if (payloadMember.type === "structure") {
          parser = new AWS2.XML.Parser();
          resp.data[payload2] = parser.parse(body.toString(), payloadMember);
        } else if (payloadMember.type === "binary" || payloadMember.isStreaming) {
          resp.data[payload2] = body;
        } else {
          resp.data[payload2] = payloadMember.toType(body);
        }
      } else if (body.length > 0) {
        parser = new AWS2.XML.Parser();
        var data = parser.parse(body.toString(), output);
        util.update(resp.data, data);
      }
    }
    module2.exports = {
      buildRequest,
      extractError,
      extractData
    };
  }
});

// node_modules/aws-sdk/lib/xml/escape-attribute.js
var require_escape_attribute = __commonJS({
  "node_modules/aws-sdk/lib/xml/escape-attribute.js"(exports, module2) {
    function escapeAttribute(value) {
      return value.replace(/&/g, "&amp;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }
    module2.exports = {
      escapeAttribute
    };
  }
});

// node_modules/aws-sdk/lib/xml/xml-node.js
var require_xml_node = __commonJS({
  "node_modules/aws-sdk/lib/xml/xml-node.js"(exports, module2) {
    var escapeAttribute = require_escape_attribute().escapeAttribute;
    function XmlNode(name, children) {
      if (children === void 0) {
        children = [];
      }
      this.name = name;
      this.children = children;
      this.attributes = {};
    }
    XmlNode.prototype.addAttribute = function(name, value) {
      this.attributes[name] = value;
      return this;
    };
    XmlNode.prototype.addChildNode = function(child) {
      this.children.push(child);
      return this;
    };
    XmlNode.prototype.removeAttribute = function(name) {
      delete this.attributes[name];
      return this;
    };
    XmlNode.prototype.toString = function() {
      var hasChildren = Boolean(this.children.length);
      var xmlText = "<" + this.name;
      var attributes = this.attributes;
      for (var i2 = 0, attributeNames = Object.keys(attributes); i2 < attributeNames.length; i2++) {
        var attributeName = attributeNames[i2];
        var attribute = attributes[attributeName];
        if (typeof attribute !== "undefined" && attribute !== null) {
          xmlText += " " + attributeName + '="' + escapeAttribute("" + attribute) + '"';
        }
      }
      return xmlText += !hasChildren ? "/>" : ">" + this.children.map(function(c) {
        return c.toString();
      }).join("") + "</" + this.name + ">";
    };
    module2.exports = {
      XmlNode
    };
  }
});

// node_modules/aws-sdk/lib/xml/escape-element.js
var require_escape_element = __commonJS({
  "node_modules/aws-sdk/lib/xml/escape-element.js"(exports, module2) {
    function escapeElement(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;");
    }
    module2.exports = {
      escapeElement
    };
  }
});

// node_modules/aws-sdk/lib/xml/xml-text.js
var require_xml_text = __commonJS({
  "node_modules/aws-sdk/lib/xml/xml-text.js"(exports, module2) {
    var escapeElement = require_escape_element().escapeElement;
    function XmlText(value) {
      this.value = value;
    }
    XmlText.prototype.toString = function() {
      return escapeElement("" + this.value);
    };
    module2.exports = {
      XmlText
    };
  }
});

// node_modules/aws-sdk/lib/xml/builder.js
var require_builder2 = __commonJS({
  "node_modules/aws-sdk/lib/xml/builder.js"(exports, module2) {
    var util = require_util();
    var XmlNode = require_xml_node().XmlNode;
    var XmlText = require_xml_text().XmlText;
    function XmlBuilder() {
    }
    XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
      var xml = new XmlNode(rootElement);
      applyNamespaces(xml, shape, true);
      serialize(xml, params, shape);
      return xml.children.length > 0 || noEmpty ? xml.toString() : "";
    };
    function serialize(xml, value, shape) {
      switch (shape.type) {
        case "structure":
          return serializeStructure(xml, value, shape);
        case "map":
          return serializeMap(xml, value, shape);
        case "list":
          return serializeList(xml, value, shape);
        default:
          return serializeScalar(xml, value, shape);
      }
    }
    function serializeStructure(xml, params, shape) {
      util.arrayEach(shape.memberNames, function(memberName) {
        var memberShape = shape.members[memberName];
        if (memberShape.location !== "body")
          return;
        var value = params[memberName];
        var name = memberShape.name;
        if (value !== void 0 && value !== null) {
          if (memberShape.isXmlAttribute) {
            xml.addAttribute(name, value);
          } else if (memberShape.flattened) {
            serialize(xml, value, memberShape);
          } else {
            var element = new XmlNode(name);
            xml.addChildNode(element);
            applyNamespaces(element, memberShape);
            serialize(element, value, memberShape);
          }
        }
      });
    }
    function serializeMap(xml, map, shape) {
      var xmlKey = shape.key.name || "key";
      var xmlValue = shape.value.name || "value";
      util.each(map, function(key, value) {
        var entry = new XmlNode(shape.flattened ? shape.name : "entry");
        xml.addChildNode(entry);
        var entryKey = new XmlNode(xmlKey);
        var entryValue = new XmlNode(xmlValue);
        entry.addChildNode(entryKey);
        entry.addChildNode(entryValue);
        serialize(entryKey, key, shape.key);
        serialize(entryValue, value, shape.value);
      });
    }
    function serializeList(xml, list, shape) {
      if (shape.flattened) {
        util.arrayEach(list, function(value) {
          var name = shape.member.name || shape.name;
          var element = new XmlNode(name);
          xml.addChildNode(element);
          serialize(element, value, shape.member);
        });
      } else {
        util.arrayEach(list, function(value) {
          var name = shape.member.name || "member";
          var element = new XmlNode(name);
          xml.addChildNode(element);
          serialize(element, value, shape.member);
        });
      }
    }
    function serializeScalar(xml, value, shape) {
      xml.addChildNode(new XmlText(shape.toWireFormat(value)));
    }
    function applyNamespaces(xml, shape, isRoot) {
      var uri, prefix = "xmlns";
      if (shape.xmlNamespaceUri) {
        uri = shape.xmlNamespaceUri;
        if (shape.xmlNamespacePrefix)
          prefix += ":" + shape.xmlNamespacePrefix;
      } else if (isRoot && shape.api.xmlNamespaceUri) {
        uri = shape.api.xmlNamespaceUri;
      }
      if (uri)
        xml.addAttribute(prefix, uri);
    }
    module2.exports = XmlBuilder;
  }
});

// node_modules/aws-sdk/lib/model/operation.js
var require_operation = __commonJS({
  "node_modules/aws-sdk/lib/model/operation.js"(exports, module2) {
    var Shape = require_shape();
    var util = require_util();
    var property = util.property;
    var memoizedProperty = util.memoizedProperty;
    function Operation(name, operation, options) {
      var self2 = this;
      options = options || {};
      property(this, "name", operation.name || name);
      property(this, "api", options.api, false);
      operation.http = operation.http || {};
      property(this, "endpoint", operation.endpoint);
      property(this, "httpMethod", operation.http.method || "POST");
      property(this, "httpPath", operation.http.requestUri || "/");
      property(this, "authtype", operation.authtype || "");
      property(this, "endpointDiscoveryRequired", operation.endpointdiscovery ? operation.endpointdiscovery.required ? "REQUIRED" : "OPTIONAL" : "NULL");
      var httpChecksumRequired = operation.httpChecksumRequired || operation.httpChecksum && operation.httpChecksum.requestChecksumRequired;
      property(this, "httpChecksumRequired", httpChecksumRequired, false);
      memoizedProperty(this, "input", function() {
        if (!operation.input) {
          return new Shape.create({ type: "structure" }, options);
        }
        return Shape.create(operation.input, options);
      });
      memoizedProperty(this, "output", function() {
        if (!operation.output) {
          return new Shape.create({ type: "structure" }, options);
        }
        return Shape.create(operation.output, options);
      });
      memoizedProperty(this, "errors", function() {
        var list = [];
        if (!operation.errors)
          return null;
        for (var i2 = 0; i2 < operation.errors.length; i2++) {
          list.push(Shape.create(operation.errors[i2], options));
        }
        return list;
      });
      memoizedProperty(this, "paginator", function() {
        return options.api.paginators[name];
      });
      if (options.documentation) {
        property(this, "documentation", operation.documentation);
        property(this, "documentationUrl", operation.documentationUrl);
      }
      memoizedProperty(this, "idempotentMembers", function() {
        var idempotentMembers = [];
        var input = self2.input;
        var members = input.members;
        if (!input.members) {
          return idempotentMembers;
        }
        for (var name2 in members) {
          if (!members.hasOwnProperty(name2)) {
            continue;
          }
          if (members[name2].isIdempotent === true) {
            idempotentMembers.push(name2);
          }
        }
        return idempotentMembers;
      });
      memoizedProperty(this, "hasEventOutput", function() {
        var output = self2.output;
        return hasEventStream(output);
      });
    }
    function hasEventStream(topLevelShape) {
      var members = topLevelShape.members;
      var payload2 = topLevelShape.payload;
      if (!topLevelShape.members) {
        return false;
      }
      if (payload2) {
        var payloadMember = members[payload2];
        return payloadMember.isEventStream;
      }
      for (var name in members) {
        if (!members.hasOwnProperty(name)) {
          if (members[name].isEventStream === true) {
            return true;
          }
        }
      }
      return false;
    }
    module2.exports = Operation;
  }
});

// node_modules/aws-sdk/lib/model/paginator.js
var require_paginator = __commonJS({
  "node_modules/aws-sdk/lib/model/paginator.js"(exports, module2) {
    var property = require_util().property;
    function Paginator(name, paginator) {
      property(this, "inputToken", paginator.input_token);
      property(this, "limitKey", paginator.limit_key);
      property(this, "moreResults", paginator.more_results);
      property(this, "outputToken", paginator.output_token);
      property(this, "resultKey", paginator.result_key);
    }
    module2.exports = Paginator;
  }
});

// node_modules/aws-sdk/lib/model/resource_waiter.js
var require_resource_waiter = __commonJS({
  "node_modules/aws-sdk/lib/model/resource_waiter.js"(exports, module2) {
    var util = require_util();
    var property = util.property;
    function ResourceWaiter(name, waiter, options) {
      options = options || {};
      property(this, "name", name);
      property(this, "api", options.api, false);
      if (waiter.operation) {
        property(this, "operation", util.string.lowerFirst(waiter.operation));
      }
      var self2 = this;
      var keys = [
        "type",
        "description",
        "delay",
        "maxAttempts",
        "acceptors"
      ];
      keys.forEach(function(key) {
        var value = waiter[key];
        if (value) {
          property(self2, key, value);
        }
      });
    }
    module2.exports = ResourceWaiter;
  }
});

// node_modules/aws-sdk/apis/metadata.json
var require_metadata = __commonJS({
  "node_modules/aws-sdk/apis/metadata.json"(exports, module2) {
    module2.exports = {
      acm: {
        name: "ACM",
        cors: true
      },
      apigateway: {
        name: "APIGateway",
        cors: true
      },
      applicationautoscaling: {
        prefix: "application-autoscaling",
        name: "ApplicationAutoScaling",
        cors: true
      },
      appstream: {
        name: "AppStream"
      },
      autoscaling: {
        name: "AutoScaling",
        cors: true
      },
      batch: {
        name: "Batch"
      },
      budgets: {
        name: "Budgets"
      },
      clouddirectory: {
        name: "CloudDirectory",
        versions: [
          "2016-05-10*"
        ]
      },
      cloudformation: {
        name: "CloudFormation",
        cors: true
      },
      cloudfront: {
        name: "CloudFront",
        versions: [
          "2013-05-12*",
          "2013-11-11*",
          "2014-05-31*",
          "2014-10-21*",
          "2014-11-06*",
          "2015-04-17*",
          "2015-07-27*",
          "2015-09-17*",
          "2016-01-13*",
          "2016-01-28*",
          "2016-08-01*",
          "2016-08-20*",
          "2016-09-07*",
          "2016-09-29*",
          "2016-11-25*",
          "2017-03-25*",
          "2017-10-30*",
          "2018-06-18*",
          "2018-11-05*",
          "2019-03-26*"
        ],
        cors: true
      },
      cloudhsm: {
        name: "CloudHSM",
        cors: true
      },
      cloudsearch: {
        name: "CloudSearch"
      },
      cloudsearchdomain: {
        name: "CloudSearchDomain"
      },
      cloudtrail: {
        name: "CloudTrail",
        cors: true
      },
      cloudwatch: {
        prefix: "monitoring",
        name: "CloudWatch",
        cors: true
      },
      cloudwatchevents: {
        prefix: "events",
        name: "CloudWatchEvents",
        versions: [
          "2014-02-03*"
        ],
        cors: true
      },
      cloudwatchlogs: {
        prefix: "logs",
        name: "CloudWatchLogs",
        cors: true
      },
      codebuild: {
        name: "CodeBuild",
        cors: true
      },
      codecommit: {
        name: "CodeCommit",
        cors: true
      },
      codedeploy: {
        name: "CodeDeploy",
        cors: true
      },
      codepipeline: {
        name: "CodePipeline",
        cors: true
      },
      cognitoidentity: {
        prefix: "cognito-identity",
        name: "CognitoIdentity",
        cors: true
      },
      cognitoidentityserviceprovider: {
        prefix: "cognito-idp",
        name: "CognitoIdentityServiceProvider",
        cors: true
      },
      cognitosync: {
        prefix: "cognito-sync",
        name: "CognitoSync",
        cors: true
      },
      configservice: {
        prefix: "config",
        name: "ConfigService",
        cors: true
      },
      cur: {
        name: "CUR",
        cors: true
      },
      datapipeline: {
        name: "DataPipeline"
      },
      devicefarm: {
        name: "DeviceFarm",
        cors: true
      },
      directconnect: {
        name: "DirectConnect",
        cors: true
      },
      directoryservice: {
        prefix: "ds",
        name: "DirectoryService"
      },
      discovery: {
        name: "Discovery"
      },
      dms: {
        name: "DMS"
      },
      dynamodb: {
        name: "DynamoDB",
        cors: true
      },
      dynamodbstreams: {
        prefix: "streams.dynamodb",
        name: "DynamoDBStreams",
        cors: true
      },
      ec2: {
        name: "EC2",
        versions: [
          "2013-06-15*",
          "2013-10-15*",
          "2014-02-01*",
          "2014-05-01*",
          "2014-06-15*",
          "2014-09-01*",
          "2014-10-01*",
          "2015-03-01*",
          "2015-04-15*",
          "2015-10-01*",
          "2016-04-01*",
          "2016-09-15*"
        ],
        cors: true
      },
      ecr: {
        name: "ECR",
        cors: true
      },
      ecs: {
        name: "ECS",
        cors: true
      },
      efs: {
        prefix: "elasticfilesystem",
        name: "EFS",
        cors: true
      },
      elasticache: {
        name: "ElastiCache",
        versions: [
          "2012-11-15*",
          "2014-03-24*",
          "2014-07-15*",
          "2014-09-30*"
        ],
        cors: true
      },
      elasticbeanstalk: {
        name: "ElasticBeanstalk",
        cors: true
      },
      elb: {
        prefix: "elasticloadbalancing",
        name: "ELB",
        cors: true
      },
      elbv2: {
        prefix: "elasticloadbalancingv2",
        name: "ELBv2",
        cors: true
      },
      emr: {
        prefix: "elasticmapreduce",
        name: "EMR",
        cors: true
      },
      es: {
        name: "ES"
      },
      elastictranscoder: {
        name: "ElasticTranscoder",
        cors: true
      },
      firehose: {
        name: "Firehose",
        cors: true
      },
      gamelift: {
        name: "GameLift",
        cors: true
      },
      glacier: {
        name: "Glacier"
      },
      health: {
        name: "Health"
      },
      iam: {
        name: "IAM",
        cors: true
      },
      importexport: {
        name: "ImportExport"
      },
      inspector: {
        name: "Inspector",
        versions: [
          "2015-08-18*"
        ],
        cors: true
      },
      iot: {
        name: "Iot",
        cors: true
      },
      iotdata: {
        prefix: "iot-data",
        name: "IotData",
        cors: true
      },
      kinesis: {
        name: "Kinesis",
        cors: true
      },
      kinesisanalytics: {
        name: "KinesisAnalytics"
      },
      kms: {
        name: "KMS",
        cors: true
      },
      lambda: {
        name: "Lambda",
        cors: true
      },
      lexruntime: {
        prefix: "runtime.lex",
        name: "LexRuntime",
        cors: true
      },
      lightsail: {
        name: "Lightsail"
      },
      machinelearning: {
        name: "MachineLearning",
        cors: true
      },
      marketplacecommerceanalytics: {
        name: "MarketplaceCommerceAnalytics",
        cors: true
      },
      marketplacemetering: {
        prefix: "meteringmarketplace",
        name: "MarketplaceMetering"
      },
      mturk: {
        prefix: "mturk-requester",
        name: "MTurk",
        cors: true
      },
      mobileanalytics: {
        name: "MobileAnalytics",
        cors: true
      },
      opsworks: {
        name: "OpsWorks",
        cors: true
      },
      opsworkscm: {
        name: "OpsWorksCM"
      },
      organizations: {
        name: "Organizations"
      },
      pinpoint: {
        name: "Pinpoint"
      },
      polly: {
        name: "Polly",
        cors: true
      },
      rds: {
        name: "RDS",
        versions: [
          "2014-09-01*"
        ],
        cors: true
      },
      redshift: {
        name: "Redshift",
        cors: true
      },
      rekognition: {
        name: "Rekognition",
        cors: true
      },
      resourcegroupstaggingapi: {
        name: "ResourceGroupsTaggingAPI"
      },
      route53: {
        name: "Route53",
        cors: true
      },
      route53domains: {
        name: "Route53Domains",
        cors: true
      },
      s3: {
        name: "S3",
        dualstackAvailable: true,
        cors: true
      },
      s3control: {
        name: "S3Control",
        dualstackAvailable: true,
        xmlNoDefaultLists: true
      },
      servicecatalog: {
        name: "ServiceCatalog",
        cors: true
      },
      ses: {
        prefix: "email",
        name: "SES",
        cors: true
      },
      shield: {
        name: "Shield"
      },
      simpledb: {
        prefix: "sdb",
        name: "SimpleDB"
      },
      sms: {
        name: "SMS"
      },
      snowball: {
        name: "Snowball"
      },
      sns: {
        name: "SNS",
        cors: true
      },
      sqs: {
        name: "SQS",
        cors: true
      },
      ssm: {
        name: "SSM",
        cors: true
      },
      storagegateway: {
        name: "StorageGateway",
        cors: true
      },
      stepfunctions: {
        prefix: "states",
        name: "StepFunctions"
      },
      sts: {
        name: "STS",
        cors: true
      },
      support: {
        name: "Support"
      },
      swf: {
        name: "SWF"
      },
      xray: {
        name: "XRay",
        cors: true
      },
      waf: {
        name: "WAF",
        cors: true
      },
      wafregional: {
        prefix: "waf-regional",
        name: "WAFRegional"
      },
      workdocs: {
        name: "WorkDocs",
        cors: true
      },
      workspaces: {
        name: "WorkSpaces"
      },
      codestar: {
        name: "CodeStar"
      },
      lexmodelbuildingservice: {
        prefix: "lex-models",
        name: "LexModelBuildingService",
        cors: true
      },
      marketplaceentitlementservice: {
        prefix: "entitlement.marketplace",
        name: "MarketplaceEntitlementService"
      },
      athena: {
        name: "Athena",
        cors: true
      },
      greengrass: {
        name: "Greengrass"
      },
      dax: {
        name: "DAX"
      },
      migrationhub: {
        prefix: "AWSMigrationHub",
        name: "MigrationHub"
      },
      cloudhsmv2: {
        name: "CloudHSMV2",
        cors: true
      },
      glue: {
        name: "Glue"
      },
      mobile: {
        name: "Mobile"
      },
      pricing: {
        name: "Pricing",
        cors: true
      },
      costexplorer: {
        prefix: "ce",
        name: "CostExplorer",
        cors: true
      },
      mediaconvert: {
        name: "MediaConvert"
      },
      medialive: {
        name: "MediaLive"
      },
      mediapackage: {
        name: "MediaPackage"
      },
      mediastore: {
        name: "MediaStore"
      },
      mediastoredata: {
        prefix: "mediastore-data",
        name: "MediaStoreData",
        cors: true
      },
      appsync: {
        name: "AppSync"
      },
      guardduty: {
        name: "GuardDuty"
      },
      mq: {
        name: "MQ"
      },
      comprehend: {
        name: "Comprehend",
        cors: true
      },
      iotjobsdataplane: {
        prefix: "iot-jobs-data",
        name: "IoTJobsDataPlane"
      },
      kinesisvideoarchivedmedia: {
        prefix: "kinesis-video-archived-media",
        name: "KinesisVideoArchivedMedia",
        cors: true
      },
      kinesisvideomedia: {
        prefix: "kinesis-video-media",
        name: "KinesisVideoMedia",
        cors: true
      },
      kinesisvideo: {
        name: "KinesisVideo",
        cors: true
      },
      sagemakerruntime: {
        prefix: "runtime.sagemaker",
        name: "SageMakerRuntime"
      },
      sagemaker: {
        name: "SageMaker"
      },
      translate: {
        name: "Translate",
        cors: true
      },
      resourcegroups: {
        prefix: "resource-groups",
        name: "ResourceGroups",
        cors: true
      },
      alexaforbusiness: {
        name: "AlexaForBusiness"
      },
      cloud9: {
        name: "Cloud9"
      },
      serverlessapplicationrepository: {
        prefix: "serverlessrepo",
        name: "ServerlessApplicationRepository"
      },
      servicediscovery: {
        name: "ServiceDiscovery"
      },
      workmail: {
        name: "WorkMail"
      },
      autoscalingplans: {
        prefix: "autoscaling-plans",
        name: "AutoScalingPlans"
      },
      transcribeservice: {
        prefix: "transcribe",
        name: "TranscribeService"
      },
      connect: {
        name: "Connect",
        cors: true
      },
      acmpca: {
        prefix: "acm-pca",
        name: "ACMPCA"
      },
      fms: {
        name: "FMS"
      },
      secretsmanager: {
        name: "SecretsManager",
        cors: true
      },
      iotanalytics: {
        name: "IoTAnalytics",
        cors: true
      },
      iot1clickdevicesservice: {
        prefix: "iot1click-devices",
        name: "IoT1ClickDevicesService"
      },
      iot1clickprojects: {
        prefix: "iot1click-projects",
        name: "IoT1ClickProjects"
      },
      pi: {
        name: "PI"
      },
      neptune: {
        name: "Neptune"
      },
      mediatailor: {
        name: "MediaTailor"
      },
      eks: {
        name: "EKS"
      },
      macie: {
        name: "Macie"
      },
      dlm: {
        name: "DLM"
      },
      signer: {
        name: "Signer"
      },
      chime: {
        name: "Chime"
      },
      pinpointemail: {
        prefix: "pinpoint-email",
        name: "PinpointEmail"
      },
      ram: {
        name: "RAM"
      },
      route53resolver: {
        name: "Route53Resolver"
      },
      pinpointsmsvoice: {
        prefix: "sms-voice",
        name: "PinpointSMSVoice"
      },
      quicksight: {
        name: "QuickSight"
      },
      rdsdataservice: {
        prefix: "rds-data",
        name: "RDSDataService"
      },
      amplify: {
        name: "Amplify"
      },
      datasync: {
        name: "DataSync"
      },
      robomaker: {
        name: "RoboMaker"
      },
      transfer: {
        name: "Transfer"
      },
      globalaccelerator: {
        name: "GlobalAccelerator"
      },
      comprehendmedical: {
        name: "ComprehendMedical",
        cors: true
      },
      kinesisanalyticsv2: {
        name: "KinesisAnalyticsV2"
      },
      mediaconnect: {
        name: "MediaConnect"
      },
      fsx: {
        name: "FSx"
      },
      securityhub: {
        name: "SecurityHub"
      },
      appmesh: {
        name: "AppMesh",
        versions: [
          "2018-10-01*"
        ]
      },
      licensemanager: {
        prefix: "license-manager",
        name: "LicenseManager"
      },
      kafka: {
        name: "Kafka"
      },
      apigatewaymanagementapi: {
        name: "ApiGatewayManagementApi"
      },
      apigatewayv2: {
        name: "ApiGatewayV2"
      },
      docdb: {
        name: "DocDB"
      },
      backup: {
        name: "Backup"
      },
      worklink: {
        name: "WorkLink"
      },
      textract: {
        name: "Textract"
      },
      managedblockchain: {
        name: "ManagedBlockchain"
      },
      mediapackagevod: {
        prefix: "mediapackage-vod",
        name: "MediaPackageVod"
      },
      groundstation: {
        name: "GroundStation"
      },
      iotthingsgraph: {
        name: "IoTThingsGraph"
      },
      iotevents: {
        name: "IoTEvents"
      },
      ioteventsdata: {
        prefix: "iotevents-data",
        name: "IoTEventsData"
      },
      personalize: {
        name: "Personalize",
        cors: true
      },
      personalizeevents: {
        prefix: "personalize-events",
        name: "PersonalizeEvents",
        cors: true
      },
      personalizeruntime: {
        prefix: "personalize-runtime",
        name: "PersonalizeRuntime",
        cors: true
      },
      applicationinsights: {
        prefix: "application-insights",
        name: "ApplicationInsights"
      },
      servicequotas: {
        prefix: "service-quotas",
        name: "ServiceQuotas"
      },
      ec2instanceconnect: {
        prefix: "ec2-instance-connect",
        name: "EC2InstanceConnect"
      },
      eventbridge: {
        name: "EventBridge"
      },
      lakeformation: {
        name: "LakeFormation"
      },
      forecastservice: {
        prefix: "forecast",
        name: "ForecastService",
        cors: true
      },
      forecastqueryservice: {
        prefix: "forecastquery",
        name: "ForecastQueryService",
        cors: true
      },
      qldb: {
        name: "QLDB"
      },
      qldbsession: {
        prefix: "qldb-session",
        name: "QLDBSession"
      },
      workmailmessageflow: {
        name: "WorkMailMessageFlow"
      },
      codestarnotifications: {
        prefix: "codestar-notifications",
        name: "CodeStarNotifications"
      },
      savingsplans: {
        name: "SavingsPlans"
      },
      sso: {
        name: "SSO"
      },
      ssooidc: {
        prefix: "sso-oidc",
        name: "SSOOIDC"
      },
      marketplacecatalog: {
        prefix: "marketplace-catalog",
        name: "MarketplaceCatalog"
      },
      dataexchange: {
        name: "DataExchange"
      },
      sesv2: {
        name: "SESV2"
      },
      migrationhubconfig: {
        prefix: "migrationhub-config",
        name: "MigrationHubConfig"
      },
      connectparticipant: {
        name: "ConnectParticipant"
      },
      appconfig: {
        name: "AppConfig"
      },
      iotsecuretunneling: {
        name: "IoTSecureTunneling"
      },
      wafv2: {
        name: "WAFV2"
      },
      elasticinference: {
        prefix: "elastic-inference",
        name: "ElasticInference"
      },
      imagebuilder: {
        name: "Imagebuilder"
      },
      schemas: {
        name: "Schemas"
      },
      accessanalyzer: {
        name: "AccessAnalyzer"
      },
      codegurureviewer: {
        prefix: "codeguru-reviewer",
        name: "CodeGuruReviewer"
      },
      codeguruprofiler: {
        name: "CodeGuruProfiler"
      },
      computeoptimizer: {
        prefix: "compute-optimizer",
        name: "ComputeOptimizer"
      },
      frauddetector: {
        name: "FraudDetector"
      },
      kendra: {
        name: "Kendra"
      },
      networkmanager: {
        name: "NetworkManager"
      },
      outposts: {
        name: "Outposts"
      },
      augmentedairuntime: {
        prefix: "sagemaker-a2i-runtime",
        name: "AugmentedAIRuntime"
      },
      ebs: {
        name: "EBS"
      },
      kinesisvideosignalingchannels: {
        prefix: "kinesis-video-signaling",
        name: "KinesisVideoSignalingChannels",
        cors: true
      },
      detective: {
        name: "Detective"
      },
      codestarconnections: {
        prefix: "codestar-connections",
        name: "CodeStarconnections"
      },
      synthetics: {
        name: "Synthetics"
      },
      iotsitewise: {
        name: "IoTSiteWise"
      },
      macie2: {
        name: "Macie2"
      },
      codeartifact: {
        name: "CodeArtifact"
      },
      honeycode: {
        name: "Honeycode"
      },
      ivs: {
        name: "IVS"
      },
      braket: {
        name: "Braket"
      },
      identitystore: {
        name: "IdentityStore"
      },
      appflow: {
        name: "Appflow"
      },
      redshiftdata: {
        prefix: "redshift-data",
        name: "RedshiftData"
      },
      ssoadmin: {
        prefix: "sso-admin",
        name: "SSOAdmin"
      },
      timestreamquery: {
        prefix: "timestream-query",
        name: "TimestreamQuery"
      },
      timestreamwrite: {
        prefix: "timestream-write",
        name: "TimestreamWrite"
      },
      s3outposts: {
        name: "S3Outposts"
      },
      databrew: {
        name: "DataBrew"
      },
      servicecatalogappregistry: {
        prefix: "servicecatalog-appregistry",
        name: "ServiceCatalogAppRegistry"
      },
      networkfirewall: {
        prefix: "network-firewall",
        name: "NetworkFirewall"
      },
      mwaa: {
        name: "MWAA"
      },
      amplifybackend: {
        name: "AmplifyBackend"
      },
      appintegrations: {
        name: "AppIntegrations"
      },
      connectcontactlens: {
        prefix: "connect-contact-lens",
        name: "ConnectContactLens"
      },
      devopsguru: {
        prefix: "devops-guru",
        name: "DevOpsGuru"
      },
      ecrpublic: {
        prefix: "ecr-public",
        name: "ECRPUBLIC"
      },
      lookoutvision: {
        name: "LookoutVision"
      },
      sagemakerfeaturestoreruntime: {
        prefix: "sagemaker-featurestore-runtime",
        name: "SageMakerFeatureStoreRuntime"
      },
      customerprofiles: {
        prefix: "customer-profiles",
        name: "CustomerProfiles"
      },
      auditmanager: {
        name: "AuditManager"
      },
      emrcontainers: {
        prefix: "emr-containers",
        name: "EMRcontainers"
      },
      healthlake: {
        name: "HealthLake"
      },
      sagemakeredge: {
        prefix: "sagemaker-edge",
        name: "SagemakerEdge"
      },
      amp: {
        name: "Amp"
      },
      greengrassv2: {
        name: "GreengrassV2"
      },
      iotdeviceadvisor: {
        name: "IotDeviceAdvisor"
      },
      iotfleethub: {
        name: "IoTFleetHub"
      },
      iotwireless: {
        name: "IoTWireless"
      },
      location: {
        name: "Location",
        cors: true
      },
      wellarchitected: {
        name: "WellArchitected"
      },
      lexmodelsv2: {
        prefix: "models.lex.v2",
        name: "LexModelsV2"
      },
      lexruntimev2: {
        prefix: "runtime.lex.v2",
        name: "LexRuntimeV2",
        cors: true
      },
      fis: {
        name: "Fis"
      },
      lookoutmetrics: {
        name: "LookoutMetrics"
      },
      mgn: {
        name: "Mgn"
      },
      lookoutequipment: {
        name: "LookoutEquipment"
      },
      nimble: {
        name: "Nimble"
      },
      finspace: {
        name: "Finspace"
      },
      finspacedata: {
        prefix: "finspace-data",
        name: "Finspacedata"
      },
      ssmcontacts: {
        prefix: "ssm-contacts",
        name: "SSMContacts"
      },
      ssmincidents: {
        prefix: "ssm-incidents",
        name: "SSMIncidents"
      },
      applicationcostprofiler: {
        name: "ApplicationCostProfiler"
      },
      apprunner: {
        name: "AppRunner"
      },
      proton: {
        name: "Proton"
      },
      route53recoverycluster: {
        prefix: "route53-recovery-cluster",
        name: "Route53RecoveryCluster"
      },
      route53recoverycontrolconfig: {
        prefix: "route53-recovery-control-config",
        name: "Route53RecoveryControlConfig"
      },
      route53recoveryreadiness: {
        prefix: "route53-recovery-readiness",
        name: "Route53RecoveryReadiness"
      },
      chimesdkidentity: {
        prefix: "chime-sdk-identity",
        name: "ChimeSDKIdentity"
      },
      chimesdkmessaging: {
        prefix: "chime-sdk-messaging",
        name: "ChimeSDKMessaging"
      },
      snowdevicemanagement: {
        prefix: "snow-device-management",
        name: "SnowDeviceManagement"
      },
      memorydb: {
        name: "MemoryDB"
      },
      opensearch: {
        name: "OpenSearch"
      },
      kafkaconnect: {
        name: "KafkaConnect"
      },
      voiceid: {
        prefix: "voice-id",
        name: "VoiceID"
      },
      wisdom: {
        name: "Wisdom"
      },
      account: {
        name: "Account"
      },
      cloudcontrol: {
        name: "CloudControl"
      },
      grafana: {
        name: "Grafana"
      },
      panorama: {
        name: "Panorama"
      },
      chimesdkmeetings: {
        prefix: "chime-sdk-meetings",
        name: "ChimeSDKMeetings"
      },
      resiliencehub: {
        name: "Resiliencehub"
      },
      migrationhubstrategy: {
        name: "MigrationHubStrategy"
      },
      appconfigdata: {
        name: "AppConfigData"
      },
      drs: {
        name: "Drs"
      },
      migrationhubrefactorspaces: {
        prefix: "migration-hub-refactor-spaces",
        name: "MigrationHubRefactorSpaces"
      },
      evidently: {
        name: "Evidently"
      },
      inspector2: {
        name: "Inspector2"
      },
      rbin: {
        name: "Rbin"
      },
      rum: {
        name: "RUM"
      },
      backupgateway: {
        prefix: "backup-gateway",
        name: "BackupGateway"
      },
      iottwinmaker: {
        name: "IoTTwinMaker"
      },
      workspacesweb: {
        prefix: "workspaces-web",
        name: "WorkSpacesWeb"
      },
      amplifyuibuilder: {
        name: "AmplifyUIBuilder"
      },
      keyspaces: {
        name: "Keyspaces"
      },
      billingconductor: {
        name: "Billingconductor"
      },
      gamesparks: {
        name: "GameSparks"
      },
      pinpointsmsvoicev2: {
        prefix: "pinpoint-sms-voice-v2",
        name: "PinpointSMSVoiceV2"
      },
      ivschat: {
        name: "Ivschat"
      },
      chimesdkmediapipelines: {
        prefix: "chime-sdk-media-pipelines",
        name: "ChimeSDKMediaPipelines"
      }
    };
  }
});

// node_modules/aws-sdk/lib/model/api.js
var require_api = __commonJS({
  "node_modules/aws-sdk/lib/model/api.js"(exports, module2) {
    var Collection = require_collection();
    var Operation = require_operation();
    var Shape = require_shape();
    var Paginator = require_paginator();
    var ResourceWaiter = require_resource_waiter();
    var metadata = require_metadata();
    var util = require_util();
    var property = util.property;
    var memoizedProperty = util.memoizedProperty;
    function Api(api, options) {
      var self2 = this;
      api = api || {};
      options = options || {};
      options.api = this;
      api.metadata = api.metadata || {};
      var serviceIdentifier = options.serviceIdentifier;
      delete options.serviceIdentifier;
      property(this, "isApi", true, false);
      property(this, "apiVersion", api.metadata.apiVersion);
      property(this, "endpointPrefix", api.metadata.endpointPrefix);
      property(this, "signingName", api.metadata.signingName);
      property(this, "globalEndpoint", api.metadata.globalEndpoint);
      property(this, "signatureVersion", api.metadata.signatureVersion);
      property(this, "jsonVersion", api.metadata.jsonVersion);
      property(this, "targetPrefix", api.metadata.targetPrefix);
      property(this, "protocol", api.metadata.protocol);
      property(this, "timestampFormat", api.metadata.timestampFormat);
      property(this, "xmlNamespaceUri", api.metadata.xmlNamespace);
      property(this, "abbreviation", api.metadata.serviceAbbreviation);
      property(this, "fullName", api.metadata.serviceFullName);
      property(this, "serviceId", api.metadata.serviceId);
      if (serviceIdentifier && metadata[serviceIdentifier]) {
        property(this, "xmlNoDefaultLists", metadata[serviceIdentifier].xmlNoDefaultLists, false);
      }
      memoizedProperty(this, "className", function() {
        var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
        if (!name)
          return null;
        name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, "");
        if (name === "ElasticLoadBalancing")
          name = "ELB";
        return name;
      });
      function addEndpointOperation(name, operation) {
        if (operation.endpointoperation === true) {
          property(self2, "endpointOperation", util.string.lowerFirst(name));
        }
        if (operation.endpointdiscovery && !self2.hasRequiredEndpointDiscovery) {
          property(self2, "hasRequiredEndpointDiscovery", operation.endpointdiscovery.required === true);
        }
      }
      property(this, "operations", new Collection(api.operations, options, function(name, operation) {
        return new Operation(name, operation, options);
      }, util.string.lowerFirst, addEndpointOperation));
      property(this, "shapes", new Collection(api.shapes, options, function(name, shape) {
        return Shape.create(shape, options);
      }));
      property(this, "paginators", new Collection(api.paginators, options, function(name, paginator) {
        return new Paginator(name, paginator, options);
      }));
      property(this, "waiters", new Collection(api.waiters, options, function(name, waiter) {
        return new ResourceWaiter(name, waiter, options);
      }, util.string.lowerFirst));
      if (options.documentation) {
        property(this, "documentation", api.documentation);
        property(this, "documentationUrl", api.documentationUrl);
      }
    }
    module2.exports = Api;
  }
});

// node_modules/aws-sdk/lib/api_loader.js
var require_api_loader = __commonJS({
  "node_modules/aws-sdk/lib/api_loader.js"(exports, module2) {
    function apiLoader(svc, version2) {
      if (!apiLoader.services.hasOwnProperty(svc)) {
        throw new Error("InvalidService: Failed to load api for " + svc);
      }
      return apiLoader.services[svc][version2];
    }
    apiLoader.services = {};
    module2.exports = apiLoader;
  }
});

// node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js
var require_LRU = __commonJS({
  "node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LinkedListNode = function() {
      function LinkedListNode2(key, value) {
        this.key = key;
        this.value = value;
      }
      return LinkedListNode2;
    }();
    var LRUCache = function() {
      function LRUCache2(size) {
        this.nodeMap = {};
        this.size = 0;
        if (typeof size !== "number" || size < 1) {
          throw new Error("Cache size can only be positive number");
        }
        this.sizeLimit = size;
      }
      Object.defineProperty(LRUCache2.prototype, "length", {
        get: function() {
          return this.size;
        },
        enumerable: true,
        configurable: true
      });
      LRUCache2.prototype.prependToList = function(node) {
        if (!this.headerNode) {
          this.tailNode = node;
        } else {
          this.headerNode.prev = node;
          node.next = this.headerNode;
        }
        this.headerNode = node;
        this.size++;
      };
      LRUCache2.prototype.removeFromTail = function() {
        if (!this.tailNode) {
          return void 0;
        }
        var node = this.tailNode;
        var prevNode = node.prev;
        if (prevNode) {
          prevNode.next = void 0;
        }
        node.prev = void 0;
        this.tailNode = prevNode;
        this.size--;
        return node;
      };
      LRUCache2.prototype.detachFromList = function(node) {
        if (this.headerNode === node) {
          this.headerNode = node.next;
        }
        if (this.tailNode === node) {
          this.tailNode = node.prev;
        }
        if (node.prev) {
          node.prev.next = node.next;
        }
        if (node.next) {
          node.next.prev = node.prev;
        }
        node.next = void 0;
        node.prev = void 0;
        this.size--;
      };
      LRUCache2.prototype.get = function(key) {
        if (this.nodeMap[key]) {
          var node = this.nodeMap[key];
          this.detachFromList(node);
          this.prependToList(node);
          return node.value;
        }
      };
      LRUCache2.prototype.remove = function(key) {
        if (this.nodeMap[key]) {
          var node = this.nodeMap[key];
          this.detachFromList(node);
          delete this.nodeMap[key];
        }
      };
      LRUCache2.prototype.put = function(key, value) {
        if (this.nodeMap[key]) {
          this.remove(key);
        } else if (this.size === this.sizeLimit) {
          var tailNode = this.removeFromTail();
          var key_1 = tailNode.key;
          delete this.nodeMap[key_1];
        }
        var newNode = new LinkedListNode(key, value);
        this.nodeMap[key] = newNode;
        this.prependToList(newNode);
      };
      LRUCache2.prototype.empty = function() {
        var keys = Object.keys(this.nodeMap);
        for (var i2 = 0; i2 < keys.length; i2++) {
          var key = keys[i2];
          var node = this.nodeMap[key];
          this.detachFromList(node);
          delete this.nodeMap[key];
        }
      };
      return LRUCache2;
    }();
    exports.LRUCache = LRUCache;
  }
});

// node_modules/aws-sdk/vendor/endpoint-cache/index.js
var require_endpoint_cache = __commonJS({
  "node_modules/aws-sdk/vendor/endpoint-cache/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LRU_1 = require_LRU();
    var CACHE_SIZE = 1e3;
    var EndpointCache = function() {
      function EndpointCache2(maxSize) {
        if (maxSize === void 0) {
          maxSize = CACHE_SIZE;
        }
        this.maxSize = maxSize;
        this.cache = new LRU_1.LRUCache(maxSize);
      }
      ;
      Object.defineProperty(EndpointCache2.prototype, "size", {
        get: function() {
          return this.cache.length;
        },
        enumerable: true,
        configurable: true
      });
      EndpointCache2.prototype.put = function(key, value) {
        var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
        var endpointRecord = this.populateValue(value);
        this.cache.put(keyString, endpointRecord);
      };
      EndpointCache2.prototype.get = function(key) {
        var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
        var now = Date.now();
        var records = this.cache.get(keyString);
        if (records) {
          for (var i2 = records.length - 1; i2 >= 0; i2--) {
            var record = records[i2];
            if (record.Expire < now) {
              records.splice(i2, 1);
            }
          }
          if (records.length === 0) {
            this.cache.remove(keyString);
            return void 0;
          }
        }
        return records;
      };
      EndpointCache2.getKeyString = function(key) {
        var identifiers = [];
        var identifierNames = Object.keys(key).sort();
        for (var i2 = 0; i2 < identifierNames.length; i2++) {
          var identifierName = identifierNames[i2];
          if (key[identifierName] === void 0)
            continue;
          identifiers.push(key[identifierName]);
        }
        return identifiers.join(" ");
      };
      EndpointCache2.prototype.populateValue = function(endpoints) {
        var now = Date.now();
        return endpoints.map(function(endpoint) {
          return {
            Address: endpoint.Address || "",
            Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1e3
          };
        });
      };
      EndpointCache2.prototype.empty = function() {
        this.cache.empty();
      };
      EndpointCache2.prototype.remove = function(key) {
        var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
        this.cache.remove(keyString);
      };
      return EndpointCache2;
    }();
    exports.EndpointCache = EndpointCache;
  }
});

// node_modules/aws-sdk/lib/sequential_executor.js
var require_sequential_executor = __commonJS({
  "node_modules/aws-sdk/lib/sequential_executor.js"(exports, module2) {
    var AWS2 = require_core2();
    AWS2.SequentialExecutor = AWS2.util.inherit({
      constructor: function SequentialExecutor() {
        this._events = {};
      },
      listeners: function listeners(eventName) {
        return this._events[eventName] ? this._events[eventName].slice(0) : [];
      },
      on: function on(eventName, listener, toHead) {
        if (this._events[eventName]) {
          toHead ? this._events[eventName].unshift(listener) : this._events[eventName].push(listener);
        } else {
          this._events[eventName] = [listener];
        }
        return this;
      },
      onAsync: function onAsync(eventName, listener, toHead) {
        listener._isAsync = true;
        return this.on(eventName, listener, toHead);
      },
      removeListener: function removeListener(eventName, listener) {
        var listeners = this._events[eventName];
        if (listeners) {
          var length = listeners.length;
          var position = -1;
          for (var i2 = 0; i2 < length; ++i2) {
            if (listeners[i2] === listener) {
              position = i2;
            }
          }
          if (position > -1) {
            listeners.splice(position, 1);
          }
        }
        return this;
      },
      removeAllListeners: function removeAllListeners(eventName) {
        if (eventName) {
          delete this._events[eventName];
        } else {
          this._events = {};
        }
        return this;
      },
      emit: function emit(eventName, eventArgs, doneCallback) {
        if (!doneCallback)
          doneCallback = function() {
          };
        var listeners = this.listeners(eventName);
        var count = listeners.length;
        this.callListeners(listeners, eventArgs, doneCallback);
        return count > 0;
      },
      callListeners: function callListeners(listeners, args, doneCallback, prevError) {
        var self2 = this;
        var error2 = prevError || null;
        function callNextListener(err) {
          if (err) {
            error2 = AWS2.util.error(error2 || new Error(), err);
            if (self2._haltHandlersOnError) {
              return doneCallback.call(self2, error2);
            }
          }
          self2.callListeners(listeners, args, doneCallback, error2);
        }
        while (listeners.length > 0) {
          var listener = listeners.shift();
          if (listener._isAsync) {
            listener.apply(self2, args.concat([callNextListener]));
            return;
          } else {
            try {
              listener.apply(self2, args);
            } catch (err) {
              error2 = AWS2.util.error(error2 || new Error(), err);
            }
            if (error2 && self2._haltHandlersOnError) {
              doneCallback.call(self2, error2);
              return;
            }
          }
        }
        doneCallback.call(self2, error2);
      },
      addListeners: function addListeners(listeners) {
        var self2 = this;
        if (listeners._events)
          listeners = listeners._events;
        AWS2.util.each(listeners, function(event, callbacks) {
          if (typeof callbacks === "function")
            callbacks = [callbacks];
          AWS2.util.arrayEach(callbacks, function(callback) {
            self2.on(event, callback);
          });
        });
        return self2;
      },
      addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
        this[name] = callback;
        this.addListener(eventName, callback, toHead);
        return this;
      },
      addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {
        callback._isAsync = true;
        return this.addNamedListener(name, eventName, callback, toHead);
      },
      addNamedListeners: function addNamedListeners(callback) {
        var self2 = this;
        callback(function() {
          self2.addNamedListener.apply(self2, arguments);
        }, function() {
          self2.addNamedAsyncListener.apply(self2, arguments);
        });
        return this;
      }
    });
    AWS2.SequentialExecutor.prototype.addListener = AWS2.SequentialExecutor.prototype.on;
    module2.exports = AWS2.SequentialExecutor;
  }
});

// node_modules/aws-sdk/lib/region_config_data.json
var require_region_config_data = __commonJS({
  "node_modules/aws-sdk/lib/region_config_data.json"(exports, module2) {
    module2.exports = {
      rules: {
        "*/*": {
          endpoint: "{service}.{region}.amazonaws.com"
        },
        "cn-*/*": {
          endpoint: "{service}.{region}.amazonaws.com.cn"
        },
        "us-iso-*/*": "usIso",
        "us-isob-*/*": "usIsob",
        "*/budgets": "globalSSL",
        "*/cloudfront": "globalSSL",
        "*/sts": "globalSSL",
        "*/importexport": {
          endpoint: "{service}.amazonaws.com",
          signatureVersion: "v2",
          globalEndpoint: true
        },
        "*/route53": "globalSSL",
        "cn-*/route53": {
          endpoint: "{service}.amazonaws.com.cn",
          globalEndpoint: true,
          signingRegion: "cn-northwest-1"
        },
        "us-gov-*/route53": "globalGovCloud",
        "us-iso-*/route53": {
          endpoint: "{service}.c2s.ic.gov",
          globalEndpoint: true,
          signingRegion: "us-iso-east-1"
        },
        "us-isob-*/route53": {
          endpoint: "{service}.sc2s.sgov.gov",
          globalEndpoint: true,
          signingRegion: "us-isob-east-1"
        },
        "*/waf": "globalSSL",
        "*/iam": "globalSSL",
        "cn-*/iam": {
          endpoint: "{service}.cn-north-1.amazonaws.com.cn",
          globalEndpoint: true,
          signingRegion: "cn-north-1"
        },
        "us-gov-*/iam": "globalGovCloud",
        "us-gov-*/sts": {
          endpoint: "{service}.{region}.amazonaws.com"
        },
        "us-gov-west-1/s3": "s3signature",
        "us-west-1/s3": "s3signature",
        "us-west-2/s3": "s3signature",
        "eu-west-1/s3": "s3signature",
        "ap-southeast-1/s3": "s3signature",
        "ap-southeast-2/s3": "s3signature",
        "ap-northeast-1/s3": "s3signature",
        "sa-east-1/s3": "s3signature",
        "us-east-1/s3": {
          endpoint: "{service}.amazonaws.com",
          signatureVersion: "s3"
        },
        "us-east-1/sdb": {
          endpoint: "{service}.amazonaws.com",
          signatureVersion: "v2"
        },
        "*/sdb": {
          endpoint: "{service}.{region}.amazonaws.com",
          signatureVersion: "v2"
        }
      },
      fipsRules: {
        "*/*": "fipsStandard",
        "us-gov-*/*": "fipsStandard",
        "us-iso-*/*": {
          endpoint: "{service}-fips.{region}.c2s.ic.gov"
        },
        "us-iso-*/dms": "usIso",
        "us-isob-*/*": {
          endpoint: "{service}-fips.{region}.sc2s.sgov.gov"
        },
        "us-isob-*/dms": "usIsob",
        "cn-*/*": {
          endpoint: "{service}-fips.{region}.amazonaws.com.cn"
        },
        "*/api.ecr": "fips.api.ecr",
        "*/api.sagemaker": "fips.api.sagemaker",
        "*/batch": "fipsDotPrefix",
        "*/eks": "fipsDotPrefix",
        "*/models.lex": "fips.models.lex",
        "*/runtime.lex": "fips.runtime.lex",
        "*/runtime.sagemaker": {
          endpoint: "runtime-fips.sagemaker.{region}.amazonaws.com"
        },
        "*/iam": "fipsWithoutRegion",
        "*/route53": "fipsWithoutRegion",
        "*/transcribe": "fipsDotPrefix",
        "*/waf": "fipsWithoutRegion",
        "us-gov-*/transcribe": "fipsDotPrefix",
        "us-gov-*/api.ecr": "fips.api.ecr",
        "us-gov-*/api.sagemaker": "fips.api.sagemaker",
        "us-gov-*/models.lex": "fips.models.lex",
        "us-gov-*/runtime.lex": "fips.runtime.lex",
        "us-gov-*/acm-pca": "fipsWithServiceOnly",
        "us-gov-*/batch": "fipsWithServiceOnly",
        "us-gov-*/config": "fipsWithServiceOnly",
        "us-gov-*/eks": "fipsWithServiceOnly",
        "us-gov-*/elasticmapreduce": "fipsWithServiceOnly",
        "us-gov-*/identitystore": "fipsWithServiceOnly",
        "us-gov-*/dynamodb": "fipsWithServiceOnly",
        "us-gov-*/elasticloadbalancing": "fipsWithServiceOnly",
        "us-gov-*/guardduty": "fipsWithServiceOnly",
        "us-gov-*/monitoring": "fipsWithServiceOnly",
        "us-gov-*/resource-groups": "fipsWithServiceOnly",
        "us-gov-*/runtime.sagemaker": "fipsWithServiceOnly",
        "us-gov-*/servicecatalog-appregistry": "fipsWithServiceOnly",
        "us-gov-*/servicequotas": "fipsWithServiceOnly",
        "us-gov-*/ssm": "fipsWithServiceOnly",
        "us-gov-*/sts": "fipsWithServiceOnly",
        "us-gov-*/support": "fipsWithServiceOnly",
        "us-gov-west-1/states": "fipsWithServiceOnly",
        "us-iso-east-1/elasticfilesystem": {
          endpoint: "elasticfilesystem-fips.{region}.c2s.ic.gov"
        },
        "us-gov-west-1/organizations": "fipsWithServiceOnly",
        "us-gov-west-1/route53": {
          endpoint: "route53.us-gov.amazonaws.com"
        }
      },
      dualstackRules: {
        "*/*": {
          endpoint: "{service}.{region}.api.aws"
        },
        "cn-*/*": {
          endpoint: "{service}.{region}.api.amazonwebservices.com.cn"
        },
        "*/s3": "dualstackLegacy",
        "cn-*/s3": "dualstackLegacyCn",
        "*/s3-control": "dualstackLegacy",
        "cn-*/s3-control": "dualstackLegacyCn",
        "ap-south-1/ec2": "dualstackLegacyEc2",
        "eu-west-1/ec2": "dualstackLegacyEc2",
        "sa-east-1/ec2": "dualstackLegacyEc2",
        "us-east-1/ec2": "dualstackLegacyEc2",
        "us-east-2/ec2": "dualstackLegacyEc2",
        "us-west-2/ec2": "dualstackLegacyEc2"
      },
      dualstackFipsRules: {
        "*/*": {
          endpoint: "{service}-fips.{region}.api.aws"
        },
        "cn-*/*": {
          endpoint: "{service}-fips.{region}.api.amazonwebservices.com.cn"
        },
        "*/s3": "dualstackFipsLegacy",
        "cn-*/s3": "dualstackFipsLegacyCn",
        "*/s3-control": "dualstackFipsLegacy",
        "cn-*/s3-control": "dualstackFipsLegacyCn"
      },
      patterns: {
        globalSSL: {
          endpoint: "https://{service}.amazonaws.com",
          globalEndpoint: true,
          signingRegion: "us-east-1"
        },
        globalGovCloud: {
          endpoint: "{service}.us-gov.amazonaws.com",
          globalEndpoint: true,
          signingRegion: "us-gov-west-1"
        },
        s3signature: {
          endpoint: "{service}.{region}.amazonaws.com",
          signatureVersion: "s3"
        },
        usIso: {
          endpoint: "{service}.{region}.c2s.ic.gov"
        },
        usIsob: {
          endpoint: "{service}.{region}.sc2s.sgov.gov"
        },
        fipsStandard: {
          endpoint: "{service}-fips.{region}.amazonaws.com"
        },
        fipsDotPrefix: {
          endpoint: "fips.{service}.{region}.amazonaws.com"
        },
        fipsWithoutRegion: {
          endpoint: "{service}-fips.amazonaws.com"
        },
        "fips.api.ecr": {
          endpoint: "ecr-fips.{region}.amazonaws.com"
        },
        "fips.api.sagemaker": {
          endpoint: "api-fips.sagemaker.{region}.amazonaws.com"
        },
        "fips.models.lex": {
          endpoint: "models-fips.lex.{region}.amazonaws.com"
        },
        "fips.runtime.lex": {
          endpoint: "runtime-fips.lex.{region}.amazonaws.com"
        },
        fipsWithServiceOnly: {
          endpoint: "{service}.{region}.amazonaws.com"
        },
        dualstackLegacy: {
          endpoint: "{service}.dualstack.{region}.amazonaws.com"
        },
        dualstackLegacyCn: {
          endpoint: "{service}.dualstack.{region}.amazonaws.com.cn"
        },
        dualstackFipsLegacy: {
          endpoint: "{service}-fips.dualstack.{region}.amazonaws.com"
        },
        dualstackFipsLegacyCn: {
          endpoint: "{service}-fips.dualstack.{region}.amazonaws.com.cn"
        },
        dualstackLegacyEc2: {
          endpoint: "api.ec2.{region}.aws"
        }
      }
    };
  }
});

// node_modules/aws-sdk/lib/region_config.js
var require_region_config = __commonJS({
  "node_modules/aws-sdk/lib/region_config.js"(exports, module2) {
    var util = require_util();
    var regionConfig = require_region_config_data();
    function generateRegionPrefix(region) {
      if (!region)
        return null;
      var parts = region.split("-");
      if (parts.length < 3)
        return null;
      return parts.slice(0, parts.length - 2).join("-") + "-*";
    }
    function derivedKeys(service) {
      var region = service.config.region;
      var regionPrefix = generateRegionPrefix(region);
      var endpointPrefix = service.api.endpointPrefix;
      return [
        [region, endpointPrefix],
        [regionPrefix, endpointPrefix],
        [region, "*"],
        [regionPrefix, "*"],
        ["*", endpointPrefix],
        ["*", "*"]
      ].map(function(item) {
        return item[0] && item[1] ? item.join("/") : null;
      });
    }
    function applyConfig(service, config) {
      util.each(config, function(key, value) {
        if (key === "globalEndpoint")
          return;
        if (service.config[key] === void 0 || service.config[key] === null) {
          service.config[key] = value;
        }
      });
    }
    function configureEndpoint(service) {
      var keys = derivedKeys(service);
      var useFipsEndpoint = service.config.useFipsEndpoint;
      var useDualstackEndpoint = service.config.useDualstackEndpoint;
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        if (!key)
          continue;
        var rules = useFipsEndpoint ? useDualstackEndpoint ? regionConfig.dualstackFipsRules : regionConfig.fipsRules : useDualstackEndpoint ? regionConfig.dualstackRules : regionConfig.rules;
        if (Object.prototype.hasOwnProperty.call(rules, key)) {
          var config = rules[key];
          if (typeof config === "string") {
            config = regionConfig.patterns[config];
          }
          service.isGlobalEndpoint = !!config.globalEndpoint;
          if (config.signingRegion) {
            service.signingRegion = config.signingRegion;
          }
          if (!config.signatureVersion)
            config.signatureVersion = "v4";
          applyConfig(service, config);
          return;
        }
      }
    }
    function getEndpointSuffix(region) {
      var regionRegexes = {
        "^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$": "amazonaws.com",
        "^cn\\-\\w+\\-\\d+$": "amazonaws.com.cn",
        "^us\\-gov\\-\\w+\\-\\d+$": "amazonaws.com",
        "^us\\-iso\\-\\w+\\-\\d+$": "c2s.ic.gov",
        "^us\\-isob\\-\\w+\\-\\d+$": "sc2s.sgov.gov"
      };
      var defaultSuffix = "amazonaws.com";
      var regexes = Object.keys(regionRegexes);
      for (var i2 = 0; i2 < regexes.length; i2++) {
        var regionPattern = RegExp(regexes[i2]);
        var dnsSuffix = regionRegexes[regexes[i2]];
        if (regionPattern.test(region))
          return dnsSuffix;
      }
      return defaultSuffix;
    }
    module2.exports = {
      configureEndpoint,
      getEndpointSuffix
    };
  }
});

// node_modules/aws-sdk/lib/region/utils.js
var require_utils4 = __commonJS({
  "node_modules/aws-sdk/lib/region/utils.js"(exports, module2) {
    function isFipsRegion(region) {
      return typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
    }
    function isGlobalRegion(region) {
      return typeof region === "string" && ["aws-global", "aws-us-gov-global"].includes(region);
    }
    function getRealRegion(region) {
      return ["fips-aws-global", "aws-fips", "aws-global"].includes(region) ? "us-east-1" : ["fips-aws-us-gov-global", "aws-us-gov-global"].includes(region) ? "us-gov-west-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "");
    }
    module2.exports = {
      isFipsRegion,
      isGlobalRegion,
      getRealRegion
    };
  }
});

// node_modules/aws-sdk/lib/service.js
var require_service = __commonJS({
  "node_modules/aws-sdk/lib/service.js"(exports, module2) {
    var AWS2 = require_core2();
    var Api = require_api();
    var regionConfig = require_region_config();
    var inherit = AWS2.util.inherit;
    var clientCount = 0;
    var region_utils = require_utils4();
    AWS2.Service = inherit({
      constructor: function Service(config) {
        if (!this.loadServiceClass) {
          throw AWS2.util.error(new Error(), "Service must be constructed with `new' operator");
        }
        if (config) {
          if (config.region) {
            var region = config.region;
            if (region_utils.isFipsRegion(region)) {
              config.region = region_utils.getRealRegion(region);
              config.useFipsEndpoint = true;
            }
            if (region_utils.isGlobalRegion(region)) {
              config.region = region_utils.getRealRegion(region);
            }
          }
          if (typeof config.useDualstack === "boolean" && typeof config.useDualstackEndpoint !== "boolean") {
            config.useDualstackEndpoint = config.useDualstack;
          }
        }
        var ServiceClass = this.loadServiceClass(config || {});
        if (ServiceClass) {
          var originalConfig = AWS2.util.copy(config);
          var svc = new ServiceClass(config);
          Object.defineProperty(svc, "_originalConfig", {
            get: function() {
              return originalConfig;
            },
            enumerable: false,
            configurable: true
          });
          svc._clientId = ++clientCount;
          return svc;
        }
        this.initialize(config);
      },
      initialize: function initialize(config) {
        var svcConfig = AWS2.config[this.serviceIdentifier];
        this.config = new AWS2.Config(AWS2.config);
        if (svcConfig)
          this.config.update(svcConfig, true);
        if (config)
          this.config.update(config, true);
        this.validateService();
        if (!this.config.endpoint)
          regionConfig.configureEndpoint(this);
        this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
        this.setEndpoint(this.config.endpoint);
        AWS2.SequentialExecutor.call(this);
        AWS2.Service.addDefaultMonitoringListeners(this);
        if ((this.config.clientSideMonitoring || AWS2.Service._clientSideMonitoring) && this.publisher) {
          var publisher = this.publisher;
          this.addNamedListener("PUBLISH_API_CALL", "apiCall", function PUBLISH_API_CALL(event) {
            process.nextTick(function() {
              publisher.eventHandler(event);
            });
          });
          this.addNamedListener("PUBLISH_API_ATTEMPT", "apiCallAttempt", function PUBLISH_API_ATTEMPT(event) {
            process.nextTick(function() {
              publisher.eventHandler(event);
            });
          });
        }
      },
      validateService: function validateService() {
      },
      loadServiceClass: function loadServiceClass(serviceConfig) {
        var config = serviceConfig;
        if (!AWS2.util.isEmpty(this.api)) {
          return null;
        } else if (config.apiConfig) {
          return AWS2.Service.defineServiceApi(this.constructor, config.apiConfig);
        } else if (!this.constructor.services) {
          return null;
        } else {
          config = new AWS2.Config(AWS2.config);
          config.update(serviceConfig, true);
          var version2 = config.apiVersions[this.constructor.serviceIdentifier];
          version2 = version2 || config.apiVersion;
          return this.getLatestServiceClass(version2);
        }
      },
      getLatestServiceClass: function getLatestServiceClass(version2) {
        version2 = this.getLatestServiceVersion(version2);
        if (this.constructor.services[version2] === null) {
          AWS2.Service.defineServiceApi(this.constructor, version2);
        }
        return this.constructor.services[version2];
      },
      getLatestServiceVersion: function getLatestServiceVersion(version2) {
        if (!this.constructor.services || this.constructor.services.length === 0) {
          throw new Error("No services defined on " + this.constructor.serviceIdentifier);
        }
        if (!version2) {
          version2 = "latest";
        } else if (AWS2.util.isType(version2, Date)) {
          version2 = AWS2.util.date.iso8601(version2).split("T")[0];
        }
        if (Object.hasOwnProperty(this.constructor.services, version2)) {
          return version2;
        }
        var keys = Object.keys(this.constructor.services).sort();
        var selectedVersion = null;
        for (var i2 = keys.length - 1; i2 >= 0; i2--) {
          if (keys[i2][keys[i2].length - 1] !== "*") {
            selectedVersion = keys[i2];
          }
          if (keys[i2].substr(0, 10) <= version2) {
            return selectedVersion;
          }
        }
        throw new Error("Could not find " + this.constructor.serviceIdentifier + " API to satisfy version constraint `" + version2 + "'");
      },
      api: {},
      defaultRetryCount: 3,
      customizeRequests: function customizeRequests(callback) {
        if (!callback) {
          this.customRequestHandler = null;
        } else if (typeof callback === "function") {
          this.customRequestHandler = callback;
        } else {
          throw new Error("Invalid callback type '" + typeof callback + "' provided in customizeRequests");
        }
      },
      makeRequest: function makeRequest(operation, params, callback) {
        if (typeof params === "function") {
          callback = params;
          params = null;
        }
        params = params || {};
        if (this.config.params) {
          var rules = this.api.operations[operation];
          if (rules) {
            params = AWS2.util.copy(params);
            AWS2.util.each(this.config.params, function(key, value) {
              if (rules.input.members[key]) {
                if (params[key] === void 0 || params[key] === null) {
                  params[key] = value;
                }
              }
            });
          }
        }
        var request = new AWS2.Request(this, operation, params);
        this.addAllRequestListeners(request);
        this.attachMonitoringEmitter(request);
        if (callback)
          request.send(callback);
        return request;
      },
      makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
        if (typeof params === "function") {
          callback = params;
          params = {};
        }
        var request = this.makeRequest(operation, params).toUnauthenticated();
        return callback ? request.send(callback) : request;
      },
      waitFor: function waitFor(state, params, callback) {
        var waiter = new AWS2.ResourceWaiter(this, state);
        return waiter.wait(params, callback);
      },
      addAllRequestListeners: function addAllRequestListeners(request) {
        var list = [
          AWS2.events,
          AWS2.EventListeners.Core,
          this.serviceInterface(),
          AWS2.EventListeners.CorePost
        ];
        for (var i2 = 0; i2 < list.length; i2++) {
          if (list[i2])
            request.addListeners(list[i2]);
        }
        if (!this.config.paramValidation) {
          request.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_PARAMETERS);
        }
        if (this.config.logger) {
          request.addListeners(AWS2.EventListeners.Logger);
        }
        this.setupRequestListeners(request);
        if (typeof this.constructor.prototype.customRequestHandler === "function") {
          this.constructor.prototype.customRequestHandler(request);
        }
        if (Object.prototype.hasOwnProperty.call(this, "customRequestHandler") && typeof this.customRequestHandler === "function") {
          this.customRequestHandler(request);
        }
      },
      apiCallEvent: function apiCallEvent(request) {
        var api = request.service.api.operations[request.operation];
        var monitoringEvent = {
          Type: "ApiCall",
          Api: api ? api.name : request.operation,
          Version: 1,
          Service: request.service.api.serviceId || request.service.api.endpointPrefix,
          Region: request.httpRequest.region,
          MaxRetriesExceeded: 0,
          UserAgent: request.httpRequest.getUserAgent()
        };
        var response = request.response;
        if (response.httpResponse.statusCode) {
          monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
        }
        if (response.error) {
          var error2 = response.error;
          var statusCode = response.httpResponse.statusCode;
          if (statusCode > 299) {
            if (error2.code)
              monitoringEvent.FinalAwsException = error2.code;
            if (error2.message)
              monitoringEvent.FinalAwsExceptionMessage = error2.message;
          } else {
            if (error2.code || error2.name)
              monitoringEvent.FinalSdkException = error2.code || error2.name;
            if (error2.message)
              monitoringEvent.FinalSdkExceptionMessage = error2.message;
          }
        }
        return monitoringEvent;
      },
      apiAttemptEvent: function apiAttemptEvent(request) {
        var api = request.service.api.operations[request.operation];
        var monitoringEvent = {
          Type: "ApiCallAttempt",
          Api: api ? api.name : request.operation,
          Version: 1,
          Service: request.service.api.serviceId || request.service.api.endpointPrefix,
          Fqdn: request.httpRequest.endpoint.hostname,
          UserAgent: request.httpRequest.getUserAgent()
        };
        var response = request.response;
        if (response.httpResponse.statusCode) {
          monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
        }
        if (!request._unAuthenticated && request.service.config.credentials && request.service.config.credentials.accessKeyId) {
          monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
        }
        if (!response.httpResponse.headers)
          return monitoringEvent;
        if (request.httpRequest.headers["x-amz-security-token"]) {
          monitoringEvent.SessionToken = request.httpRequest.headers["x-amz-security-token"];
        }
        if (response.httpResponse.headers["x-amzn-requestid"]) {
          monitoringEvent.XAmznRequestId = response.httpResponse.headers["x-amzn-requestid"];
        }
        if (response.httpResponse.headers["x-amz-request-id"]) {
          monitoringEvent.XAmzRequestId = response.httpResponse.headers["x-amz-request-id"];
        }
        if (response.httpResponse.headers["x-amz-id-2"]) {
          monitoringEvent.XAmzId2 = response.httpResponse.headers["x-amz-id-2"];
        }
        return monitoringEvent;
      },
      attemptFailEvent: function attemptFailEvent(request) {
        var monitoringEvent = this.apiAttemptEvent(request);
        var response = request.response;
        var error2 = response.error;
        if (response.httpResponse.statusCode > 299) {
          if (error2.code)
            monitoringEvent.AwsException = error2.code;
          if (error2.message)
            monitoringEvent.AwsExceptionMessage = error2.message;
        } else {
          if (error2.code || error2.name)
            monitoringEvent.SdkException = error2.code || error2.name;
          if (error2.message)
            monitoringEvent.SdkExceptionMessage = error2.message;
        }
        return monitoringEvent;
      },
      attachMonitoringEmitter: function attachMonitoringEmitter(request) {
        var attemptTimestamp;
        var attemptStartRealTime;
        var attemptLatency;
        var callStartRealTime;
        var attemptCount = 0;
        var region;
        var callTimestamp;
        var self2 = this;
        var addToHead = true;
        request.on("validate", function() {
          callStartRealTime = AWS2.util.realClock.now();
          callTimestamp = Date.now();
        }, addToHead);
        request.on("sign", function() {
          attemptStartRealTime = AWS2.util.realClock.now();
          attemptTimestamp = Date.now();
          region = request.httpRequest.region;
          attemptCount++;
        }, addToHead);
        request.on("validateResponse", function() {
          attemptLatency = Math.round(AWS2.util.realClock.now() - attemptStartRealTime);
        });
        request.addNamedListener("API_CALL_ATTEMPT", "success", function API_CALL_ATTEMPT() {
          var apiAttemptEvent = self2.apiAttemptEvent(request);
          apiAttemptEvent.Timestamp = attemptTimestamp;
          apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
          apiAttemptEvent.Region = region;
          self2.emit("apiCallAttempt", [apiAttemptEvent]);
        });
        request.addNamedListener("API_CALL_ATTEMPT_RETRY", "retry", function API_CALL_ATTEMPT_RETRY() {
          var apiAttemptEvent = self2.attemptFailEvent(request);
          apiAttemptEvent.Timestamp = attemptTimestamp;
          attemptLatency = attemptLatency || Math.round(AWS2.util.realClock.now() - attemptStartRealTime);
          apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
          apiAttemptEvent.Region = region;
          self2.emit("apiCallAttempt", [apiAttemptEvent]);
        });
        request.addNamedListener("API_CALL", "complete", function API_CALL() {
          var apiCallEvent = self2.apiCallEvent(request);
          apiCallEvent.AttemptCount = attemptCount;
          if (apiCallEvent.AttemptCount <= 0)
            return;
          apiCallEvent.Timestamp = callTimestamp;
          var latency = Math.round(AWS2.util.realClock.now() - callStartRealTime);
          apiCallEvent.Latency = latency >= 0 ? latency : 0;
          var response = request.response;
          if (response.error && response.error.retryable && typeof response.retryCount === "number" && typeof response.maxRetries === "number" && response.retryCount >= response.maxRetries) {
            apiCallEvent.MaxRetriesExceeded = 1;
          }
          self2.emit("apiCall", [apiCallEvent]);
        });
      },
      setupRequestListeners: function setupRequestListeners(request) {
      },
      getSigningName: function getSigningName() {
        return this.api.signingName || this.api.endpointPrefix;
      },
      getSignerClass: function getSignerClass(request) {
        var version2;
        var operation = null;
        var authtype = "";
        if (request) {
          var operations = request.service.api.operations || {};
          operation = operations[request.operation] || null;
          authtype = operation ? operation.authtype : "";
        }
        if (this.config.signatureVersion) {
          version2 = this.config.signatureVersion;
        } else if (authtype === "v4" || authtype === "v4-unsigned-body") {
          version2 = "v4";
        } else {
          version2 = this.api.signatureVersion;
        }
        return AWS2.Signers.RequestSigner.getVersion(version2);
      },
      serviceInterface: function serviceInterface() {
        switch (this.api.protocol) {
          case "ec2":
            return AWS2.EventListeners.Query;
          case "query":
            return AWS2.EventListeners.Query;
          case "json":
            return AWS2.EventListeners.Json;
          case "rest-json":
            return AWS2.EventListeners.RestJson;
          case "rest-xml":
            return AWS2.EventListeners.RestXml;
        }
        if (this.api.protocol) {
          throw new Error("Invalid service `protocol' " + this.api.protocol + " in API config");
        }
      },
      successfulResponse: function successfulResponse(resp) {
        return resp.httpResponse.statusCode < 300;
      },
      numRetries: function numRetries() {
        if (this.config.maxRetries !== void 0) {
          return this.config.maxRetries;
        } else {
          return this.defaultRetryCount;
        }
      },
      retryDelays: function retryDelays(retryCount, err) {
        return AWS2.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
      },
      retryableError: function retryableError(error2) {
        if (this.timeoutError(error2))
          return true;
        if (this.networkingError(error2))
          return true;
        if (this.expiredCredentialsError(error2))
          return true;
        if (this.throttledError(error2))
          return true;
        if (error2.statusCode >= 500)
          return true;
        return false;
      },
      networkingError: function networkingError(error2) {
        return error2.code === "NetworkingError";
      },
      timeoutError: function timeoutError(error2) {
        return error2.code === "TimeoutError";
      },
      expiredCredentialsError: function expiredCredentialsError(error2) {
        return error2.code === "ExpiredTokenException";
      },
      clockSkewError: function clockSkewError(error2) {
        switch (error2.code) {
          case "RequestTimeTooSkewed":
          case "RequestExpired":
          case "InvalidSignatureException":
          case "SignatureDoesNotMatch":
          case "AuthFailure":
          case "RequestInTheFuture":
            return true;
          default:
            return false;
        }
      },
      getSkewCorrectedDate: function getSkewCorrectedDate() {
        return new Date(Date.now() + this.config.systemClockOffset);
      },
      applyClockOffset: function applyClockOffset(newServerTime) {
        if (newServerTime) {
          this.config.systemClockOffset = newServerTime - Date.now();
        }
      },
      isClockSkewed: function isClockSkewed(newServerTime) {
        if (newServerTime) {
          return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 3e5;
        }
      },
      throttledError: function throttledError(error2) {
        if (error2.statusCode === 429)
          return true;
        switch (error2.code) {
          case "ProvisionedThroughputExceededException":
          case "Throttling":
          case "ThrottlingException":
          case "RequestLimitExceeded":
          case "RequestThrottled":
          case "RequestThrottledException":
          case "TooManyRequestsException":
          case "TransactionInProgressException":
          case "EC2ThrottledException":
            return true;
          default:
            return false;
        }
      },
      endpointFromTemplate: function endpointFromTemplate(endpoint) {
        if (typeof endpoint !== "string")
          return endpoint;
        var e2 = endpoint;
        e2 = e2.replace(/\{service\}/g, this.api.endpointPrefix);
        e2 = e2.replace(/\{region\}/g, this.config.region);
        e2 = e2.replace(/\{scheme\}/g, this.config.sslEnabled ? "https" : "http");
        return e2;
      },
      setEndpoint: function setEndpoint(endpoint) {
        this.endpoint = new AWS2.Endpoint(endpoint, this.config);
      },
      paginationConfig: function paginationConfig(operation, throwException) {
        var paginator = this.api.operations[operation].paginator;
        if (!paginator) {
          if (throwException) {
            var e2 = new Error();
            throw AWS2.util.error(e2, "No pagination configuration for " + operation);
          }
          return null;
        }
        return paginator;
      }
    });
    AWS2.util.update(AWS2.Service, {
      defineMethods: function defineMethods(svc) {
        AWS2.util.each(svc.prototype.api.operations, function iterator(method) {
          if (svc.prototype[method])
            return;
          var operation = svc.prototype.api.operations[method];
          if (operation.authtype === "none") {
            svc.prototype[method] = function(params, callback) {
              return this.makeUnauthenticatedRequest(method, params, callback);
            };
          } else {
            svc.prototype[method] = function(params, callback) {
              return this.makeRequest(method, params, callback);
            };
          }
        });
      },
      defineService: function defineService(serviceIdentifier, versions, features) {
        AWS2.Service._serviceMap[serviceIdentifier] = true;
        if (!Array.isArray(versions)) {
          features = versions;
          versions = [];
        }
        var svc = inherit(AWS2.Service, features || {});
        if (typeof serviceIdentifier === "string") {
          AWS2.Service.addVersions(svc, versions);
          var identifier = svc.serviceIdentifier || serviceIdentifier;
          svc.serviceIdentifier = identifier;
        } else {
          svc.prototype.api = serviceIdentifier;
          AWS2.Service.defineMethods(svc);
        }
        AWS2.SequentialExecutor.call(this.prototype);
        if (!this.prototype.publisher && AWS2.util.clientSideMonitoring) {
          var Publisher = AWS2.util.clientSideMonitoring.Publisher;
          var configProvider = AWS2.util.clientSideMonitoring.configProvider;
          var publisherConfig = configProvider();
          this.prototype.publisher = new Publisher(publisherConfig);
          if (publisherConfig.enabled) {
            AWS2.Service._clientSideMonitoring = true;
          }
        }
        AWS2.SequentialExecutor.call(svc.prototype);
        AWS2.Service.addDefaultMonitoringListeners(svc.prototype);
        return svc;
      },
      addVersions: function addVersions(svc, versions) {
        if (!Array.isArray(versions))
          versions = [versions];
        svc.services = svc.services || {};
        for (var i2 = 0; i2 < versions.length; i2++) {
          if (svc.services[versions[i2]] === void 0) {
            svc.services[versions[i2]] = null;
          }
        }
        svc.apiVersions = Object.keys(svc.services).sort();
      },
      defineServiceApi: function defineServiceApi(superclass, version2, apiConfig) {
        var svc = inherit(superclass, {
          serviceIdentifier: superclass.serviceIdentifier
        });
        function setApi(api) {
          if (api.isApi) {
            svc.prototype.api = api;
          } else {
            svc.prototype.api = new Api(api, {
              serviceIdentifier: superclass.serviceIdentifier
            });
          }
        }
        if (typeof version2 === "string") {
          if (apiConfig) {
            setApi(apiConfig);
          } else {
            try {
              setApi(AWS2.apiLoader(superclass.serviceIdentifier, version2));
            } catch (err) {
              throw AWS2.util.error(err, {
                message: "Could not find API configuration " + superclass.serviceIdentifier + "-" + version2
              });
            }
          }
          if (!Object.prototype.hasOwnProperty.call(superclass.services, version2)) {
            superclass.apiVersions = superclass.apiVersions.concat(version2).sort();
          }
          superclass.services[version2] = svc;
        } else {
          setApi(version2);
        }
        AWS2.Service.defineMethods(svc);
        return svc;
      },
      hasService: function(identifier) {
        return Object.prototype.hasOwnProperty.call(AWS2.Service._serviceMap, identifier);
      },
      addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
        attachOn.addNamedListener("MONITOR_EVENTS_BUBBLE", "apiCallAttempt", function EVENTS_BUBBLE(event) {
          var baseClass = Object.getPrototypeOf(attachOn);
          if (baseClass._events)
            baseClass.emit("apiCallAttempt", [event]);
        });
        attachOn.addNamedListener("CALL_EVENTS_BUBBLE", "apiCall", function CALL_EVENTS_BUBBLE(event) {
          var baseClass = Object.getPrototypeOf(attachOn);
          if (baseClass._events)
            baseClass.emit("apiCall", [event]);
        });
      },
      _serviceMap: {}
    });
    AWS2.util.mixin(AWS2.Service, AWS2.SequentialExecutor);
    module2.exports = AWS2.Service;
  }
});

// node_modules/aws-sdk/lib/credentials.js
var require_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials.js"() {
    var AWS2 = require_core2();
    AWS2.Credentials = AWS2.util.inherit({
      constructor: function Credentials() {
        AWS2.util.hideProperties(this, ["secretAccessKey"]);
        this.expired = false;
        this.expireTime = null;
        this.refreshCallbacks = [];
        if (arguments.length === 1 && typeof arguments[0] === "object") {
          var creds = arguments[0].credentials || arguments[0];
          this.accessKeyId = creds.accessKeyId;
          this.secretAccessKey = creds.secretAccessKey;
          this.sessionToken = creds.sessionToken;
        } else {
          this.accessKeyId = arguments[0];
          this.secretAccessKey = arguments[1];
          this.sessionToken = arguments[2];
        }
      },
      expiryWindow: 15,
      needsRefresh: function needsRefresh() {
        var currentTime = AWS2.util.date.getDate().getTime();
        var adjustedTime = new Date(currentTime + this.expiryWindow * 1e3);
        if (this.expireTime && adjustedTime > this.expireTime) {
          return true;
        } else {
          return this.expired || !this.accessKeyId || !this.secretAccessKey;
        }
      },
      get: function get(callback) {
        var self2 = this;
        if (this.needsRefresh()) {
          this.refresh(function(err) {
            if (!err)
              self2.expired = false;
            if (callback)
              callback(err);
          });
        } else if (callback) {
          callback();
        }
      },
      refresh: function refresh(callback) {
        this.expired = false;
        callback();
      },
      coalesceRefresh: function coalesceRefresh(callback, sync) {
        var self2 = this;
        if (self2.refreshCallbacks.push(callback) === 1) {
          self2.load(function onLoad(err) {
            AWS2.util.arrayEach(self2.refreshCallbacks, function(callback2) {
              if (sync) {
                callback2(err);
              } else {
                AWS2.util.defer(function() {
                  callback2(err);
                });
              }
            });
            self2.refreshCallbacks.length = 0;
          });
        }
      },
      load: function load(callback) {
        callback();
      }
    });
    AWS2.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.getPromise = AWS2.util.promisifyMethod("get", PromiseDependency);
      this.prototype.refreshPromise = AWS2.util.promisifyMethod("refresh", PromiseDependency);
    };
    AWS2.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.getPromise;
      delete this.prototype.refreshPromise;
    };
    AWS2.util.addPromises(AWS2.Credentials);
  }
});

// node_modules/aws-sdk/lib/credentials/credential_provider_chain.js
var require_credential_provider_chain = __commonJS({
  "node_modules/aws-sdk/lib/credentials/credential_provider_chain.js"() {
    var AWS2 = require_core2();
    AWS2.CredentialProviderChain = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function CredentialProviderChain(providers) {
        if (providers) {
          this.providers = providers;
        } else {
          this.providers = AWS2.CredentialProviderChain.defaultProviders.slice(0);
        }
        this.resolveCallbacks = [];
      },
      resolve: function resolve2(callback) {
        var self2 = this;
        if (self2.providers.length === 0) {
          callback(new Error("No providers"));
          return self2;
        }
        if (self2.resolveCallbacks.push(callback) === 1) {
          let resolveNext2 = function(err, creds) {
            if (!err && creds || index === providers.length) {
              AWS2.util.arrayEach(self2.resolveCallbacks, function(callback2) {
                callback2(err, creds);
              });
              self2.resolveCallbacks.length = 0;
              return;
            }
            var provider = providers[index++];
            if (typeof provider === "function") {
              creds = provider.call();
            } else {
              creds = provider;
            }
            if (creds.get) {
              creds.get(function(getErr) {
                resolveNext2(getErr, getErr ? null : creds);
              });
            } else {
              resolveNext2(null, creds);
            }
          };
          var resolveNext = resolveNext2;
          var index = 0;
          var providers = self2.providers.slice(0);
          resolveNext2();
        }
        return self2;
      }
    });
    AWS2.CredentialProviderChain.defaultProviders = [];
    AWS2.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.resolvePromise = AWS2.util.promisifyMethod("resolve", PromiseDependency);
    };
    AWS2.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.resolvePromise;
    };
    AWS2.util.addPromises(AWS2.CredentialProviderChain);
  }
});

// node_modules/aws-sdk/lib/config.js
var require_config = __commonJS({
  "node_modules/aws-sdk/lib/config.js"() {
    var AWS2 = require_core2();
    require_credentials();
    require_credential_provider_chain();
    var PromisesDependency;
    AWS2.Config = AWS2.util.inherit({
      constructor: function Config(options) {
        if (options === void 0)
          options = {};
        options = this.extractCredentials(options);
        AWS2.util.each.call(this, this.keys, function(key, value) {
          this.set(key, options[key], value);
        });
      },
      getCredentials: function getCredentials(callback) {
        var self2 = this;
        function finish(err) {
          callback(err, err ? null : self2.credentials);
        }
        function credError(msg, err) {
          return new AWS2.util.error(err || new Error(), {
            code: "CredentialsError",
            message: msg,
            name: "CredentialsError"
          });
        }
        function getAsyncCredentials() {
          self2.credentials.get(function(err) {
            if (err) {
              var msg = "Could not load credentials from " + self2.credentials.constructor.name;
              err = credError(msg, err);
            }
            finish(err);
          });
        }
        function getStaticCredentials() {
          var err = null;
          if (!self2.credentials.accessKeyId || !self2.credentials.secretAccessKey) {
            err = credError("Missing credentials");
          }
          finish(err);
        }
        if (self2.credentials) {
          if (typeof self2.credentials.get === "function") {
            getAsyncCredentials();
          } else {
            getStaticCredentials();
          }
        } else if (self2.credentialProvider) {
          self2.credentialProvider.resolve(function(err, creds) {
            if (err) {
              err = credError("Could not load credentials from any providers", err);
            }
            self2.credentials = creds;
            finish(err);
          });
        } else {
          finish(credError("No credentials to load"));
        }
      },
      update: function update(options, allowUnknownKeys) {
        allowUnknownKeys = allowUnknownKeys || false;
        options = this.extractCredentials(options);
        AWS2.util.each.call(this, options, function(key, value) {
          if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) || AWS2.Service.hasService(key)) {
            this.set(key, value);
          }
        });
      },
      loadFromPath: function loadFromPath(path8) {
        this.clear();
        var options = JSON.parse(AWS2.util.readFileSync(path8));
        var fileSystemCreds = new AWS2.FileSystemCredentials(path8);
        var chain = new AWS2.CredentialProviderChain();
        chain.providers.unshift(fileSystemCreds);
        chain.resolve(function(err, creds) {
          if (err)
            throw err;
          else
            options.credentials = creds;
        });
        this.constructor(options);
        return this;
      },
      clear: function clear() {
        AWS2.util.each.call(this, this.keys, function(key) {
          delete this[key];
        });
        this.set("credentials", void 0);
        this.set("credentialProvider", void 0);
      },
      set: function set(property, value, defaultValue) {
        if (value === void 0) {
          if (defaultValue === void 0) {
            defaultValue = this.keys[property];
          }
          if (typeof defaultValue === "function") {
            this[property] = defaultValue.call(this);
          } else {
            this[property] = defaultValue;
          }
        } else if (property === "httpOptions" && this[property]) {
          this[property] = AWS2.util.merge(this[property], value);
        } else {
          this[property] = value;
        }
      },
      keys: {
        credentials: null,
        credentialProvider: null,
        region: null,
        logger: null,
        apiVersions: {},
        apiVersion: null,
        endpoint: void 0,
        httpOptions: {
          timeout: 12e4
        },
        maxRetries: void 0,
        maxRedirects: 10,
        paramValidation: true,
        sslEnabled: true,
        s3ForcePathStyle: false,
        s3BucketEndpoint: false,
        s3DisableBodySigning: true,
        s3UsEast1RegionalEndpoint: "legacy",
        s3UseArnRegion: void 0,
        computeChecksums: true,
        convertResponseTypes: true,
        correctClockSkew: false,
        customUserAgent: null,
        dynamoDbCrc32: true,
        systemClockOffset: 0,
        signatureVersion: null,
        signatureCache: true,
        retryDelayOptions: {},
        useAccelerateEndpoint: false,
        clientSideMonitoring: false,
        endpointDiscoveryEnabled: void 0,
        endpointCacheSize: 1e3,
        hostPrefixEnabled: true,
        stsRegionalEndpoints: "legacy",
        useFipsEndpoint: false,
        useDualstackEndpoint: false
      },
      extractCredentials: function extractCredentials(options) {
        if (options.accessKeyId && options.secretAccessKey) {
          options = AWS2.util.copy(options);
          options.credentials = new AWS2.Credentials(options);
        }
        return options;
      },
      setPromisesDependency: function setPromisesDependency(dep) {
        PromisesDependency = dep;
        if (dep === null && typeof Promise === "function") {
          PromisesDependency = Promise;
        }
        var constructors = [AWS2.Request, AWS2.Credentials, AWS2.CredentialProviderChain];
        if (AWS2.S3) {
          constructors.push(AWS2.S3);
          if (AWS2.S3.ManagedUpload) {
            constructors.push(AWS2.S3.ManagedUpload);
          }
        }
        AWS2.util.addPromises(constructors, PromisesDependency);
      },
      getPromisesDependency: function getPromisesDependency() {
        return PromisesDependency;
      }
    });
    AWS2.config = new AWS2.Config();
  }
});

// node_modules/aws-sdk/lib/http.js
var require_http = __commonJS({
  "node_modules/aws-sdk/lib/http.js"() {
    var AWS2 = require_core2();
    var inherit = AWS2.util.inherit;
    AWS2.Endpoint = inherit({
      constructor: function Endpoint(endpoint, config) {
        AWS2.util.hideProperties(this, ["slashes", "auth", "hash", "search", "query"]);
        if (typeof endpoint === "undefined" || endpoint === null) {
          throw new Error("Invalid endpoint: " + endpoint);
        } else if (typeof endpoint !== "string") {
          return AWS2.util.copy(endpoint);
        }
        if (!endpoint.match(/^http/)) {
          var useSSL = config && config.sslEnabled !== void 0 ? config.sslEnabled : AWS2.config.sslEnabled;
          endpoint = (useSSL ? "https" : "http") + "://" + endpoint;
        }
        AWS2.util.update(this, AWS2.util.urlParse(endpoint));
        if (this.port) {
          this.port = parseInt(this.port, 10);
        } else {
          this.port = this.protocol === "https:" ? 443 : 80;
        }
      }
    });
    AWS2.HttpRequest = inherit({
      constructor: function HttpRequest(endpoint, region) {
        endpoint = new AWS2.Endpoint(endpoint);
        this.method = "POST";
        this.path = endpoint.path || "/";
        this.headers = {};
        this.body = "";
        this.endpoint = endpoint;
        this.region = region;
        this._userAgent = "";
        this.setUserAgent();
      },
      setUserAgent: function setUserAgent() {
        this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS2.util.userAgent();
      },
      getUserAgentHeaderName: function getUserAgentHeaderName() {
        var prefix = AWS2.util.isBrowser() ? "X-Amz-" : "";
        return prefix + "User-Agent";
      },
      appendToUserAgent: function appendToUserAgent(agentPartial) {
        if (typeof agentPartial === "string" && agentPartial) {
          this._userAgent += " " + agentPartial;
        }
        this.headers[this.getUserAgentHeaderName()] = this._userAgent;
      },
      getUserAgent: function getUserAgent() {
        return this._userAgent;
      },
      pathname: function pathname() {
        return this.path.split("?", 1)[0];
      },
      search: function search() {
        var query = this.path.split("?", 2)[1];
        if (query) {
          query = AWS2.util.queryStringParse(query);
          return AWS2.util.queryParamsToString(query);
        }
        return "";
      },
      updateEndpoint: function updateEndpoint(endpointStr) {
        var newEndpoint = new AWS2.Endpoint(endpointStr);
        this.endpoint = newEndpoint;
        this.path = newEndpoint.path || "/";
        if (this.headers["Host"]) {
          this.headers["Host"] = newEndpoint.host;
        }
      }
    });
    AWS2.HttpResponse = inherit({
      constructor: function HttpResponse() {
        this.statusCode = void 0;
        this.headers = {};
        this.body = void 0;
        this.streaming = false;
        this.stream = null;
      },
      createUnbufferedStream: function createUnbufferedStream() {
        this.streaming = true;
        return this.stream;
      }
    });
    AWS2.HttpClient = inherit({});
    AWS2.HttpClient.getInstance = function getInstance() {
      if (this.singleton === void 0) {
        this.singleton = new this();
      }
      return this.singleton;
    };
  }
});

// node_modules/aws-sdk/lib/discover_endpoint.js
var require_discover_endpoint = __commonJS({
  "node_modules/aws-sdk/lib/discover_endpoint.js"(exports, module2) {
    var AWS2 = require_core2();
    var util = require_util();
    var endpointDiscoveryEnabledEnvs = ["AWS_ENABLE_ENDPOINT_DISCOVERY", "AWS_ENDPOINT_DISCOVERY_ENABLED"];
    function getCacheKey(request) {
      var service = request.service;
      var api = service.api || {};
      var operations = api.operations;
      var identifiers = {};
      if (service.config.region) {
        identifiers.region = service.config.region;
      }
      if (api.serviceId) {
        identifiers.serviceId = api.serviceId;
      }
      if (service.config.credentials.accessKeyId) {
        identifiers.accessKeyId = service.config.credentials.accessKeyId;
      }
      return identifiers;
    }
    function marshallCustomIdentifiersHelper(result, params, shape) {
      if (!shape || params === void 0 || params === null)
        return;
      if (shape.type === "structure" && shape.required && shape.required.length > 0) {
        util.arrayEach(shape.required, function(name) {
          var memberShape = shape.members[name];
          if (memberShape.endpointDiscoveryId === true) {
            var locationName = memberShape.isLocationName ? memberShape.name : name;
            result[locationName] = String(params[name]);
          } else {
            marshallCustomIdentifiersHelper(result, params[name], memberShape);
          }
        });
      }
    }
    function marshallCustomIdentifiers(request, shape) {
      var identifiers = {};
      marshallCustomIdentifiersHelper(identifiers, request.params, shape);
      return identifiers;
    }
    function optionalDiscoverEndpoint(request) {
      var service = request.service;
      var api = service.api;
      var operationModel = api.operations ? api.operations[request.operation] : void 0;
      var inputShape = operationModel ? operationModel.input : void 0;
      var identifiers = marshallCustomIdentifiers(request, inputShape);
      var cacheKey = getCacheKey(request);
      if (Object.keys(identifiers).length > 0) {
        cacheKey = util.update(cacheKey, identifiers);
        if (operationModel)
          cacheKey.operation = operationModel.name;
      }
      var endpoints = AWS2.endpointCache.get(cacheKey);
      if (endpoints && endpoints.length === 1 && endpoints[0].Address === "") {
        return;
      } else if (endpoints && endpoints.length > 0) {
        request.httpRequest.updateEndpoint(endpoints[0].Address);
      } else {
        var endpointRequest = service.makeRequest(api.endpointOperation, {
          Operation: operationModel.name,
          Identifiers: identifiers
        });
        addApiVersionHeader(endpointRequest);
        endpointRequest.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_PARAMETERS);
        endpointRequest.removeListener("retry", AWS2.EventListeners.Core.RETRY_CHECK);
        AWS2.endpointCache.put(cacheKey, [{
          Address: "",
          CachePeriodInMinutes: 1
        }]);
        endpointRequest.send(function(err, data) {
          if (data && data.Endpoints) {
            AWS2.endpointCache.put(cacheKey, data.Endpoints);
          } else if (err) {
            AWS2.endpointCache.put(cacheKey, [{
              Address: "",
              CachePeriodInMinutes: 1
            }]);
          }
        });
      }
    }
    var requestQueue = {};
    function requiredDiscoverEndpoint(request, done) {
      var service = request.service;
      var api = service.api;
      var operationModel = api.operations ? api.operations[request.operation] : void 0;
      var inputShape = operationModel ? operationModel.input : void 0;
      var identifiers = marshallCustomIdentifiers(request, inputShape);
      var cacheKey = getCacheKey(request);
      if (Object.keys(identifiers).length > 0) {
        cacheKey = util.update(cacheKey, identifiers);
        if (operationModel)
          cacheKey.operation = operationModel.name;
      }
      var cacheKeyStr = AWS2.EndpointCache.getKeyString(cacheKey);
      var endpoints = AWS2.endpointCache.get(cacheKeyStr);
      if (endpoints && endpoints.length === 1 && endpoints[0].Address === "") {
        if (!requestQueue[cacheKeyStr])
          requestQueue[cacheKeyStr] = [];
        requestQueue[cacheKeyStr].push({ request, callback: done });
        return;
      } else if (endpoints && endpoints.length > 0) {
        request.httpRequest.updateEndpoint(endpoints[0].Address);
        done();
      } else {
        var endpointRequest = service.makeRequest(api.endpointOperation, {
          Operation: operationModel.name,
          Identifiers: identifiers
        });
        endpointRequest.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_PARAMETERS);
        addApiVersionHeader(endpointRequest);
        AWS2.endpointCache.put(cacheKeyStr, [{
          Address: "",
          CachePeriodInMinutes: 60
        }]);
        endpointRequest.send(function(err, data) {
          if (err) {
            request.response.error = util.error(err, { retryable: false });
            AWS2.endpointCache.remove(cacheKey);
            if (requestQueue[cacheKeyStr]) {
              var pendingRequests = requestQueue[cacheKeyStr];
              util.arrayEach(pendingRequests, function(requestContext) {
                requestContext.request.response.error = util.error(err, { retryable: false });
                requestContext.callback();
              });
              delete requestQueue[cacheKeyStr];
            }
          } else if (data) {
            AWS2.endpointCache.put(cacheKeyStr, data.Endpoints);
            request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
            if (requestQueue[cacheKeyStr]) {
              var pendingRequests = requestQueue[cacheKeyStr];
              util.arrayEach(pendingRequests, function(requestContext) {
                requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
                requestContext.callback();
              });
              delete requestQueue[cacheKeyStr];
            }
          }
          done();
        });
      }
    }
    function addApiVersionHeader(endpointRequest) {
      var api = endpointRequest.service.api;
      var apiVersion = api.apiVersion;
      if (apiVersion && !endpointRequest.httpRequest.headers["x-amz-api-version"]) {
        endpointRequest.httpRequest.headers["x-amz-api-version"] = apiVersion;
      }
    }
    function invalidateCachedEndpoints(response) {
      var error2 = response.error;
      var httpResponse = response.httpResponse;
      if (error2 && (error2.code === "InvalidEndpointException" || httpResponse.statusCode === 421)) {
        var request = response.request;
        var operations = request.service.api.operations || {};
        var inputShape = operations[request.operation] ? operations[request.operation].input : void 0;
        var identifiers = marshallCustomIdentifiers(request, inputShape);
        var cacheKey = getCacheKey(request);
        if (Object.keys(identifiers).length > 0) {
          cacheKey = util.update(cacheKey, identifiers);
          if (operations[request.operation])
            cacheKey.operation = operations[request.operation].name;
        }
        AWS2.endpointCache.remove(cacheKey);
      }
    }
    function hasCustomEndpoint(client) {
      if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {
        throw util.error(new Error(), {
          code: "ConfigurationException",
          message: "Custom endpoint is supplied; endpointDiscoveryEnabled must not be true."
        });
      }
      ;
      var svcConfig = AWS2.config[client.serviceIdentifier] || {};
      return Boolean(AWS2.config.endpoint || svcConfig.endpoint || client._originalConfig && client._originalConfig.endpoint);
    }
    function isFalsy(value) {
      return ["false", "0"].indexOf(value) >= 0;
    }
    function resolveEndpointDiscoveryConfig(request) {
      var service = request.service || {};
      if (service.config.endpointDiscoveryEnabled !== void 0) {
        return service.config.endpointDiscoveryEnabled;
      }
      if (util.isBrowser())
        return void 0;
      for (var i2 = 0; i2 < endpointDiscoveryEnabledEnvs.length; i2++) {
        var env = endpointDiscoveryEnabledEnvs[i2];
        if (Object.prototype.hasOwnProperty.call(process.env, env)) {
          if (process.env[env] === "" || process.env[env] === void 0) {
            throw util.error(new Error(), {
              code: "ConfigurationException",
              message: "environmental variable " + env + " cannot be set to nothing"
            });
          }
          return !isFalsy(process.env[env]);
        }
      }
      var configFile = {};
      try {
        configFile = AWS2.util.iniLoader ? AWS2.util.iniLoader.loadFrom({
          isConfig: true,
          filename: process.env[AWS2.util.sharedConfigFileEnv]
        }) : {};
      } catch (e2) {
      }
      var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS2.util.defaultProfile] || {};
      if (Object.prototype.hasOwnProperty.call(sharedFileConfig, "endpoint_discovery_enabled")) {
        if (sharedFileConfig.endpoint_discovery_enabled === void 0) {
          throw util.error(new Error(), {
            code: "ConfigurationException",
            message: "config file entry 'endpoint_discovery_enabled' cannot be set to nothing"
          });
        }
        return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);
      }
      return void 0;
    }
    function discoverEndpoint(request, done) {
      var service = request.service || {};
      if (hasCustomEndpoint(service) || request.isPresigned())
        return done();
      var operations = service.api.operations || {};
      var operationModel = operations[request.operation];
      var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : "NULL";
      var isEnabled = resolveEndpointDiscoveryConfig(request);
      var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;
      if (isEnabled || hasRequiredEndpointDiscovery) {
        request.httpRequest.appendToUserAgent("endpoint-discovery");
      }
      switch (isEndpointDiscoveryRequired) {
        case "OPTIONAL":
          if (isEnabled || hasRequiredEndpointDiscovery) {
            optionalDiscoverEndpoint(request);
            request.addNamedListener("INVALIDATE_CACHED_ENDPOINTS", "extractError", invalidateCachedEndpoints);
          }
          done();
          break;
        case "REQUIRED":
          if (isEnabled === false) {
            request.response.error = util.error(new Error(), {
              code: "ConfigurationException",
              message: "Endpoint Discovery is disabled but " + service.api.className + "." + request.operation + "() requires it. Please check your configurations."
            });
            done();
            break;
          }
          request.addNamedListener("INVALIDATE_CACHED_ENDPOINTS", "extractError", invalidateCachedEndpoints);
          requiredDiscoverEndpoint(request, done);
          break;
        case "NULL":
        default:
          done();
          break;
      }
    }
    module2.exports = {
      discoverEndpoint,
      requiredDiscoverEndpoint,
      optionalDiscoverEndpoint,
      marshallCustomIdentifiers,
      getCacheKey,
      invalidateCachedEndpoint: invalidateCachedEndpoints
    };
  }
});

// node_modules/aws-sdk/lib/event_listeners.js
var require_event_listeners = __commonJS({
  "node_modules/aws-sdk/lib/event_listeners.js"() {
    var AWS2 = require_core2();
    var SequentialExecutor = require_sequential_executor();
    var DISCOVER_ENDPOINT = require_discover_endpoint().discoverEndpoint;
    AWS2.EventListeners = {
      Core: {}
    };
    function getOperationAuthtype(req) {
      if (!req.service.api.operations) {
        return "";
      }
      var operation = req.service.api.operations[req.operation];
      return operation ? operation.authtype : "";
    }
    AWS2.EventListeners = {
      Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
        addAsync("VALIDATE_CREDENTIALS", "validate", function VALIDATE_CREDENTIALS(req, done) {
          if (!req.service.api.signatureVersion && !req.service.config.signatureVersion)
            return done();
          req.service.config.getCredentials(function(err) {
            if (err) {
              req.response.error = AWS2.util.error(err, { code: "CredentialsError", message: "Missing credentials in config, if using AWS_CONFIG_FILE, set AWS_SDK_LOAD_CONFIG=1" });
            }
            done();
          });
        });
        add("VALIDATE_REGION", "validate", function VALIDATE_REGION(req) {
          if (!req.service.isGlobalEndpoint) {
            var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
            if (!req.service.config.region) {
              req.response.error = AWS2.util.error(new Error(), { code: "ConfigError", message: "Missing region in config" });
            } else if (!dnsHostRegex.test(req.service.config.region)) {
              req.response.error = AWS2.util.error(new Error(), { code: "ConfigError", message: "Invalid region in config" });
            }
          }
        });
        add("BUILD_IDEMPOTENCY_TOKENS", "validate", function BUILD_IDEMPOTENCY_TOKENS(req) {
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          if (!operation) {
            return;
          }
          var idempotentMembers = operation.idempotentMembers;
          if (!idempotentMembers.length) {
            return;
          }
          var params = AWS2.util.copy(req.params);
          for (var i2 = 0, iLen = idempotentMembers.length; i2 < iLen; i2++) {
            if (!params[idempotentMembers[i2]]) {
              params[idempotentMembers[i2]] = AWS2.util.uuid.v4();
            }
          }
          req.params = params;
        });
        add("VALIDATE_PARAMETERS", "validate", function VALIDATE_PARAMETERS(req) {
          if (!req.service.api.operations) {
            return;
          }
          var rules = req.service.api.operations[req.operation].input;
          var validation = req.service.config.paramValidation;
          new AWS2.ParamValidator(validation).validate(rules, req.params);
        });
        add("COMPUTE_CHECKSUM", "afterBuild", function COMPUTE_CHECKSUM(req) {
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          if (!operation) {
            return;
          }
          var body = req.httpRequest.body;
          var isNonStreamingPayload = body && (AWS2.util.Buffer.isBuffer(body) || typeof body === "string");
          var headers = req.httpRequest.headers;
          if (operation.httpChecksumRequired && req.service.config.computeChecksums && isNonStreamingPayload && !headers["Content-MD5"]) {
            var md5 = AWS2.util.crypto.md5(body, "base64");
            headers["Content-MD5"] = md5;
          }
        });
        addAsync("COMPUTE_SHA256", "afterBuild", function COMPUTE_SHA256(req, done) {
          req.haltHandlersOnError();
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          var authtype = operation ? operation.authtype : "";
          if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion)
            return done();
          if (req.service.getSignerClass(req) === AWS2.Signers.V4) {
            var body = req.httpRequest.body || "";
            if (authtype.indexOf("unsigned-body") >= 0) {
              req.httpRequest.headers["X-Amz-Content-Sha256"] = "UNSIGNED-PAYLOAD";
              return done();
            }
            AWS2.util.computeSha256(body, function(err, sha) {
              if (err) {
                done(err);
              } else {
                req.httpRequest.headers["X-Amz-Content-Sha256"] = sha;
                done();
              }
            });
          } else {
            done();
          }
        });
        add("SET_CONTENT_LENGTH", "afterBuild", function SET_CONTENT_LENGTH(req) {
          var authtype = getOperationAuthtype(req);
          var payloadMember = AWS2.util.getRequestPayloadShape(req);
          if (req.httpRequest.headers["Content-Length"] === void 0) {
            try {
              var length = AWS2.util.string.byteLength(req.httpRequest.body);
              req.httpRequest.headers["Content-Length"] = length;
            } catch (err) {
              if (payloadMember && payloadMember.isStreaming) {
                if (payloadMember.requiresLength) {
                  throw err;
                } else if (authtype.indexOf("unsigned-body") >= 0) {
                  req.httpRequest.headers["Transfer-Encoding"] = "chunked";
                  return;
                } else {
                  throw err;
                }
              }
              throw err;
            }
          }
        });
        add("SET_HTTP_HOST", "afterBuild", function SET_HTTP_HOST(req) {
          req.httpRequest.headers["Host"] = req.httpRequest.endpoint.host;
        });
        add("RESTART", "restart", function RESTART() {
          var err = this.response.error;
          if (!err || !err.retryable)
            return;
          this.httpRequest = new AWS2.HttpRequest(this.service.endpoint, this.service.region);
          if (this.response.retryCount < this.service.config.maxRetries) {
            this.response.retryCount++;
          } else {
            this.response.error = null;
          }
        });
        var addToHead = true;
        addAsync("DISCOVER_ENDPOINT", "sign", DISCOVER_ENDPOINT, addToHead);
        addAsync("SIGN", "sign", function SIGN(req, done) {
          var service = req.service;
          var operations = req.service.api.operations || {};
          var operation = operations[req.operation];
          var authtype = operation ? operation.authtype : "";
          if (!service.api.signatureVersion && !authtype && !service.config.signatureVersion)
            return done();
          service.config.getCredentials(function(err, credentials) {
            if (err) {
              req.response.error = err;
              return done();
            }
            try {
              var date = service.getSkewCorrectedDate();
              var SignerClass = service.getSignerClass(req);
              var signer = new SignerClass(req.httpRequest, service.getSigningName(req), {
                signatureCache: service.config.signatureCache,
                operation,
                signatureVersion: service.api.signatureVersion
              });
              signer.setServiceClientId(service._clientId);
              delete req.httpRequest.headers["Authorization"];
              delete req.httpRequest.headers["Date"];
              delete req.httpRequest.headers["X-Amz-Date"];
              signer.addAuthorization(credentials, date);
              req.signedAt = date;
            } catch (e2) {
              req.response.error = e2;
            }
            done();
          });
        });
        add("VALIDATE_RESPONSE", "validateResponse", function VALIDATE_RESPONSE(resp) {
          if (this.service.successfulResponse(resp, this)) {
            resp.data = {};
            resp.error = null;
          } else {
            resp.data = null;
            resp.error = AWS2.util.error(new Error(), { code: "UnknownError", message: "An unknown error occurred." });
          }
        });
        addAsync("SEND", "send", function SEND(resp, done) {
          resp.httpResponse._abortCallback = done;
          resp.error = null;
          resp.data = null;
          function callback(httpResp) {
            resp.httpResponse.stream = httpResp;
            var stream = resp.request.httpRequest.stream;
            var service = resp.request.service;
            var api = service.api;
            var operationName = resp.request.operation;
            var operation = api.operations[operationName] || {};
            httpResp.on("headers", function onHeaders(statusCode, headers, statusMessage) {
              resp.request.emit("httpHeaders", [statusCode, headers, resp, statusMessage]);
              if (!resp.httpResponse.streaming) {
                if (AWS2.HttpClient.streamsApiVersion === 2) {
                  if (operation.hasEventOutput && service.successfulResponse(resp)) {
                    resp.request.emit("httpDone");
                    done();
                    return;
                  }
                  httpResp.on("readable", function onReadable() {
                    var data = httpResp.read();
                    if (data !== null) {
                      resp.request.emit("httpData", [data, resp]);
                    }
                  });
                } else {
                  httpResp.on("data", function onData(data) {
                    resp.request.emit("httpData", [data, resp]);
                  });
                }
              }
            });
            httpResp.on("end", function onEnd() {
              if (!stream || !stream.didCallback) {
                if (AWS2.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {
                  return;
                }
                resp.request.emit("httpDone");
                done();
              }
            });
          }
          function progress(httpResp) {
            httpResp.on("sendProgress", function onSendProgress(value) {
              resp.request.emit("httpUploadProgress", [value, resp]);
            });
            httpResp.on("receiveProgress", function onReceiveProgress(value) {
              resp.request.emit("httpDownloadProgress", [value, resp]);
            });
          }
          function error2(err) {
            if (err.code !== "RequestAbortedError") {
              var errCode = err.code === "TimeoutError" ? err.code : "NetworkingError";
              err = AWS2.util.error(err, {
                code: errCode,
                region: resp.request.httpRequest.region,
                hostname: resp.request.httpRequest.endpoint.hostname,
                retryable: true
              });
            }
            resp.error = err;
            resp.request.emit("httpError", [resp.error, resp], function() {
              done();
            });
          }
          function executeSend() {
            var http3 = AWS2.HttpClient.getInstance();
            var httpOptions = resp.request.service.config.httpOptions || {};
            try {
              var stream = http3.handleRequest(resp.request.httpRequest, httpOptions, callback, error2);
              progress(stream);
            } catch (err) {
              error2(err);
            }
          }
          var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1e3;
          if (timeDiff >= 60 * 10) {
            this.emit("sign", [this], function(err) {
              if (err)
                done(err);
              else
                executeSend();
            });
          } else {
            executeSend();
          }
        });
        add("HTTP_HEADERS", "httpHeaders", function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
          resp.httpResponse.statusCode = statusCode;
          resp.httpResponse.statusMessage = statusMessage;
          resp.httpResponse.headers = headers;
          resp.httpResponse.body = AWS2.util.buffer.toBuffer("");
          resp.httpResponse.buffers = [];
          resp.httpResponse.numBytes = 0;
          var dateHeader = headers.date || headers.Date;
          var service = resp.request.service;
          if (dateHeader) {
            var serverTime = Date.parse(dateHeader);
            if (service.config.correctClockSkew && service.isClockSkewed(serverTime)) {
              service.applyClockOffset(serverTime);
            }
          }
        });
        add("HTTP_DATA", "httpData", function HTTP_DATA(chunk, resp) {
          if (chunk) {
            if (AWS2.util.isNode()) {
              resp.httpResponse.numBytes += chunk.length;
              var total = resp.httpResponse.headers["content-length"];
              var progress = { loaded: resp.httpResponse.numBytes, total };
              resp.request.emit("httpDownloadProgress", [progress, resp]);
            }
            resp.httpResponse.buffers.push(AWS2.util.buffer.toBuffer(chunk));
          }
        });
        add("HTTP_DONE", "httpDone", function HTTP_DONE(resp) {
          if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
            var body = AWS2.util.buffer.concat(resp.httpResponse.buffers);
            resp.httpResponse.body = body;
          }
          delete resp.httpResponse.numBytes;
          delete resp.httpResponse.buffers;
        });
        add("FINALIZE_ERROR", "retry", function FINALIZE_ERROR(resp) {
          if (resp.httpResponse.statusCode) {
            resp.error.statusCode = resp.httpResponse.statusCode;
            if (resp.error.retryable === void 0) {
              resp.error.retryable = this.service.retryableError(resp.error, this);
            }
          }
        });
        add("INVALIDATE_CREDENTIALS", "retry", function INVALIDATE_CREDENTIALS(resp) {
          if (!resp.error)
            return;
          switch (resp.error.code) {
            case "RequestExpired":
            case "ExpiredTokenException":
            case "ExpiredToken":
              resp.error.retryable = true;
              resp.request.service.config.credentials.expired = true;
          }
        });
        add("EXPIRED_SIGNATURE", "retry", function EXPIRED_SIGNATURE(resp) {
          var err = resp.error;
          if (!err)
            return;
          if (typeof err.code === "string" && typeof err.message === "string") {
            if (err.code.match(/Signature/) && err.message.match(/expired/)) {
              resp.error.retryable = true;
            }
          }
        });
        add("CLOCK_SKEWED", "retry", function CLOCK_SKEWED(resp) {
          if (!resp.error)
            return;
          if (this.service.clockSkewError(resp.error) && this.service.config.correctClockSkew) {
            resp.error.retryable = true;
          }
        });
        add("REDIRECT", "retry", function REDIRECT(resp) {
          if (resp.error && resp.error.statusCode >= 300 && resp.error.statusCode < 400 && resp.httpResponse.headers["location"]) {
            this.httpRequest.endpoint = new AWS2.Endpoint(resp.httpResponse.headers["location"]);
            this.httpRequest.headers["Host"] = this.httpRequest.endpoint.host;
            resp.error.redirect = true;
            resp.error.retryable = true;
          }
        });
        add("RETRY_CHECK", "retry", function RETRY_CHECK(resp) {
          if (resp.error) {
            if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
              resp.error.retryDelay = 0;
            } else if (resp.retryCount < resp.maxRetries) {
              resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
            }
          }
        });
        addAsync("RESET_RETRY_STATE", "afterRetry", function RESET_RETRY_STATE(resp, done) {
          var delay, willRetry = false;
          if (resp.error) {
            delay = resp.error.retryDelay || 0;
            if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
              resp.retryCount++;
              willRetry = true;
            } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
              resp.redirectCount++;
              willRetry = true;
            }
          }
          if (willRetry && delay >= 0) {
            resp.error = null;
            setTimeout(done, delay);
          } else {
            done();
          }
        });
      }),
      CorePost: new SequentialExecutor().addNamedListeners(function(add) {
        add("EXTRACT_REQUEST_ID", "extractData", AWS2.util.extractRequestId);
        add("EXTRACT_REQUEST_ID", "extractError", AWS2.util.extractRequestId);
        add("ENOTFOUND_ERROR", "httpError", function ENOTFOUND_ERROR(err) {
          function isDNSError(err2) {
            return err2.errno === "ENOTFOUND" || typeof err2.errno === "number" && typeof AWS2.util.getSystemErrorName === "function" && ["EAI_NONAME", "EAI_NODATA"].indexOf(AWS2.util.getSystemErrorName(err2.errno) >= 0);
          }
          if (err.code === "NetworkingError" && isDNSError(err)) {
            var message = "Inaccessible host: `" + err.hostname + "' at port `" + err.port + "'. This service may not be available in the `" + err.region + "' region.";
            this.response.error = AWS2.util.error(new Error(message), {
              code: "UnknownEndpoint",
              region: err.region,
              hostname: err.hostname,
              retryable: true,
              originalError: err
            });
          }
        });
      }),
      Logger: new SequentialExecutor().addNamedListeners(function(add) {
        add("LOG_REQUEST", "complete", function LOG_REQUEST(resp) {
          var req = resp.request;
          var logger = req.service.config.logger;
          if (!logger)
            return;
          function filterSensitiveLog(inputShape, shape) {
            if (!shape) {
              return shape;
            }
            if (inputShape.isSensitive) {
              return "***SensitiveInformation***";
            }
            switch (inputShape.type) {
              case "structure":
                var struct = {};
                AWS2.util.each(shape, function(subShapeName, subShape) {
                  if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
                    struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
                  } else {
                    struct[subShapeName] = subShape;
                  }
                });
                return struct;
              case "list":
                var list = [];
                AWS2.util.arrayEach(shape, function(subShape, index) {
                  list.push(filterSensitiveLog(inputShape.member, subShape));
                });
                return list;
              case "map":
                var map = {};
                AWS2.util.each(shape, function(key, value) {
                  map[key] = filterSensitiveLog(inputShape.value, value);
                });
                return map;
              default:
                return shape;
            }
          }
          function buildMessage() {
            var time = resp.request.service.getSkewCorrectedDate().getTime();
            var delta = (time - req.startTime.getTime()) / 1e3;
            var ansi = logger.isTTY ? true : false;
            var status = resp.httpResponse.statusCode;
            var censoredParams = req.params;
            if (req.service.api.operations && req.service.api.operations[req.operation] && req.service.api.operations[req.operation].input) {
              var inputShape = req.service.api.operations[req.operation].input;
              censoredParams = filterSensitiveLog(inputShape, req.params);
            }
            var params = require("util").inspect(censoredParams, true, null);
            var message = "";
            if (ansi)
              message += "\x1B[33m";
            message += "[AWS " + req.service.serviceIdentifier + " " + status;
            message += " " + delta.toString() + "s " + resp.retryCount + " retries]";
            if (ansi)
              message += "\x1B[0;1m";
            message += " " + AWS2.util.string.lowerFirst(req.operation);
            message += "(" + params + ")";
            if (ansi)
              message += "\x1B[0m";
            return message;
          }
          var line = buildMessage();
          if (typeof logger.log === "function") {
            logger.log(line);
          } else if (typeof logger.write === "function") {
            logger.write(line + "\n");
          }
        });
      }),
      Json: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_json();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      }),
      Rest: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_rest();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      }),
      RestJson: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_rest_json();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      }),
      RestXml: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_rest_xml();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      }),
      Query: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_query();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      })
    };
  }
});

// node_modules/aws-sdk/lib/state_machine.js
var require_state_machine = __commonJS({
  "node_modules/aws-sdk/lib/state_machine.js"(exports, module2) {
    function AcceptorStateMachine(states, state) {
      this.currentState = state || null;
      this.states = states || {};
    }
    AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
      if (typeof finalState === "function") {
        inputError = bindObject;
        bindObject = done;
        done = finalState;
        finalState = null;
      }
      var self2 = this;
      var state = self2.states[self2.currentState];
      state.fn.call(bindObject || self2, inputError, function(err) {
        if (err) {
          if (state.fail)
            self2.currentState = state.fail;
          else
            return done ? done.call(bindObject, err) : null;
        } else {
          if (state.accept)
            self2.currentState = state.accept;
          else
            return done ? done.call(bindObject) : null;
        }
        if (self2.currentState === finalState) {
          return done ? done.call(bindObject, err) : null;
        }
        self2.runTo(finalState, done, bindObject, err);
      });
    };
    AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
      if (typeof acceptState === "function") {
        fn = acceptState;
        acceptState = null;
        failState = null;
      } else if (typeof failState === "function") {
        fn = failState;
        failState = null;
      }
      if (!this.currentState)
        this.currentState = name;
      this.states[name] = { accept: acceptState, fail: failState, fn };
      return this;
    };
    module2.exports = AcceptorStateMachine;
  }
});

// node_modules/jmespath/jmespath.js
var require_jmespath = __commonJS({
  "node_modules/jmespath/jmespath.js"(exports) {
    (function(exports2) {
      "use strict";
      function isArray(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        } else {
          return false;
        }
      }
      function isObject(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        } else {
          return false;
        }
      }
      function strictDeepEqual(first, second) {
        if (first === second) {
          return true;
        }
        var firstType = Object.prototype.toString.call(first);
        if (firstType !== Object.prototype.toString.call(second)) {
          return false;
        }
        if (isArray(first) === true) {
          if (first.length !== second.length) {
            return false;
          }
          for (var i2 = 0; i2 < first.length; i2++) {
            if (strictDeepEqual(first[i2], second[i2]) === false) {
              return false;
            }
          }
          return true;
        }
        if (isObject(first) === true) {
          var keysSeen = {};
          for (var key in first) {
            if (hasOwnProperty.call(first, key)) {
              if (strictDeepEqual(first[key], second[key]) === false) {
                return false;
              }
              keysSeen[key] = true;
            }
          }
          for (var key2 in second) {
            if (hasOwnProperty.call(second, key2)) {
              if (keysSeen[key2] !== true) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      function isFalse(obj) {
        if (obj === "" || obj === false || obj === null) {
          return true;
        } else if (isArray(obj) && obj.length === 0) {
          return true;
        } else if (isObject(obj)) {
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      }
      function objValues(obj) {
        var keys = Object.keys(obj);
        var values = [];
        for (var i2 = 0; i2 < keys.length; i2++) {
          values.push(obj[keys[i2]]);
        }
        return values;
      }
      function merge(a, b) {
        var merged = {};
        for (var key in a) {
          merged[key] = a[key];
        }
        for (var key2 in b) {
          merged[key2] = b[key2];
        }
        return merged;
      }
      var trimLeft;
      if (typeof String.prototype.trimLeft === "function") {
        trimLeft = function(str) {
          return str.trimLeft();
        };
      } else {
        trimLeft = function(str) {
          return str.match(/^\s*(.*)/)[1];
        };
      }
      var TYPE_NUMBER = 0;
      var TYPE_ANY = 1;
      var TYPE_STRING = 2;
      var TYPE_ARRAY = 3;
      var TYPE_OBJECT = 4;
      var TYPE_BOOLEAN = 5;
      var TYPE_EXPREF = 6;
      var TYPE_NULL = 7;
      var TYPE_ARRAY_NUMBER = 8;
      var TYPE_ARRAY_STRING = 9;
      var TYPE_NAME_TABLE = {
        0: "number",
        1: "any",
        2: "string",
        3: "array",
        4: "object",
        5: "boolean",
        6: "expression",
        7: "null",
        8: "Array<number>",
        9: "Array<string>"
      };
      var TOK_EOF = "EOF";
      var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
      var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
      var TOK_RBRACKET = "Rbracket";
      var TOK_RPAREN = "Rparen";
      var TOK_COMMA = "Comma";
      var TOK_COLON = "Colon";
      var TOK_RBRACE = "Rbrace";
      var TOK_NUMBER = "Number";
      var TOK_CURRENT = "Current";
      var TOK_EXPREF = "Expref";
      var TOK_PIPE = "Pipe";
      var TOK_OR = "Or";
      var TOK_AND = "And";
      var TOK_EQ = "EQ";
      var TOK_GT = "GT";
      var TOK_LT = "LT";
      var TOK_GTE = "GTE";
      var TOK_LTE = "LTE";
      var TOK_NE = "NE";
      var TOK_FLATTEN = "Flatten";
      var TOK_STAR = "Star";
      var TOK_FILTER = "Filter";
      var TOK_DOT = "Dot";
      var TOK_NOT = "Not";
      var TOK_LBRACE = "Lbrace";
      var TOK_LBRACKET = "Lbracket";
      var TOK_LPAREN = "Lparen";
      var TOK_LITERAL = "Literal";
      var basicTokens = {
        ".": TOK_DOT,
        "*": TOK_STAR,
        ",": TOK_COMMA,
        ":": TOK_COLON,
        "{": TOK_LBRACE,
        "}": TOK_RBRACE,
        "]": TOK_RBRACKET,
        "(": TOK_LPAREN,
        ")": TOK_RPAREN,
        "@": TOK_CURRENT
      };
      var operatorStartToken = {
        "<": true,
        ">": true,
        "=": true,
        "!": true
      };
      var skipChars = {
        " ": true,
        "	": true,
        "\n": true
      };
      function isAlpha(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch === "_";
      }
      function isNum(ch) {
        return ch >= "0" && ch <= "9" || ch === "-";
      }
      function isAlphaNum(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9" || ch === "_";
      }
      function Lexer() {
      }
      Lexer.prototype = {
        tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token2;
          while (this._current < stream.length) {
            if (isAlpha(stream[this._current])) {
              start = this._current;
              identifier = this._consumeUnquotedIdentifier(stream);
              tokens.push({
                type: TOK_UNQUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (basicTokens[stream[this._current]] !== void 0) {
              tokens.push({
                type: basicTokens[stream[this._current]],
                value: stream[this._current],
                start: this._current
              });
              this._current++;
            } else if (isNum(stream[this._current])) {
              token2 = this._consumeNumber(stream);
              tokens.push(token2);
            } else if (stream[this._current] === "[") {
              token2 = this._consumeLBracket(stream);
              tokens.push(token2);
            } else if (stream[this._current] === '"') {
              start = this._current;
              identifier = this._consumeQuotedIdentifier(stream);
              tokens.push({
                type: TOK_QUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "'") {
              start = this._current;
              identifier = this._consumeRawStringLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "`") {
              start = this._current;
              var literal = this._consumeLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: literal,
                start
              });
            } else if (operatorStartToken[stream[this._current]] !== void 0) {
              tokens.push(this._consumeOperator(stream));
            } else if (skipChars[stream[this._current]] !== void 0) {
              this._current++;
            } else if (stream[this._current] === "&") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "&") {
                this._current++;
                tokens.push({ type: TOK_AND, value: "&&", start });
              } else {
                tokens.push({ type: TOK_EXPREF, value: "&", start });
              }
            } else if (stream[this._current] === "|") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "|") {
                this._current++;
                tokens.push({ type: TOK_OR, value: "||", start });
              } else {
                tokens.push({ type: TOK_PIPE, value: "|", start });
              }
            } else {
              var error2 = new Error("Unknown character:" + stream[this._current]);
              error2.name = "LexerError";
              throw error2;
            }
          }
          return tokens;
        },
        _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
            this._current++;
          }
          return stream.slice(start, this._current);
        },
        _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== '"' && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === '"')) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
        },
        _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "'")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
        },
        _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
            this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return { type: TOK_NUMBER, value, start };
        },
        _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
            this._current++;
            return { type: TOK_FILTER, value: "[?", start };
          } else if (stream[this._current] === "]") {
            this._current++;
            return { type: TOK_FLATTEN, value: "[]", start };
          } else {
            return { type: TOK_LBRACKET, value: "[", start };
          }
        },
        _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_NE, value: "!=", start };
            } else {
              return { type: TOK_NOT, value: "!", start };
            }
          } else if (startingChar === "<") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_LTE, value: "<=", start };
            } else {
              return { type: TOK_LT, value: "<", start };
            }
          } else if (startingChar === ">") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_GTE, value: ">=", start };
            } else {
              return { type: TOK_GT, value: ">", start };
            }
          } else if (startingChar === "=") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_EQ, value: "==", start };
            }
          }
        },
        _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while (stream[this._current] !== "`" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "`")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
            literal = JSON.parse(literalString);
          } else {
            literal = JSON.parse('"' + literalString + '"');
          }
          this._current++;
          return literal;
        },
        _looksLikeJSON: function(literalString) {
          var startingChars = '[{"';
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";
          if (literalString === "") {
            return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
            return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
            return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
            try {
              JSON.parse(literalString);
              return true;
            } catch (ex) {
              return false;
            }
          } else {
            return false;
          }
        }
      };
      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;
      function Parser() {
      }
      Parser.prototype = {
        parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
            var t2 = this._lookaheadToken(0);
            var error2 = new Error("Unexpected token type: " + t2.type + ", value: " + t2.value);
            error2.name = "ParserError";
            throw error2;
          }
          return ast;
        },
        _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({ type: TOK_EOF, value: "", start: expression.length });
          this.tokens = tokens;
        },
        expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
            this._advance();
            left = this.led(currentToken, left);
            currentToken = this._lookahead(0);
          }
          return left;
        },
        _lookahead: function(number) {
          return this.tokens[this.index + number].type;
        },
        _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
        },
        _advance: function() {
          this.index++;
        },
        nud: function(token2) {
          var left;
          var right;
          var expression;
          switch (token2.type) {
            case TOK_LITERAL:
              return { type: "Literal", value: token2.value };
            case TOK_UNQUOTEDIDENTIFIER:
              return { type: "Field", name: token2.value };
            case TOK_QUOTEDIDENTIFIER:
              var node = { type: "Field", name: token2.value };
              if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
              }
              return node;
            case TOK_NOT:
              right = this.expression(bindingPower.Not);
              return { type: "NotExpression", children: [right] };
            case TOK_STAR:
              left = { type: "Identity" };
              right = null;
              if (this._lookahead(0) === TOK_RBRACKET) {
                right = { type: "Identity" };
              } else {
                right = this._parseProjectionRHS(bindingPower.Star);
              }
              return { type: "ValueProjection", children: [left, right] };
            case TOK_FILTER:
              return this.led(token2.type, { type: "Identity" });
            case TOK_LBRACE:
              return this._parseMultiselectHash();
            case TOK_FLATTEN:
              left = { type: TOK_FLATTEN, children: [{ type: "Identity" }] };
              right = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: "Projection", children: [left, right] };
            case TOK_LBRACKET:
              if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({ type: "Identity" }, right);
              } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {
                  type: "Projection",
                  children: [{ type: "Identity" }, right]
                };
              }
              return this._parseMultiselectList();
            case TOK_CURRENT:
              return { type: TOK_CURRENT };
            case TOK_EXPREF:
              expression = this.expression(bindingPower.Expref);
              return { type: "ExpressionReference", children: [expression] };
            case TOK_LPAREN:
              var args = [];
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              return args[0];
            default:
              this._errorToken(token2);
          }
        },
        led: function(tokenName, left) {
          var right;
          switch (tokenName) {
            case TOK_DOT:
              var rbp = bindingPower.Dot;
              if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return { type: "Subexpression", children: [left, right] };
              }
              this._advance();
              right = this._parseProjectionRHS(rbp);
              return { type: "ValueProjection", children: [left, right] };
            case TOK_PIPE:
              right = this.expression(bindingPower.Pipe);
              return { type: TOK_PIPE, children: [left, right] };
            case TOK_OR:
              right = this.expression(bindingPower.Or);
              return { type: "OrExpression", children: [left, right] };
            case TOK_AND:
              right = this.expression(bindingPower.And);
              return { type: "AndExpression", children: [left, right] };
            case TOK_LPAREN:
              var name = left.name;
              var args = [];
              var expression, node;
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              node = { type: "Function", name, children: args };
              return node;
            case TOK_FILTER:
              var condition = this.expression(0);
              this._match(TOK_RBRACKET);
              if (this._lookahead(0) === TOK_FLATTEN) {
                right = { type: "Identity" };
              } else {
                right = this._parseProjectionRHS(bindingPower.Filter);
              }
              return { type: "FilterProjection", children: [left, right, condition] };
            case TOK_FLATTEN:
              var leftNode = { type: TOK_FLATTEN, children: [left] };
              var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: "Projection", children: [leftNode, rightNode] };
            case TOK_EQ:
            case TOK_NE:
            case TOK_GT:
            case TOK_GTE:
            case TOK_LT:
            case TOK_LTE:
              return this._parseComparator(left, tokenName);
            case TOK_LBRACKET:
              var token2 = this._lookaheadToken(0);
              if (token2.type === TOK_NUMBER || token2.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
              }
              this._match(TOK_STAR);
              this._match(TOK_RBRACKET);
              right = this._parseProjectionRHS(bindingPower.Star);
              return { type: "Projection", children: [left, right] };
            default:
              this._errorToken(this._lookaheadToken(0));
          }
        },
        _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
            this._advance();
          } else {
            var t2 = this._lookaheadToken(0);
            var error2 = new Error("Expected " + tokenType + ", got: " + t2.type);
            error2.name = "ParserError";
            throw error2;
          }
        },
        _errorToken: function(token2) {
          var error2 = new Error("Invalid token (" + token2.type + '): "' + token2.value + '"');
          error2.name = "ParserError";
          throw error2;
        },
        _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
            return this._parseSliceExpression();
          } else {
            var node = {
              type: "Index",
              value: this._lookaheadToken(0).value
            };
            this._advance();
            this._match(TOK_RBRACKET);
            return node;
          }
        },
        _projectIfSlice: function(left, right) {
          var indexExpr = { type: "IndexExpression", children: [left, right] };
          if (right.type === "Slice") {
            return {
              type: "Projection",
              children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
            };
          } else {
            return indexExpr;
          }
        },
        _parseSliceExpression: function() {
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
            if (currentToken === TOK_COLON) {
              index++;
              this._advance();
            } else if (currentToken === TOK_NUMBER) {
              parts[index] = this._lookaheadToken(0).value;
              this._advance();
            } else {
              var t2 = this._lookahead(0);
              var error2 = new Error("Syntax error, unexpected token: " + t2.value + "(" + t2.type + ")");
              error2.name = "Parsererror";
              throw error2;
            }
            currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
            type: "Slice",
            children: parts
          };
        },
        _parseComparator: function(left, comparator) {
          var right = this.expression(bindingPower[comparator]);
          return { type: "Comparator", name: comparator, children: [left, right] };
        },
        _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
            return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
            this._match(TOK_LBRACKET);
            return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
            this._match(TOK_LBRACE);
            return this._parseMultiselectHash();
          }
        },
        _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
            right = { type: "Identity" };
          } else if (this._lookahead(0) === TOK_LBRACKET) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
            this._match(TOK_DOT);
            right = this._parseDotRHS(rbp);
          } else {
            var t2 = this._lookaheadToken(0);
            var error2 = new Error("Sytanx error, unexpected token: " + t2.value + "(" + t2.type + ")");
            error2.name = "ParserError";
            throw error2;
          }
          return right;
        },
        _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
            var expression = this.expression(0);
            expressions.push(expression);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
              if (this._lookahead(0) === TOK_RBRACKET) {
                throw new Error("Unexpected token Rbracket");
              }
            }
          }
          this._match(TOK_RBRACKET);
          return { type: "MultiSelectList", children: expressions };
        },
        _parseMultiselectHash: function() {
          var pairs = [];
          var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
          var keyToken, keyName, value, node;
          for (; ; ) {
            keyToken = this._lookaheadToken(0);
            if (identifierTypes.indexOf(keyToken.type) < 0) {
              throw new Error("Expecting an identifier token, got: " + keyToken.type);
            }
            keyName = keyToken.value;
            this._advance();
            this._match(TOK_COLON);
            value = this.expression(0);
            node = { type: "KeyValuePair", name: keyName, value };
            pairs.push(node);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
            } else if (this._lookahead(0) === TOK_RBRACE) {
              this._match(TOK_RBRACE);
              break;
            }
          }
          return { type: "MultiSelectHash", children: pairs };
        }
      };
      function TreeInterpreter(runtime) {
        this.runtime = runtime;
      }
      TreeInterpreter.prototype = {
        search: function(node, value) {
          return this.visit(node, value);
        },
        visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i2;
          switch (node.type) {
            case "Field":
              if (value !== null && isObject(value)) {
                field = value[node.name];
                if (field === void 0) {
                  return null;
                } else {
                  return field;
                }
              }
              return null;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i2 = 1; i2 < node.children.length; i2++) {
                result = this.visit(node.children[1], result);
                if (result === null) {
                  return null;
                }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === void 0) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                for (i2 = start; i2 < stop; i2 += step) {
                  result.push(value[i2]);
                }
              } else {
                for (i2 = start; i2 > stop; i2 += step) {
                  result.push(value[i2]);
                }
              }
              return result;
            case "Projection":
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i2 = 0; i2 < base.length; i2++) {
                current = this.visit(node.children[1], base[i2]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i2 = 0; i2 < values.length; i2++) {
                current = this.visit(node.children[1], values[i2]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i2 = 0; i2 < base.length; i2++) {
                matched = this.visit(node.children[2], base[i2]);
                if (!isFalse(matched)) {
                  filtered.push(base[i2]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch (node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i2 = 0; i2 < original.length; i2++) {
                current = original[i2];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i2 = 0; i2 < node.children.length; i2++) {
                collected.push(this.visit(node.children[i2], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i2 = 0; i2 < node.children.length; i2++) {
                child = node.children[i2];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);
              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i2 = 0; i2 < node.children.length; i2++) {
                resolvedArgs.push(this.visit(node.children[i2], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
        },
        computeSliceParams: function(arrayLength, sliceParams) {
          var start = sliceParams[0];
          var stop = sliceParams[1];
          var step = sliceParams[2];
          var computed = [null, null, null];
          if (step === null) {
            step = 1;
          } else if (step === 0) {
            var error2 = new Error("Invalid slice, step cannot be 0");
            error2.name = "RuntimeError";
            throw error2;
          }
          var stepValueNegative = step < 0 ? true : false;
          if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
          } else {
            start = this.capSliceRange(arrayLength, start, step);
          }
          if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
          } else {
            stop = this.capSliceRange(arrayLength, stop, step);
          }
          computed[0] = start;
          computed[1] = stop;
          computed[2] = step;
          return computed;
        },
        capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
            actualValue += arrayLength;
            if (actualValue < 0) {
              actualValue = step < 0 ? -1 : 0;
            }
          } else if (actualValue >= arrayLength) {
            actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
        }
      };
      function Runtime(interpreter) {
        this._interpreter = interpreter;
        this.functionTable = {
          abs: { _func: this._functionAbs, _signature: [{ types: [TYPE_NUMBER] }] },
          avg: { _func: this._functionAvg, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          ceil: { _func: this._functionCeil, _signature: [{ types: [TYPE_NUMBER] }] },
          contains: {
            _func: this._functionContains,
            _signature: [
              { types: [TYPE_STRING, TYPE_ARRAY] },
              { types: [TYPE_ANY] }
            ]
          },
          "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
          },
          floor: { _func: this._functionFloor, _signature: [{ types: [TYPE_NUMBER] }] },
          length: {
            _func: this._functionLength,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }]
          },
          map: {
            _func: this._functionMap,
            _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }]
          },
          max: {
            _func: this._functionMax,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
          },
          "merge": {
            _func: this._functionMerge,
            _signature: [{ types: [TYPE_OBJECT], variadic: true }]
          },
          "max_by": {
            _func: this._functionMaxBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          sum: { _func: this._functionSum, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
          },
          min: {
            _func: this._functionMin,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
          },
          "min_by": {
            _func: this._functionMinBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          type: { _func: this._functionType, _signature: [{ types: [TYPE_ANY] }] },
          keys: { _func: this._functionKeys, _signature: [{ types: [TYPE_OBJECT] }] },
          values: { _func: this._functionValues, _signature: [{ types: [TYPE_OBJECT] }] },
          sort: { _func: this._functionSort, _signature: [{ types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }] },
          "sort_by": {
            _func: this._functionSortBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          join: {
            _func: this._functionJoin,
            _signature: [
              { types: [TYPE_STRING] },
              { types: [TYPE_ARRAY_STRING] }
            ]
          },
          reverse: {
            _func: this._functionReverse,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }]
          },
          "to_array": { _func: this._functionToArray, _signature: [{ types: [TYPE_ANY] }] },
          "to_string": { _func: this._functionToString, _signature: [{ types: [TYPE_ANY] }] },
          "to_number": { _func: this._functionToNumber, _signature: [{ types: [TYPE_ANY] }] },
          "not_null": {
            _func: this._functionNotNull,
            _signature: [{ types: [TYPE_ANY], variadic: true }]
          }
        };
      }
      Runtime.prototype = {
        callFunction: function(name, resolvedArgs) {
          var functionEntry = this.functionTable[name];
          if (functionEntry === void 0) {
            throw new Error("Unknown function: " + name + "()");
          }
          this._validateArgs(name, resolvedArgs, functionEntry._signature);
          return functionEntry._func.call(this, resolvedArgs);
        },
        _validateArgs: function(name, args, signature) {
          var pluralized;
          if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
              pluralized = signature.length === 1 ? " argument" : " arguments";
              throw new Error("ArgumentError: " + name + "() takes at least" + signature.length + pluralized + " but received " + args.length);
            }
          } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() takes " + signature.length + pluralized + " but received " + args.length);
          }
          var currentSpec;
          var actualType;
          var typeMatched;
          for (var i2 = 0; i2 < signature.length; i2++) {
            typeMatched = false;
            currentSpec = signature[i2].types;
            actualType = this._getTypeName(args[i2]);
            for (var j = 0; j < currentSpec.length; j++) {
              if (this._typeMatches(actualType, currentSpec[j], args[i2])) {
                typeMatched = true;
                break;
              }
            }
            if (!typeMatched) {
              var expected = currentSpec.map(function(typeIdentifier) {
                return TYPE_NAME_TABLE[typeIdentifier];
              }).join(",");
              throw new Error("TypeError: " + name + "() expected argument " + (i2 + 1) + " to be type " + expected + " but received type " + TYPE_NAME_TABLE[actualType] + " instead.");
            }
          }
        },
        _typeMatches: function(actual, expected, argValue) {
          if (expected === TYPE_ANY) {
            return true;
          }
          if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {
            if (expected === TYPE_ARRAY) {
              return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
              var subtype;
              if (expected === TYPE_ARRAY_NUMBER) {
                subtype = TYPE_NUMBER;
              } else if (expected === TYPE_ARRAY_STRING) {
                subtype = TYPE_STRING;
              }
              for (var i2 = 0; i2 < argValue.length; i2++) {
                if (!this._typeMatches(this._getTypeName(argValue[i2]), subtype, argValue[i2])) {
                  return false;
                }
              }
              return true;
            }
          } else {
            return actual === expected;
          }
        },
        _getTypeName: function(obj) {
          switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
          }
        },
        _functionStartsWith: function(resolvedArgs) {
          return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
        },
        _functionEndsWith: function(resolvedArgs) {
          var searchStr = resolvedArgs[0];
          var suffix = resolvedArgs[1];
          return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
        },
        _functionReverse: function(resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);
          if (typeName === TYPE_STRING) {
            var originalStr = resolvedArgs[0];
            var reversedStr = "";
            for (var i2 = originalStr.length - 1; i2 >= 0; i2--) {
              reversedStr += originalStr[i2];
            }
            return reversedStr;
          } else {
            var reversedArray = resolvedArgs[0].slice(0);
            reversedArray.reverse();
            return reversedArray;
          }
        },
        _functionAbs: function(resolvedArgs) {
          return Math.abs(resolvedArgs[0]);
        },
        _functionCeil: function(resolvedArgs) {
          return Math.ceil(resolvedArgs[0]);
        },
        _functionAvg: function(resolvedArgs) {
          var sum = 0;
          var inputArray = resolvedArgs[0];
          for (var i2 = 0; i2 < inputArray.length; i2++) {
            sum += inputArray[i2];
          }
          return sum / inputArray.length;
        },
        _functionContains: function(resolvedArgs) {
          return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
        },
        _functionFloor: function(resolvedArgs) {
          return Math.floor(resolvedArgs[0]);
        },
        _functionLength: function(resolvedArgs) {
          if (!isObject(resolvedArgs[0])) {
            return resolvedArgs[0].length;
          } else {
            return Object.keys(resolvedArgs[0]).length;
          }
        },
        _functionMap: function(resolvedArgs) {
          var mapped = [];
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[0];
          var elements = resolvedArgs[1];
          for (var i2 = 0; i2 < elements.length; i2++) {
            mapped.push(interpreter.visit(exprefNode, elements[i2]));
          }
          return mapped;
        },
        _functionMerge: function(resolvedArgs) {
          var merged = {};
          for (var i2 = 0; i2 < resolvedArgs.length; i2++) {
            var current = resolvedArgs[i2];
            for (var key in current) {
              merged[key] = current[key];
            }
          }
          return merged;
        },
        _functionMax: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);
            if (typeName === TYPE_NUMBER) {
              return Math.max.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var maxElement = elements[0];
              for (var i2 = 1; i2 < elements.length; i2++) {
                if (maxElement.localeCompare(elements[i2]) < 0) {
                  maxElement = elements[i2];
                }
              }
              return maxElement;
            }
          } else {
            return null;
          }
        },
        _functionMin: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);
            if (typeName === TYPE_NUMBER) {
              return Math.min.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var minElement = elements[0];
              for (var i2 = 1; i2 < elements.length; i2++) {
                if (elements[i2].localeCompare(minElement) < 0) {
                  minElement = elements[i2];
                }
              }
              return minElement;
            }
          } else {
            return null;
          }
        },
        _functionSum: function(resolvedArgs) {
          var sum = 0;
          var listToSum = resolvedArgs[0];
          for (var i2 = 0; i2 < listToSum.length; i2++) {
            sum += listToSum[i2];
          }
          return sum;
        },
        _functionType: function(resolvedArgs) {
          switch (this._getTypeName(resolvedArgs[0])) {
            case TYPE_NUMBER:
              return "number";
            case TYPE_STRING:
              return "string";
            case TYPE_ARRAY:
              return "array";
            case TYPE_OBJECT:
              return "object";
            case TYPE_BOOLEAN:
              return "boolean";
            case TYPE_EXPREF:
              return "expref";
            case TYPE_NULL:
              return "null";
          }
        },
        _functionKeys: function(resolvedArgs) {
          return Object.keys(resolvedArgs[0]);
        },
        _functionValues: function(resolvedArgs) {
          var obj = resolvedArgs[0];
          var keys = Object.keys(obj);
          var values = [];
          for (var i2 = 0; i2 < keys.length; i2++) {
            values.push(obj[keys[i2]]);
          }
          return values;
        },
        _functionJoin: function(resolvedArgs) {
          var joinChar = resolvedArgs[0];
          var listJoin = resolvedArgs[1];
          return listJoin.join(joinChar);
        },
        _functionToArray: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
          } else {
            return [resolvedArgs[0]];
          }
        },
        _functionToString: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
          } else {
            return JSON.stringify(resolvedArgs[0]);
          }
        },
        _functionToNumber: function(resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);
          var convertedValue;
          if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
          } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
              return convertedValue;
            }
          }
          return null;
        },
        _functionNotNull: function(resolvedArgs) {
          for (var i2 = 0; i2 < resolvedArgs.length; i2++) {
            if (this._getTypeName(resolvedArgs[i2]) !== TYPE_NULL) {
              return resolvedArgs[i2];
            }
          }
          return null;
        },
        _functionSort: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          sortedArray.sort();
          return sortedArray;
        },
        _functionSortBy: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          if (sortedArray.length === 0) {
            return sortedArray;
          }
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[1];
          var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));
          if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
          }
          var that = this;
          var decorated = [];
          for (var i2 = 0; i2 < sortedArray.length; i2++) {
            decorated.push([i2, sortedArray[i2]]);
          }
          decorated.sort(function(a, b) {
            var exprA = interpreter.visit(exprefNode, a[1]);
            var exprB = interpreter.visit(exprefNode, b[1]);
            if (that._getTypeName(exprA) !== requiredType) {
              throw new Error("TypeError: expected " + requiredType + ", received " + that._getTypeName(exprA));
            } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error("TypeError: expected " + requiredType + ", received " + that._getTypeName(exprB));
            }
            if (exprA > exprB) {
              return 1;
            } else if (exprA < exprB) {
              return -1;
            } else {
              return a[0] - b[0];
            }
          });
          for (var j = 0; j < decorated.length; j++) {
            sortedArray[j] = decorated[j][1];
          }
          return sortedArray;
        },
        _functionMaxBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var maxNumber = -Infinity;
          var maxRecord;
          var current;
          for (var i2 = 0; i2 < resolvedArray.length; i2++) {
            current = keyFunction(resolvedArray[i2]);
            if (current > maxNumber) {
              maxNumber = current;
              maxRecord = resolvedArray[i2];
            }
          }
          return maxRecord;
        },
        _functionMinBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var minNumber = Infinity;
          var minRecord;
          var current;
          for (var i2 = 0; i2 < resolvedArray.length; i2++) {
            current = keyFunction(resolvedArray[i2]);
            if (current < minNumber) {
              minNumber = current;
              minRecord = resolvedArray[i2];
            }
          }
          return minRecord;
        },
        createKeyFunction: function(exprefNode, allowedTypes) {
          var that = this;
          var interpreter = this._interpreter;
          var keyFunc = function(x2) {
            var current = interpreter.visit(exprefNode, x2);
            if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
              var msg = "TypeError: expected one of " + allowedTypes + ", received " + that._getTypeName(current);
              throw new Error(msg);
            }
            return current;
          };
          return keyFunc;
        }
      };
      function compile(stream) {
        var parser = new Parser();
        var ast = parser.parse(stream);
        return ast;
      }
      function tokenize(stream) {
        var lexer = new Lexer();
        return lexer.tokenize(stream);
      }
      function search(data, expression) {
        var parser = new Parser();
        var runtime = new Runtime();
        var interpreter = new TreeInterpreter(runtime);
        runtime._interpreter = interpreter;
        var node = parser.parse(expression);
        return interpreter.search(node, data);
      }
      exports2.tokenize = tokenize;
      exports2.compile = compile;
      exports2.search = search;
      exports2.strictDeepEqual = strictDeepEqual;
    })(typeof exports === "undefined" ? exports.jmespath = {} : exports);
  }
});

// node_modules/aws-sdk/lib/request.js
var require_request = __commonJS({
  "node_modules/aws-sdk/lib/request.js"() {
    var AWS2 = require_core2();
    var AcceptorStateMachine = require_state_machine();
    var inherit = AWS2.util.inherit;
    var domain = AWS2.util.domain;
    var jmespath = require_jmespath();
    var hardErrorStates = { success: 1, error: 1, complete: 1 };
    function isTerminalState(machine) {
      return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
    }
    var fsm = new AcceptorStateMachine();
    fsm.setupStates = function() {
      var transition = function(_, done) {
        var self2 = this;
        self2._haltHandlersOnError = false;
        self2.emit(self2._asm.currentState, function(err) {
          if (err) {
            if (isTerminalState(self2)) {
              if (domain && self2.domain instanceof domain.Domain) {
                err.domainEmitter = self2;
                err.domain = self2.domain;
                err.domainThrown = false;
                self2.domain.emit("error", err);
              } else {
                throw err;
              }
            } else {
              self2.response.error = err;
              done(err);
            }
          } else {
            done(self2.response.error);
          }
        });
      };
      this.addState("validate", "build", "error", transition);
      this.addState("build", "afterBuild", "restart", transition);
      this.addState("afterBuild", "sign", "restart", transition);
      this.addState("sign", "send", "retry", transition);
      this.addState("retry", "afterRetry", "afterRetry", transition);
      this.addState("afterRetry", "sign", "error", transition);
      this.addState("send", "validateResponse", "retry", transition);
      this.addState("validateResponse", "extractData", "extractError", transition);
      this.addState("extractError", "extractData", "retry", transition);
      this.addState("extractData", "success", "retry", transition);
      this.addState("restart", "build", "error", transition);
      this.addState("success", "complete", "complete", transition);
      this.addState("error", "complete", "complete", transition);
      this.addState("complete", null, null, transition);
    };
    fsm.setupStates();
    AWS2.Request = inherit({
      constructor: function Request2(service, operation, params) {
        var endpoint = service.endpoint;
        var region = service.config.region;
        var customUserAgent = service.config.customUserAgent;
        if (service.signingRegion) {
          region = service.signingRegion;
        } else if (service.isGlobalEndpoint) {
          region = "us-east-1";
        }
        this.domain = domain && domain.active;
        this.service = service;
        this.operation = operation;
        this.params = params || {};
        this.httpRequest = new AWS2.HttpRequest(endpoint, region);
        this.httpRequest.appendToUserAgent(customUserAgent);
        this.startTime = service.getSkewCorrectedDate();
        this.response = new AWS2.Response(this);
        this._asm = new AcceptorStateMachine(fsm.states, "validate");
        this._haltHandlersOnError = false;
        AWS2.SequentialExecutor.call(this);
        this.emit = this.emitEvent;
      },
      send: function send(callback) {
        if (callback) {
          this.httpRequest.appendToUserAgent("callback");
          this.on("complete", function(resp) {
            callback.call(resp, resp.error, resp.data);
          });
        }
        this.runTo();
        return this.response;
      },
      build: function build(callback) {
        return this.runTo("send", callback);
      },
      runTo: function runTo(state, done) {
        this._asm.runTo(state, done, this);
        return this;
      },
      abort: function abort() {
        this.removeAllListeners("validateResponse");
        this.removeAllListeners("extractError");
        this.on("validateResponse", function addAbortedError(resp) {
          resp.error = AWS2.util.error(new Error("Request aborted by user"), {
            code: "RequestAbortedError",
            retryable: false
          });
        });
        if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) {
          this.httpRequest.stream.abort();
          if (this.httpRequest._abortCallback) {
            this.httpRequest._abortCallback();
          } else {
            this.removeAllListeners("send");
          }
        }
        return this;
      },
      eachPage: function eachPage(callback) {
        callback = AWS2.util.fn.makeAsync(callback, 3);
        function wrappedCallback(response) {
          callback.call(response, response.error, response.data, function(result) {
            if (result === false)
              return;
            if (response.hasNextPage()) {
              response.nextPage().on("complete", wrappedCallback).send();
            } else {
              callback.call(response, null, null, AWS2.util.fn.noop);
            }
          });
        }
        this.on("complete", wrappedCallback).send();
      },
      eachItem: function eachItem(callback) {
        var self2 = this;
        function wrappedCallback(err, data) {
          if (err)
            return callback(err, null);
          if (data === null)
            return callback(null, null);
          var config = self2.service.paginationConfig(self2.operation);
          var resultKey = config.resultKey;
          if (Array.isArray(resultKey))
            resultKey = resultKey[0];
          var items = jmespath.search(data, resultKey);
          var continueIteration = true;
          AWS2.util.arrayEach(items, function(item) {
            continueIteration = callback(null, item);
            if (continueIteration === false) {
              return AWS2.util.abort;
            }
          });
          return continueIteration;
        }
        this.eachPage(wrappedCallback);
      },
      isPageable: function isPageable() {
        return this.service.paginationConfig(this.operation) ? true : false;
      },
      createReadStream: function createReadStream3() {
        var streams = AWS2.util.stream;
        var req = this;
        var stream = null;
        if (AWS2.HttpClient.streamsApiVersion === 2) {
          stream = new streams.PassThrough();
          process.nextTick(function() {
            req.send();
          });
        } else {
          stream = new streams.Stream();
          stream.readable = true;
          stream.sent = false;
          stream.on("newListener", function(event) {
            if (!stream.sent && event === "data") {
              stream.sent = true;
              process.nextTick(function() {
                req.send();
              });
            }
          });
        }
        this.on("error", function(err) {
          stream.emit("error", err);
        });
        this.on("httpHeaders", function streamHeaders(statusCode, headers, resp) {
          if (statusCode < 300) {
            req.removeListener("httpData", AWS2.EventListeners.Core.HTTP_DATA);
            req.removeListener("httpError", AWS2.EventListeners.Core.HTTP_ERROR);
            req.on("httpError", function streamHttpError(error2) {
              resp.error = error2;
              resp.error.retryable = false;
            });
            var shouldCheckContentLength = false;
            var expectedLen;
            if (req.httpRequest.method !== "HEAD") {
              expectedLen = parseInt(headers["content-length"], 10);
            }
            if (expectedLen !== void 0 && !isNaN(expectedLen) && expectedLen >= 0) {
              shouldCheckContentLength = true;
              var receivedLen = 0;
            }
            var checkContentLengthAndEmit = function checkContentLengthAndEmit2() {
              if (shouldCheckContentLength && receivedLen !== expectedLen) {
                stream.emit("error", AWS2.util.error(new Error("Stream content length mismatch. Received " + receivedLen + " of " + expectedLen + " bytes."), { code: "StreamContentLengthMismatch" }));
              } else if (AWS2.HttpClient.streamsApiVersion === 2) {
                stream.end();
              } else {
                stream.emit("end");
              }
            };
            var httpStream = resp.httpResponse.createUnbufferedStream();
            if (AWS2.HttpClient.streamsApiVersion === 2) {
              if (shouldCheckContentLength) {
                var lengthAccumulator = new streams.PassThrough();
                lengthAccumulator._write = function(chunk) {
                  if (chunk && chunk.length) {
                    receivedLen += chunk.length;
                  }
                  return streams.PassThrough.prototype._write.apply(this, arguments);
                };
                lengthAccumulator.on("end", checkContentLengthAndEmit);
                stream.on("error", function(err) {
                  shouldCheckContentLength = false;
                  httpStream.unpipe(lengthAccumulator);
                  lengthAccumulator.emit("end");
                  lengthAccumulator.end();
                });
                httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
              } else {
                httpStream.pipe(stream);
              }
            } else {
              if (shouldCheckContentLength) {
                httpStream.on("data", function(arg) {
                  if (arg && arg.length) {
                    receivedLen += arg.length;
                  }
                });
              }
              httpStream.on("data", function(arg) {
                stream.emit("data", arg);
              });
              httpStream.on("end", checkContentLengthAndEmit);
            }
            httpStream.on("error", function(err) {
              shouldCheckContentLength = false;
              stream.emit("error", err);
            });
          }
        });
        return stream;
      },
      emitEvent: function emit(eventName, args, done) {
        if (typeof args === "function") {
          done = args;
          args = null;
        }
        if (!done)
          done = function() {
          };
        if (!args)
          args = this.eventParameters(eventName, this.response);
        var origEmit = AWS2.SequentialExecutor.prototype.emit;
        origEmit.call(this, eventName, args, function(err) {
          if (err)
            this.response.error = err;
          done.call(this, err);
        });
      },
      eventParameters: function eventParameters(eventName) {
        switch (eventName) {
          case "restart":
          case "validate":
          case "sign":
          case "build":
          case "afterValidate":
          case "afterBuild":
            return [this];
          case "error":
            return [this.response.error, this.response];
          default:
            return [this.response];
        }
      },
      presign: function presign(expires, callback) {
        if (!callback && typeof expires === "function") {
          callback = expires;
          expires = null;
        }
        return new AWS2.Signers.Presign().sign(this.toGet(), expires, callback);
      },
      isPresigned: function isPresigned() {
        return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, "presigned-expires");
      },
      toUnauthenticated: function toUnauthenticated() {
        this._unAuthenticated = true;
        this.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_CREDENTIALS);
        this.removeListener("sign", AWS2.EventListeners.Core.SIGN);
        return this;
      },
      toGet: function toGet() {
        if (this.service.api.protocol === "query" || this.service.api.protocol === "ec2") {
          this.removeListener("build", this.buildAsGet);
          this.addListener("build", this.buildAsGet);
        }
        return this;
      },
      buildAsGet: function buildAsGet(request) {
        request.httpRequest.method = "GET";
        request.httpRequest.path = request.service.endpoint.path + "?" + request.httpRequest.body;
        request.httpRequest.body = "";
        delete request.httpRequest.headers["Content-Length"];
        delete request.httpRequest.headers["Content-Type"];
      },
      haltHandlersOnError: function haltHandlersOnError() {
        this._haltHandlersOnError = true;
      }
    });
    AWS2.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.promise = function promise() {
        var self2 = this;
        this.httpRequest.appendToUserAgent("promise");
        return new PromiseDependency(function(resolve2, reject) {
          self2.on("complete", function(resp) {
            if (resp.error) {
              reject(resp.error);
            } else {
              resolve2(Object.defineProperty(resp.data || {}, "$response", { value: resp }));
            }
          });
          self2.runTo();
        });
      };
    };
    AWS2.Request.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.promise;
    };
    AWS2.util.addPromises(AWS2.Request);
    AWS2.util.mixin(AWS2.Request, AWS2.SequentialExecutor);
  }
});

// node_modules/aws-sdk/lib/response.js
var require_response = __commonJS({
  "node_modules/aws-sdk/lib/response.js"() {
    var AWS2 = require_core2();
    var inherit = AWS2.util.inherit;
    var jmespath = require_jmespath();
    AWS2.Response = inherit({
      constructor: function Response2(request) {
        this.request = request;
        this.data = null;
        this.error = null;
        this.retryCount = 0;
        this.redirectCount = 0;
        this.httpResponse = new AWS2.HttpResponse();
        if (request) {
          this.maxRetries = request.service.numRetries();
          this.maxRedirects = request.service.config.maxRedirects;
        }
      },
      nextPage: function nextPage(callback) {
        var config;
        var service = this.request.service;
        var operation = this.request.operation;
        try {
          config = service.paginationConfig(operation, true);
        } catch (e2) {
          this.error = e2;
        }
        if (!this.hasNextPage()) {
          if (callback)
            callback(this.error, null);
          else if (this.error)
            throw this.error;
          return null;
        }
        var params = AWS2.util.copy(this.request.params);
        if (!this.nextPageTokens) {
          return callback ? callback(null, null) : null;
        } else {
          var inputTokens = config.inputToken;
          if (typeof inputTokens === "string")
            inputTokens = [inputTokens];
          for (var i2 = 0; i2 < inputTokens.length; i2++) {
            params[inputTokens[i2]] = this.nextPageTokens[i2];
          }
          return service.makeRequest(this.request.operation, params, callback);
        }
      },
      hasNextPage: function hasNextPage() {
        this.cacheNextPageTokens();
        if (this.nextPageTokens)
          return true;
        if (this.nextPageTokens === void 0)
          return void 0;
        else
          return false;
      },
      cacheNextPageTokens: function cacheNextPageTokens() {
        if (Object.prototype.hasOwnProperty.call(this, "nextPageTokens"))
          return this.nextPageTokens;
        this.nextPageTokens = void 0;
        var config = this.request.service.paginationConfig(this.request.operation);
        if (!config)
          return this.nextPageTokens;
        this.nextPageTokens = null;
        if (config.moreResults) {
          if (!jmespath.search(this.data, config.moreResults)) {
            return this.nextPageTokens;
          }
        }
        var exprs = config.outputToken;
        if (typeof exprs === "string")
          exprs = [exprs];
        AWS2.util.arrayEach.call(this, exprs, function(expr) {
          var output = jmespath.search(this.data, expr);
          if (output) {
            this.nextPageTokens = this.nextPageTokens || [];
            this.nextPageTokens.push(output);
          }
        });
        return this.nextPageTokens;
      }
    });
  }
});

// node_modules/aws-sdk/lib/resource_waiter.js
var require_resource_waiter2 = __commonJS({
  "node_modules/aws-sdk/lib/resource_waiter.js"() {
    var AWS2 = require_core2();
    var inherit = AWS2.util.inherit;
    var jmespath = require_jmespath();
    function CHECK_ACCEPTORS(resp) {
      var waiter = resp.request._waiter;
      var acceptors = waiter.config.acceptors;
      var acceptorMatched = false;
      var state = "retry";
      acceptors.forEach(function(acceptor) {
        if (!acceptorMatched) {
          var matcher = waiter.matchers[acceptor.matcher];
          if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
            acceptorMatched = true;
            state = acceptor.state;
          }
        }
      });
      if (!acceptorMatched && resp.error)
        state = "failure";
      if (state === "success") {
        waiter.setSuccess(resp);
      } else {
        waiter.setError(resp, state === "retry");
      }
    }
    AWS2.ResourceWaiter = inherit({
      constructor: function constructor(service, state) {
        this.service = service;
        this.state = state;
        this.loadWaiterConfig(this.state);
      },
      service: null,
      state: null,
      config: null,
      matchers: {
        path: function(resp, expected, argument) {
          try {
            var result = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          return jmespath.strictDeepEqual(result, expected);
        },
        pathAll: function(resp, expected, argument) {
          try {
            var results = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          if (!Array.isArray(results))
            results = [results];
          var numResults = results.length;
          if (!numResults)
            return false;
          for (var ind = 0; ind < numResults; ind++) {
            if (!jmespath.strictDeepEqual(results[ind], expected)) {
              return false;
            }
          }
          return true;
        },
        pathAny: function(resp, expected, argument) {
          try {
            var results = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          if (!Array.isArray(results))
            results = [results];
          var numResults = results.length;
          for (var ind = 0; ind < numResults; ind++) {
            if (jmespath.strictDeepEqual(results[ind], expected)) {
              return true;
            }
          }
          return false;
        },
        status: function(resp, expected) {
          var statusCode = resp.httpResponse.statusCode;
          return typeof statusCode === "number" && statusCode === expected;
        },
        error: function(resp, expected) {
          if (typeof expected === "string" && resp.error) {
            return expected === resp.error.code;
          }
          return expected === !!resp.error;
        }
      },
      listeners: new AWS2.SequentialExecutor().addNamedListeners(function(add) {
        add("RETRY_CHECK", "retry", function(resp) {
          var waiter = resp.request._waiter;
          if (resp.error && resp.error.code === "ResourceNotReady") {
            resp.error.retryDelay = (waiter.config.delay || 0) * 1e3;
          }
        });
        add("CHECK_OUTPUT", "extractData", CHECK_ACCEPTORS);
        add("CHECK_ERROR", "extractError", CHECK_ACCEPTORS);
      }),
      wait: function wait(params, callback) {
        if (typeof params === "function") {
          callback = params;
          params = void 0;
        }
        if (params && params.$waiter) {
          params = AWS2.util.copy(params);
          if (typeof params.$waiter.delay === "number") {
            this.config.delay = params.$waiter.delay;
          }
          if (typeof params.$waiter.maxAttempts === "number") {
            this.config.maxAttempts = params.$waiter.maxAttempts;
          }
          delete params.$waiter;
        }
        var request = this.service.makeRequest(this.config.operation, params);
        request._waiter = this;
        request.response.maxRetries = this.config.maxAttempts;
        request.addListeners(this.listeners);
        if (callback)
          request.send(callback);
        return request;
      },
      setSuccess: function setSuccess(resp) {
        resp.error = null;
        resp.data = resp.data || {};
        resp.request.removeAllListeners("extractData");
      },
      setError: function setError(resp, retryable) {
        resp.data = null;
        resp.error = AWS2.util.error(resp.error || new Error(), {
          code: "ResourceNotReady",
          message: "Resource is not in the state " + this.state,
          retryable
        });
      },
      loadWaiterConfig: function loadWaiterConfig(state) {
        if (!this.service.api.waiters[state]) {
          throw new AWS2.util.error(new Error(), {
            code: "StateNotFoundError",
            message: "State " + state + " not found."
          });
        }
        this.config = AWS2.util.copy(this.service.api.waiters[state]);
      }
    });
  }
});

// node_modules/aws-sdk/lib/signers/v2.js
var require_v2 = __commonJS({
  "node_modules/aws-sdk/lib/signers/v2.js"(exports, module2) {
    var AWS2 = require_core2();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.V2 = inherit(AWS2.Signers.RequestSigner, {
      addAuthorization: function addAuthorization(credentials, date) {
        if (!date)
          date = AWS2.util.date.getDate();
        var r2 = this.request;
        r2.params.Timestamp = AWS2.util.date.iso8601(date);
        r2.params.SignatureVersion = "2";
        r2.params.SignatureMethod = "HmacSHA256";
        r2.params.AWSAccessKeyId = credentials.accessKeyId;
        if (credentials.sessionToken) {
          r2.params.SecurityToken = credentials.sessionToken;
        }
        delete r2.params.Signature;
        r2.params.Signature = this.signature(credentials);
        r2.body = AWS2.util.queryParamsToString(r2.params);
        r2.headers["Content-Length"] = r2.body.length;
      },
      signature: function signature(credentials) {
        return AWS2.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), "base64");
      },
      stringToSign: function stringToSign() {
        var parts = [];
        parts.push(this.request.method);
        parts.push(this.request.endpoint.host.toLowerCase());
        parts.push(this.request.pathname());
        parts.push(AWS2.util.queryParamsToString(this.request.params));
        return parts.join("\n");
      }
    });
    module2.exports = AWS2.Signers.V2;
  }
});

// node_modules/aws-sdk/lib/signers/v3.js
var require_v3 = __commonJS({
  "node_modules/aws-sdk/lib/signers/v3.js"(exports, module2) {
    var AWS2 = require_core2();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.V3 = inherit(AWS2.Signers.RequestSigner, {
      addAuthorization: function addAuthorization(credentials, date) {
        var datetime = AWS2.util.date.rfc822(date);
        this.request.headers["X-Amz-Date"] = datetime;
        if (credentials.sessionToken) {
          this.request.headers["x-amz-security-token"] = credentials.sessionToken;
        }
        this.request.headers["X-Amzn-Authorization"] = this.authorization(credentials, datetime);
      },
      authorization: function authorization(credentials) {
        return "AWS3 AWSAccessKeyId=" + credentials.accessKeyId + ",Algorithm=HmacSHA256,SignedHeaders=" + this.signedHeaders() + ",Signature=" + this.signature(credentials);
      },
      signedHeaders: function signedHeaders() {
        var headers = [];
        AWS2.util.arrayEach(this.headersToSign(), function iterator(h2) {
          headers.push(h2.toLowerCase());
        });
        return headers.sort().join(";");
      },
      canonicalHeaders: function canonicalHeaders() {
        var headers = this.request.headers;
        var parts = [];
        AWS2.util.arrayEach(this.headersToSign(), function iterator(h2) {
          parts.push(h2.toLowerCase().trim() + ":" + String(headers[h2]).trim());
        });
        return parts.sort().join("\n") + "\n";
      },
      headersToSign: function headersToSign() {
        var headers = [];
        AWS2.util.each(this.request.headers, function iterator(k) {
          if (k === "Host" || k === "Content-Encoding" || k.match(/^X-Amz/i)) {
            headers.push(k);
          }
        });
        return headers;
      },
      signature: function signature(credentials) {
        return AWS2.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), "base64");
      },
      stringToSign: function stringToSign() {
        var parts = [];
        parts.push(this.request.method);
        parts.push("/");
        parts.push("");
        parts.push(this.canonicalHeaders());
        parts.push(this.request.body);
        return AWS2.util.crypto.sha256(parts.join("\n"));
      }
    });
    module2.exports = AWS2.Signers.V3;
  }
});

// node_modules/aws-sdk/lib/signers/v3https.js
var require_v3https = __commonJS({
  "node_modules/aws-sdk/lib/signers/v3https.js"(exports, module2) {
    var AWS2 = require_core2();
    var inherit = AWS2.util.inherit;
    require_v3();
    AWS2.Signers.V3Https = inherit(AWS2.Signers.V3, {
      authorization: function authorization(credentials) {
        return "AWS3-HTTPS AWSAccessKeyId=" + credentials.accessKeyId + ",Algorithm=HmacSHA256,Signature=" + this.signature(credentials);
      },
      stringToSign: function stringToSign() {
        return this.request.headers["X-Amz-Date"];
      }
    });
    module2.exports = AWS2.Signers.V3Https;
  }
});

// node_modules/aws-sdk/lib/signers/v4_credentials.js
var require_v4_credentials = __commonJS({
  "node_modules/aws-sdk/lib/signers/v4_credentials.js"(exports, module2) {
    var AWS2 = require_core2();
    var cachedSecret = {};
    var cacheQueue = [];
    var maxCacheEntries = 50;
    var v4Identifier = "aws4_request";
    module2.exports = {
      createScope: function createScope(date, region, serviceName) {
        return [
          date.substr(0, 8),
          region,
          serviceName,
          v4Identifier
        ].join("/");
      },
      getSigningKey: function getSigningKey(credentials, date, region, service, shouldCache) {
        var credsIdentifier = AWS2.util.crypto.hmac(credentials.secretAccessKey, credentials.accessKeyId, "base64");
        var cacheKey = [credsIdentifier, date, region, service].join("_");
        shouldCache = shouldCache !== false;
        if (shouldCache && cacheKey in cachedSecret) {
          return cachedSecret[cacheKey];
        }
        var kDate = AWS2.util.crypto.hmac("AWS4" + credentials.secretAccessKey, date, "buffer");
        var kRegion = AWS2.util.crypto.hmac(kDate, region, "buffer");
        var kService = AWS2.util.crypto.hmac(kRegion, service, "buffer");
        var signingKey = AWS2.util.crypto.hmac(kService, v4Identifier, "buffer");
        if (shouldCache) {
          cachedSecret[cacheKey] = signingKey;
          cacheQueue.push(cacheKey);
          if (cacheQueue.length > maxCacheEntries) {
            delete cachedSecret[cacheQueue.shift()];
          }
        }
        return signingKey;
      },
      emptyCache: function emptyCache() {
        cachedSecret = {};
        cacheQueue = [];
      }
    };
  }
});

// node_modules/aws-sdk/lib/signers/v4.js
var require_v4 = __commonJS({
  "node_modules/aws-sdk/lib/signers/v4.js"(exports, module2) {
    var AWS2 = require_core2();
    var v4Credentials = require_v4_credentials();
    var inherit = AWS2.util.inherit;
    var expiresHeader = "presigned-expires";
    AWS2.Signers.V4 = inherit(AWS2.Signers.RequestSigner, {
      constructor: function V4(request, serviceName, options) {
        AWS2.Signers.RequestSigner.call(this, request);
        this.serviceName = serviceName;
        options = options || {};
        this.signatureCache = typeof options.signatureCache === "boolean" ? options.signatureCache : true;
        this.operation = options.operation;
        this.signatureVersion = options.signatureVersion;
      },
      algorithm: "AWS4-HMAC-SHA256",
      addAuthorization: function addAuthorization(credentials, date) {
        var datetime = AWS2.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, "");
        if (this.isPresigned()) {
          this.updateForPresigned(credentials, datetime);
        } else {
          this.addHeaders(credentials, datetime);
        }
        this.request.headers["Authorization"] = this.authorization(credentials, datetime);
      },
      addHeaders: function addHeaders(credentials, datetime) {
        this.request.headers["X-Amz-Date"] = datetime;
        if (credentials.sessionToken) {
          this.request.headers["x-amz-security-token"] = credentials.sessionToken;
        }
      },
      updateForPresigned: function updateForPresigned(credentials, datetime) {
        var credString = this.credentialString(datetime);
        var qs = {
          "X-Amz-Date": datetime,
          "X-Amz-Algorithm": this.algorithm,
          "X-Amz-Credential": credentials.accessKeyId + "/" + credString,
          "X-Amz-Expires": this.request.headers[expiresHeader],
          "X-Amz-SignedHeaders": this.signedHeaders()
        };
        if (credentials.sessionToken) {
          qs["X-Amz-Security-Token"] = credentials.sessionToken;
        }
        if (this.request.headers["Content-Type"]) {
          qs["Content-Type"] = this.request.headers["Content-Type"];
        }
        if (this.request.headers["Content-MD5"]) {
          qs["Content-MD5"] = this.request.headers["Content-MD5"];
        }
        if (this.request.headers["Cache-Control"]) {
          qs["Cache-Control"] = this.request.headers["Cache-Control"];
        }
        AWS2.util.each.call(this, this.request.headers, function(key, value) {
          if (key === expiresHeader)
            return;
          if (this.isSignableHeader(key)) {
            var lowerKey = key.toLowerCase();
            if (lowerKey.indexOf("x-amz-meta-") === 0) {
              qs[lowerKey] = value;
            } else if (lowerKey.indexOf("x-amz-") === 0) {
              qs[key] = value;
            }
          }
        });
        var sep = this.request.path.indexOf("?") >= 0 ? "&" : "?";
        this.request.path += sep + AWS2.util.queryParamsToString(qs);
      },
      authorization: function authorization(credentials, datetime) {
        var parts = [];
        var credString = this.credentialString(datetime);
        parts.push(this.algorithm + " Credential=" + credentials.accessKeyId + "/" + credString);
        parts.push("SignedHeaders=" + this.signedHeaders());
        parts.push("Signature=" + this.signature(credentials, datetime));
        return parts.join(", ");
      },
      signature: function signature(credentials, datetime) {
        var signingKey = v4Credentials.getSigningKey(credentials, datetime.substr(0, 8), this.request.region, this.serviceName, this.signatureCache);
        return AWS2.util.crypto.hmac(signingKey, this.stringToSign(datetime), "hex");
      },
      stringToSign: function stringToSign(datetime) {
        var parts = [];
        parts.push("AWS4-HMAC-SHA256");
        parts.push(datetime);
        parts.push(this.credentialString(datetime));
        parts.push(this.hexEncodedHash(this.canonicalString()));
        return parts.join("\n");
      },
      canonicalString: function canonicalString() {
        var parts = [], pathname = this.request.pathname();
        if (this.serviceName !== "s3" && this.signatureVersion !== "s3v4")
          pathname = AWS2.util.uriEscapePath(pathname);
        parts.push(this.request.method);
        parts.push(pathname);
        parts.push(this.request.search());
        parts.push(this.canonicalHeaders() + "\n");
        parts.push(this.signedHeaders());
        parts.push(this.hexEncodedBodyHash());
        return parts.join("\n");
      },
      canonicalHeaders: function canonicalHeaders() {
        var headers = [];
        AWS2.util.each.call(this, this.request.headers, function(key, item) {
          headers.push([key, item]);
        });
        headers.sort(function(a, b) {
          return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
        });
        var parts = [];
        AWS2.util.arrayEach.call(this, headers, function(item) {
          var key = item[0].toLowerCase();
          if (this.isSignableHeader(key)) {
            var value = item[1];
            if (typeof value === "undefined" || value === null || typeof value.toString !== "function") {
              throw AWS2.util.error(new Error("Header " + key + " contains invalid value"), {
                code: "InvalidHeader"
              });
            }
            parts.push(key + ":" + this.canonicalHeaderValues(value.toString()));
          }
        });
        return parts.join("\n");
      },
      canonicalHeaderValues: function canonicalHeaderValues(values) {
        return values.replace(/\s+/g, " ").replace(/^\s+|\s+$/g, "");
      },
      signedHeaders: function signedHeaders() {
        var keys = [];
        AWS2.util.each.call(this, this.request.headers, function(key) {
          key = key.toLowerCase();
          if (this.isSignableHeader(key))
            keys.push(key);
        });
        return keys.sort().join(";");
      },
      credentialString: function credentialString(datetime) {
        return v4Credentials.createScope(datetime.substr(0, 8), this.request.region, this.serviceName);
      },
      hexEncodedHash: function hash(string) {
        return AWS2.util.crypto.sha256(string, "hex");
      },
      hexEncodedBodyHash: function hexEncodedBodyHash() {
        var request = this.request;
        if (this.isPresigned() && ["s3", "s3-object-lambda"].indexOf(this.serviceName) > -1 && !request.body) {
          return "UNSIGNED-PAYLOAD";
        } else if (request.headers["X-Amz-Content-Sha256"]) {
          return request.headers["X-Amz-Content-Sha256"];
        } else {
          return this.hexEncodedHash(this.request.body || "");
        }
      },
      unsignableHeaders: [
        "authorization",
        "content-type",
        "content-length",
        "user-agent",
        expiresHeader,
        "expect",
        "x-amzn-trace-id"
      ],
      isSignableHeader: function isSignableHeader(key) {
        if (key.toLowerCase().indexOf("x-amz-") === 0)
          return true;
        return this.unsignableHeaders.indexOf(key) < 0;
      },
      isPresigned: function isPresigned() {
        return this.request.headers[expiresHeader] ? true : false;
      }
    });
    module2.exports = AWS2.Signers.V4;
  }
});

// node_modules/aws-sdk/lib/signers/s3.js
var require_s3 = __commonJS({
  "node_modules/aws-sdk/lib/signers/s3.js"(exports, module2) {
    var AWS2 = require_core2();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.S3 = inherit(AWS2.Signers.RequestSigner, {
      subResources: {
        "acl": 1,
        "accelerate": 1,
        "analytics": 1,
        "cors": 1,
        "lifecycle": 1,
        "delete": 1,
        "inventory": 1,
        "location": 1,
        "logging": 1,
        "metrics": 1,
        "notification": 1,
        "partNumber": 1,
        "policy": 1,
        "requestPayment": 1,
        "replication": 1,
        "restore": 1,
        "tagging": 1,
        "torrent": 1,
        "uploadId": 1,
        "uploads": 1,
        "versionId": 1,
        "versioning": 1,
        "versions": 1,
        "website": 1
      },
      responseHeaders: {
        "response-content-type": 1,
        "response-content-language": 1,
        "response-expires": 1,
        "response-cache-control": 1,
        "response-content-disposition": 1,
        "response-content-encoding": 1
      },
      addAuthorization: function addAuthorization(credentials, date) {
        if (!this.request.headers["presigned-expires"]) {
          this.request.headers["X-Amz-Date"] = AWS2.util.date.rfc822(date);
        }
        if (credentials.sessionToken) {
          this.request.headers["x-amz-security-token"] = credentials.sessionToken;
        }
        var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
        var auth = "AWS " + credentials.accessKeyId + ":" + signature;
        this.request.headers["Authorization"] = auth;
      },
      stringToSign: function stringToSign() {
        var r2 = this.request;
        var parts = [];
        parts.push(r2.method);
        parts.push(r2.headers["Content-MD5"] || "");
        parts.push(r2.headers["Content-Type"] || "");
        parts.push(r2.headers["presigned-expires"] || "");
        var headers = this.canonicalizedAmzHeaders();
        if (headers)
          parts.push(headers);
        parts.push(this.canonicalizedResource());
        return parts.join("\n");
      },
      canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {
        var amzHeaders = [];
        AWS2.util.each(this.request.headers, function(name) {
          if (name.match(/^x-amz-/i))
            amzHeaders.push(name);
        });
        amzHeaders.sort(function(a, b) {
          return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
        });
        var parts = [];
        AWS2.util.arrayEach.call(this, amzHeaders, function(name) {
          parts.push(name.toLowerCase() + ":" + String(this.request.headers[name]));
        });
        return parts.join("\n");
      },
      canonicalizedResource: function canonicalizedResource() {
        var r2 = this.request;
        var parts = r2.path.split("?");
        var path8 = parts[0];
        var querystring = parts[1];
        var resource = "";
        if (r2.virtualHostedBucket)
          resource += "/" + r2.virtualHostedBucket;
        resource += path8;
        if (querystring) {
          var resources = [];
          AWS2.util.arrayEach.call(this, querystring.split("&"), function(param) {
            var name = param.split("=")[0];
            var value = param.split("=")[1];
            if (this.subResources[name] || this.responseHeaders[name]) {
              var subresource = { name };
              if (value !== void 0) {
                if (this.subResources[name]) {
                  subresource.value = value;
                } else {
                  subresource.value = decodeURIComponent(value);
                }
              }
              resources.push(subresource);
            }
          });
          resources.sort(function(a, b) {
            return a.name < b.name ? -1 : 1;
          });
          if (resources.length) {
            querystring = [];
            AWS2.util.arrayEach(resources, function(res) {
              if (res.value === void 0) {
                querystring.push(res.name);
              } else {
                querystring.push(res.name + "=" + res.value);
              }
            });
            resource += "?" + querystring.join("&");
          }
        }
        return resource;
      },
      sign: function sign(secret, string) {
        return AWS2.util.crypto.hmac(secret, string, "base64", "sha1");
      }
    });
    module2.exports = AWS2.Signers.S3;
  }
});

// node_modules/aws-sdk/lib/signers/presign.js
var require_presign = __commonJS({
  "node_modules/aws-sdk/lib/signers/presign.js"(exports, module2) {
    var AWS2 = require_core2();
    var inherit = AWS2.util.inherit;
    var expiresHeader = "presigned-expires";
    function signedUrlBuilder(request) {
      var expires = request.httpRequest.headers[expiresHeader];
      var signerClass = request.service.getSignerClass(request);
      delete request.httpRequest.headers["User-Agent"];
      delete request.httpRequest.headers["X-Amz-User-Agent"];
      if (signerClass === AWS2.Signers.V4) {
        if (expires > 604800) {
          var message = "Presigning does not support expiry time greater than a week with SigV4 signing.";
          throw AWS2.util.error(new Error(), {
            code: "InvalidExpiryTime",
            message,
            retryable: false
          });
        }
        request.httpRequest.headers[expiresHeader] = expires;
      } else if (signerClass === AWS2.Signers.S3) {
        var now = request.service ? request.service.getSkewCorrectedDate() : AWS2.util.date.getDate();
        request.httpRequest.headers[expiresHeader] = parseInt(AWS2.util.date.unixTimestamp(now) + expires, 10).toString();
      } else {
        throw AWS2.util.error(new Error(), {
          message: "Presigning only supports S3 or SigV4 signing.",
          code: "UnsupportedSigner",
          retryable: false
        });
      }
    }
    function signedUrlSigner(request) {
      var endpoint = request.httpRequest.endpoint;
      var parsedUrl = AWS2.util.urlParse(request.httpRequest.path);
      var queryParams = {};
      if (parsedUrl.search) {
        queryParams = AWS2.util.queryStringParse(parsedUrl.search.substr(1));
      }
      var auth = request.httpRequest.headers["Authorization"].split(" ");
      if (auth[0] === "AWS") {
        auth = auth[1].split(":");
        queryParams["Signature"] = auth.pop();
        queryParams["AWSAccessKeyId"] = auth.join(":");
        AWS2.util.each(request.httpRequest.headers, function(key, value) {
          if (key === expiresHeader)
            key = "Expires";
          if (key.indexOf("x-amz-meta-") === 0) {
            delete queryParams[key];
            key = key.toLowerCase();
          }
          queryParams[key] = value;
        });
        delete request.httpRequest.headers[expiresHeader];
        delete queryParams["Authorization"];
        delete queryParams["Host"];
      } else if (auth[0] === "AWS4-HMAC-SHA256") {
        auth.shift();
        var rest = auth.join(" ");
        var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
        queryParams["X-Amz-Signature"] = signature;
        delete queryParams["Expires"];
      }
      endpoint.pathname = parsedUrl.pathname;
      endpoint.search = AWS2.util.queryParamsToString(queryParams);
    }
    AWS2.Signers.Presign = inherit({
      sign: function sign(request, expireTime, callback) {
        request.httpRequest.headers[expiresHeader] = expireTime || 3600;
        request.on("build", signedUrlBuilder);
        request.on("sign", signedUrlSigner);
        request.removeListener("afterBuild", AWS2.EventListeners.Core.SET_CONTENT_LENGTH);
        request.removeListener("afterBuild", AWS2.EventListeners.Core.COMPUTE_SHA256);
        request.emit("beforePresign", [request]);
        if (callback) {
          request.build(function() {
            if (this.response.error)
              callback(this.response.error);
            else {
              callback(null, AWS2.util.urlFormat(request.httpRequest.endpoint));
            }
          });
        } else {
          request.build();
          if (request.response.error)
            throw request.response.error;
          return AWS2.util.urlFormat(request.httpRequest.endpoint);
        }
      }
    });
    module2.exports = AWS2.Signers.Presign;
  }
});

// node_modules/aws-sdk/lib/signers/request_signer.js
var require_request_signer = __commonJS({
  "node_modules/aws-sdk/lib/signers/request_signer.js"() {
    var AWS2 = require_core2();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.RequestSigner = inherit({
      constructor: function RequestSigner(request) {
        this.request = request;
      },
      setServiceClientId: function setServiceClientId(id) {
        this.serviceClientId = id;
      },
      getServiceClientId: function getServiceClientId() {
        return this.serviceClientId;
      }
    });
    AWS2.Signers.RequestSigner.getVersion = function getVersion(version2) {
      switch (version2) {
        case "v2":
          return AWS2.Signers.V2;
        case "v3":
          return AWS2.Signers.V3;
        case "s3v4":
          return AWS2.Signers.V4;
        case "v4":
          return AWS2.Signers.V4;
        case "s3":
          return AWS2.Signers.S3;
        case "v3https":
          return AWS2.Signers.V3Https;
      }
      throw new Error("Unknown signing version " + version2);
    };
    require_v2();
    require_v3();
    require_v3https();
    require_v4();
    require_s3();
    require_presign();
  }
});

// node_modules/aws-sdk/lib/param_validator.js
var require_param_validator = __commonJS({
  "node_modules/aws-sdk/lib/param_validator.js"() {
    var AWS2 = require_core2();
    AWS2.ParamValidator = AWS2.util.inherit({
      constructor: function ParamValidator(validation) {
        if (validation === true || validation === void 0) {
          validation = { "min": true };
        }
        this.validation = validation;
      },
      validate: function validate2(shape, params, context2) {
        this.errors = [];
        this.validateMember(shape, params || {}, context2 || "params");
        if (this.errors.length > 1) {
          var msg = this.errors.join("\n* ");
          msg = "There were " + this.errors.length + " validation errors:\n* " + msg;
          throw AWS2.util.error(new Error(msg), { code: "MultipleValidationErrors", errors: this.errors });
        } else if (this.errors.length === 1) {
          throw this.errors[0];
        } else {
          return true;
        }
      },
      fail: function fail(code, message) {
        this.errors.push(AWS2.util.error(new Error(message), { code }));
      },
      validateStructure: function validateStructure(shape, params, context2) {
        if (shape.isDocument)
          return true;
        this.validateType(params, context2, ["object"], "structure");
        var paramName;
        for (var i2 = 0; shape.required && i2 < shape.required.length; i2++) {
          paramName = shape.required[i2];
          var value = params[paramName];
          if (value === void 0 || value === null) {
            this.fail("MissingRequiredParameter", "Missing required key '" + paramName + "' in " + context2);
          }
        }
        for (paramName in params) {
          if (!Object.prototype.hasOwnProperty.call(params, paramName))
            continue;
          var paramValue = params[paramName], memberShape = shape.members[paramName];
          if (memberShape !== void 0) {
            var memberContext = [context2, paramName].join(".");
            this.validateMember(memberShape, paramValue, memberContext);
          } else if (paramValue !== void 0 && paramValue !== null) {
            this.fail("UnexpectedParameter", "Unexpected key '" + paramName + "' found in " + context2);
          }
        }
        return true;
      },
      validateMember: function validateMember(shape, param, context2) {
        switch (shape.type) {
          case "structure":
            return this.validateStructure(shape, param, context2);
          case "list":
            return this.validateList(shape, param, context2);
          case "map":
            return this.validateMap(shape, param, context2);
          default:
            return this.validateScalar(shape, param, context2);
        }
      },
      validateList: function validateList(shape, params, context2) {
        if (this.validateType(params, context2, [Array])) {
          this.validateRange(shape, params.length, context2, "list member count");
          for (var i2 = 0; i2 < params.length; i2++) {
            this.validateMember(shape.member, params[i2], context2 + "[" + i2 + "]");
          }
        }
      },
      validateMap: function validateMap(shape, params, context2) {
        if (this.validateType(params, context2, ["object"], "map")) {
          var mapCount = 0;
          for (var param in params) {
            if (!Object.prototype.hasOwnProperty.call(params, param))
              continue;
            this.validateMember(shape.key, param, context2 + "[key='" + param + "']");
            this.validateMember(shape.value, params[param], context2 + "['" + param + "']");
            mapCount++;
          }
          this.validateRange(shape, mapCount, context2, "map member count");
        }
      },
      validateScalar: function validateScalar(shape, value, context2) {
        switch (shape.type) {
          case null:
          case void 0:
          case "string":
            return this.validateString(shape, value, context2);
          case "base64":
          case "binary":
            return this.validatePayload(value, context2);
          case "integer":
          case "float":
            return this.validateNumber(shape, value, context2);
          case "boolean":
            return this.validateType(value, context2, ["boolean"]);
          case "timestamp":
            return this.validateType(value, context2, [
              Date,
              /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/,
              "number"
            ], "Date object, ISO-8601 string, or a UNIX timestamp");
          default:
            return this.fail("UnkownType", "Unhandled type " + shape.type + " for " + context2);
        }
      },
      validateString: function validateString(shape, value, context2) {
        var validTypes = ["string"];
        if (shape.isJsonValue) {
          validTypes = validTypes.concat(["number", "object", "boolean"]);
        }
        if (value !== null && this.validateType(value, context2, validTypes)) {
          this.validateEnum(shape, value, context2);
          this.validateRange(shape, value.length, context2, "string length");
          this.validatePattern(shape, value, context2);
          this.validateUri(shape, value, context2);
        }
      },
      validateUri: function validateUri(shape, value, context2) {
        if (shape["location"] === "uri") {
          if (value.length === 0) {
            this.fail("UriParameterError", 'Expected uri parameter to have length >= 1, but found "' + value + '" for ' + context2);
          }
        }
      },
      validatePattern: function validatePattern(shape, value, context2) {
        if (this.validation["pattern"] && shape["pattern"] !== void 0) {
          if (!new RegExp(shape["pattern"]).test(value)) {
            this.fail("PatternMatchError", 'Provided value "' + value + '" does not match regex pattern /' + shape["pattern"] + "/ for " + context2);
          }
        }
      },
      validateRange: function validateRange(shape, value, context2, descriptor) {
        if (this.validation["min"]) {
          if (shape["min"] !== void 0 && value < shape["min"]) {
            this.fail("MinRangeError", "Expected " + descriptor + " >= " + shape["min"] + ", but found " + value + " for " + context2);
          }
        }
        if (this.validation["max"]) {
          if (shape["max"] !== void 0 && value > shape["max"]) {
            this.fail("MaxRangeError", "Expected " + descriptor + " <= " + shape["max"] + ", but found " + value + " for " + context2);
          }
        }
      },
      validateEnum: function validateRange(shape, value, context2) {
        if (this.validation["enum"] && shape["enum"] !== void 0) {
          if (shape["enum"].indexOf(value) === -1) {
            this.fail("EnumError", "Found string value of " + value + ", but expected " + shape["enum"].join("|") + " for " + context2);
          }
        }
      },
      validateType: function validateType(value, context2, acceptedTypes, type) {
        if (value === null || value === void 0)
          return false;
        var foundInvalidType = false;
        for (var i2 = 0; i2 < acceptedTypes.length; i2++) {
          if (typeof acceptedTypes[i2] === "string") {
            if (typeof value === acceptedTypes[i2])
              return true;
          } else if (acceptedTypes[i2] instanceof RegExp) {
            if ((value || "").toString().match(acceptedTypes[i2]))
              return true;
          } else {
            if (value instanceof acceptedTypes[i2])
              return true;
            if (AWS2.util.isType(value, acceptedTypes[i2]))
              return true;
            if (!type && !foundInvalidType)
              acceptedTypes = acceptedTypes.slice();
            acceptedTypes[i2] = AWS2.util.typeName(acceptedTypes[i2]);
          }
          foundInvalidType = true;
        }
        var acceptedType = type;
        if (!acceptedType) {
          acceptedType = acceptedTypes.join(", ").replace(/,([^,]+)$/, ", or$1");
        }
        var vowel = acceptedType.match(/^[aeiou]/i) ? "n" : "";
        this.fail("InvalidParameterType", "Expected " + context2 + " to be a" + vowel + " " + acceptedType);
        return false;
      },
      validateNumber: function validateNumber(shape, value, context2) {
        if (value === null || value === void 0)
          return;
        if (typeof value === "string") {
          var castedValue = parseFloat(value);
          if (castedValue.toString() === value)
            value = castedValue;
        }
        if (this.validateType(value, context2, ["number"])) {
          this.validateRange(shape, value, context2, "numeric value");
        }
      },
      validatePayload: function validatePayload(value, context2) {
        if (value === null || value === void 0)
          return;
        if (typeof value === "string")
          return;
        if (value && typeof value.byteLength === "number")
          return;
        if (AWS2.util.isNode()) {
          var Stream3 = AWS2.util.stream.Stream;
          if (AWS2.util.Buffer.isBuffer(value) || value instanceof Stream3)
            return;
        } else {
          if (typeof Blob !== void 0 && value instanceof Blob)
            return;
        }
        var types3 = ["Buffer", "Stream", "File", "Blob", "ArrayBuffer", "DataView"];
        if (value) {
          for (var i2 = 0; i2 < types3.length; i2++) {
            if (AWS2.util.isType(value, types3[i2]))
              return;
            if (AWS2.util.typeName(value.constructor) === types3[i2])
              return;
          }
        }
        this.fail("InvalidParameterType", "Expected " + context2 + " to be a string, Buffer, Stream, Blob, or typed array object");
      }
    });
  }
});

// node_modules/aws-sdk/lib/core.js
var require_core2 = __commonJS({
  "node_modules/aws-sdk/lib/core.js"(exports, module2) {
    var AWS2 = { util: require_util() };
    var _hidden = {};
    _hidden.toString();
    module2.exports = AWS2;
    AWS2.util.update(AWS2, {
      VERSION: "2.1141.0",
      Signers: {},
      Protocol: {
        Json: require_json(),
        Query: require_query(),
        Rest: require_rest(),
        RestJson: require_rest_json(),
        RestXml: require_rest_xml()
      },
      XML: {
        Builder: require_builder2(),
        Parser: null
      },
      JSON: {
        Builder: require_builder(),
        Parser: require_parser()
      },
      Model: {
        Api: require_api(),
        Operation: require_operation(),
        Shape: require_shape(),
        Paginator: require_paginator(),
        ResourceWaiter: require_resource_waiter()
      },
      apiLoader: require_api_loader(),
      EndpointCache: require_endpoint_cache().EndpointCache
    });
    require_sequential_executor();
    require_service();
    require_config();
    require_http();
    require_event_listeners();
    require_request();
    require_response();
    require_resource_waiter2();
    require_request_signer();
    require_param_validator();
    AWS2.events = new AWS2.SequentialExecutor();
    AWS2.util.memoizedProperty(AWS2, "endpointCache", function() {
      return new AWS2.EndpointCache(AWS2.config.endpointCacheSize);
    }, true);
  }
});

// node_modules/aws-sdk/node_modules/uuid/lib/rng.js
var require_rng = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/lib/rng.js"(exports, module2) {
    var crypto = require("crypto");
    module2.exports = function nodeRNG() {
      return crypto.randomBytes(16);
    };
  }
});

// node_modules/aws-sdk/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/lib/bytesToUuid.js"(exports, module2) {
    var byteToHex = [];
    for (i2 = 0; i2 < 256; ++i2) {
      byteToHex[i2] = (i2 + 256).toString(16).substr(1);
    }
    var i2;
    function bytesToUuid(buf, offset) {
      var i3 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]],
        "-",
        bth[buf[i3++]],
        bth[buf[i3++]],
        "-",
        bth[buf[i3++]],
        bth[buf[i3++]],
        "-",
        bth[buf[i3++]],
        bth[buf[i3++]],
        "-",
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]]
      ].join("");
    }
    module2.exports = bytesToUuid;
  }
});

// node_modules/aws-sdk/node_modules/uuid/v1.js
var require_v1 = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/v1.js"(exports, module2) {
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v12(options, buf, offset) {
      var i2 = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i2++] = tl >>> 24 & 255;
      b[i2++] = tl >>> 16 & 255;
      b[i2++] = tl >>> 8 & 255;
      b[i2++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i2++] = tmh >>> 8 & 255;
      b[i2++] = tmh & 255;
      b[i2++] = tmh >>> 24 & 15 | 16;
      b[i2++] = tmh >>> 16 & 255;
      b[i2++] = clockseq >>> 8 | 128;
      b[i2++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i2 + n] = node[n];
      }
      return buf ? buf : bytesToUuid(b);
    }
    module2.exports = v12;
  }
});

// node_modules/aws-sdk/node_modules/uuid/v4.js
var require_v42 = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/v4.js"(exports, module2) {
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    function v42(options, buf, offset) {
      var i2 = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i2 + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module2.exports = v42;
  }
});

// node_modules/aws-sdk/node_modules/uuid/index.js
var require_uuid = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/index.js"(exports, module2) {
    var v12 = require_v1();
    var v42 = require_v42();
    var uuid2 = v42;
    uuid2.v1 = v12;
    uuid2.v4 = v42;
    module2.exports = uuid2;
  }
});

// node_modules/aws-sdk/lib/util.js
var require_util = __commonJS({
  "node_modules/aws-sdk/lib/util.js"(exports, module2) {
    var AWS2;
    var util = {
      environment: "nodejs",
      engine: function engine() {
        if (util.isBrowser() && typeof navigator !== "undefined") {
          return navigator.userAgent;
        } else {
          var engine2 = process.platform + "/" + process.version;
          if (process.env.AWS_EXECUTION_ENV) {
            engine2 += " exec-env/" + process.env.AWS_EXECUTION_ENV;
          }
          return engine2;
        }
      },
      userAgent: function userAgent() {
        var name = util.environment;
        var agent = "aws-sdk-" + name + "/" + require_core2().VERSION;
        if (name === "nodejs")
          agent += " " + util.engine();
        return agent;
      },
      uriEscape: function uriEscape(string) {
        var output = encodeURIComponent(string);
        output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);
        output = output.replace(/[*]/g, function(ch) {
          return "%" + ch.charCodeAt(0).toString(16).toUpperCase();
        });
        return output;
      },
      uriEscapePath: function uriEscapePath(string) {
        var parts = [];
        util.arrayEach(string.split("/"), function(part) {
          parts.push(util.uriEscape(part));
        });
        return parts.join("/");
      },
      urlParse: function urlParse(url) {
        return util.url.parse(url);
      },
      urlFormat: function urlFormat(url) {
        return util.url.format(url);
      },
      queryStringParse: function queryStringParse(qs) {
        return util.querystring.parse(qs);
      },
      queryParamsToString: function queryParamsToString(params) {
        var items = [];
        var escape2 = util.uriEscape;
        var sortedKeys = Object.keys(params).sort();
        util.arrayEach(sortedKeys, function(name) {
          var value = params[name];
          var ename = escape2(name);
          var result = ename + "=";
          if (Array.isArray(value)) {
            var vals = [];
            util.arrayEach(value, function(item) {
              vals.push(escape2(item));
            });
            result = ename + "=" + vals.sort().join("&" + ename + "=");
          } else if (value !== void 0 && value !== null) {
            result = ename + "=" + escape2(value);
          }
          items.push(result);
        });
        return items.join("&");
      },
      readFileSync: function readFileSync(path8) {
        if (util.isBrowser())
          return null;
        return require("fs").readFileSync(path8, "utf-8");
      },
      base64: {
        encode: function encode64(string) {
          if (typeof string === "number") {
            throw util.error(new Error("Cannot base64 encode number " + string));
          }
          if (string === null || typeof string === "undefined") {
            return string;
          }
          var buf = util.buffer.toBuffer(string);
          return buf.toString("base64");
        },
        decode: function decode64(string) {
          if (typeof string === "number") {
            throw util.error(new Error("Cannot base64 decode number " + string));
          }
          if (string === null || typeof string === "undefined") {
            return string;
          }
          return util.buffer.toBuffer(string, "base64");
        }
      },
      buffer: {
        toBuffer: function(data, encoding) {
          return typeof util.Buffer.from === "function" && util.Buffer.from !== Uint8Array.from ? util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);
        },
        alloc: function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new Error("size passed to alloc must be a number.");
          }
          if (typeof util.Buffer.alloc === "function") {
            return util.Buffer.alloc(size, fill, encoding);
          } else {
            var buf = new util.Buffer(size);
            if (fill !== void 0 && typeof buf.fill === "function") {
              buf.fill(fill, void 0, void 0, encoding);
            }
            return buf;
          }
        },
        toStream: function toStream(buffer) {
          if (!util.Buffer.isBuffer(buffer))
            buffer = util.buffer.toBuffer(buffer);
          var readable = new util.stream.Readable();
          var pos = 0;
          readable._read = function(size) {
            if (pos >= buffer.length)
              return readable.push(null);
            var end = pos + size;
            if (end > buffer.length)
              end = buffer.length;
            readable.push(buffer.slice(pos, end));
            pos = end;
          };
          return readable;
        },
        concat: function(buffers) {
          var length = 0, offset = 0, buffer = null, i2;
          for (i2 = 0; i2 < buffers.length; i2++) {
            length += buffers[i2].length;
          }
          buffer = util.buffer.alloc(length);
          for (i2 = 0; i2 < buffers.length; i2++) {
            buffers[i2].copy(buffer, offset);
            offset += buffers[i2].length;
          }
          return buffer;
        }
      },
      string: {
        byteLength: function byteLength(string) {
          if (string === null || string === void 0)
            return 0;
          if (typeof string === "string")
            string = util.buffer.toBuffer(string);
          if (typeof string.byteLength === "number") {
            return string.byteLength;
          } else if (typeof string.length === "number") {
            return string.length;
          } else if (typeof string.size === "number") {
            return string.size;
          } else if (typeof string.path === "string") {
            return require("fs").lstatSync(string.path).size;
          } else {
            throw util.error(new Error("Cannot determine length of " + string), { object: string });
          }
        },
        upperFirst: function upperFirst(string) {
          return string[0].toUpperCase() + string.substr(1);
        },
        lowerFirst: function lowerFirst(string) {
          return string[0].toLowerCase() + string.substr(1);
        }
      },
      ini: {
        parse: function string(ini) {
          var currentSection, map = {};
          util.arrayEach(ini.split(/\r?\n/), function(line) {
            line = line.split(/(^|\s)[;#]/)[0];
            var section = line.match(/^\s*\[([^\[\]]+)\]\s*$/);
            if (section) {
              currentSection = section[1];
              if (currentSection === "__proto__" || currentSection.split(/\s/)[1] === "__proto__") {
                throw util.error(new Error("Cannot load profile name '" + currentSection + "' from shared ini file."));
              }
            } else if (currentSection) {
              var item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
              if (item) {
                map[currentSection] = map[currentSection] || {};
                map[currentSection][item[1]] = item[2];
              }
            }
          });
          return map;
        }
      },
      fn: {
        noop: function() {
        },
        callback: function(err) {
          if (err)
            throw err;
        },
        makeAsync: function makeAsync(fn, expectedArgs) {
          if (expectedArgs && expectedArgs <= fn.length) {
            return fn;
          }
          return function() {
            var args = Array.prototype.slice.call(arguments, 0);
            var callback = args.pop();
            var result = fn.apply(null, args);
            callback(result);
          };
        }
      },
      date: {
        getDate: function getDate() {
          if (!AWS2)
            AWS2 = require_core2();
          if (AWS2.config.systemClockOffset) {
            return new Date(new Date().getTime() + AWS2.config.systemClockOffset);
          } else {
            return new Date();
          }
        },
        iso8601: function iso8601(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.toISOString().replace(/\.\d{3}Z$/, "Z");
        },
        rfc822: function rfc822(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.toUTCString();
        },
        unixTimestamp: function unixTimestamp(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.getTime() / 1e3;
        },
        from: function format(date) {
          if (typeof date === "number") {
            return new Date(date * 1e3);
          } else {
            return new Date(date);
          }
        },
        format: function format(date, formatter) {
          if (!formatter)
            formatter = "iso8601";
          return util.date[formatter](util.date.from(date));
        },
        parseTimestamp: function parseTimestamp(value) {
          if (typeof value === "number") {
            return new Date(value * 1e3);
          } else if (value.match(/^\d+$/)) {
            return new Date(value * 1e3);
          } else if (value.match(/^\d{4}/)) {
            return new Date(value);
          } else if (value.match(/^\w{3},/)) {
            return new Date(value);
          } else {
            throw util.error(new Error("unhandled timestamp format: " + value), { code: "TimestampParserError" });
          }
        }
      },
      crypto: {
        crc32Table: [
          0,
          1996959894,
          3993919788,
          2567524794,
          124634137,
          1886057615,
          3915621685,
          2657392035,
          249268274,
          2044508324,
          3772115230,
          2547177864,
          162941995,
          2125561021,
          3887607047,
          2428444049,
          498536548,
          1789927666,
          4089016648,
          2227061214,
          450548861,
          1843258603,
          4107580753,
          2211677639,
          325883990,
          1684777152,
          4251122042,
          2321926636,
          335633487,
          1661365465,
          4195302755,
          2366115317,
          997073096,
          1281953886,
          3579855332,
          2724688242,
          1006888145,
          1258607687,
          3524101629,
          2768942443,
          901097722,
          1119000684,
          3686517206,
          2898065728,
          853044451,
          1172266101,
          3705015759,
          2882616665,
          651767980,
          1373503546,
          3369554304,
          3218104598,
          565507253,
          1454621731,
          3485111705,
          3099436303,
          671266974,
          1594198024,
          3322730930,
          2970347812,
          795835527,
          1483230225,
          3244367275,
          3060149565,
          1994146192,
          31158534,
          2563907772,
          4023717930,
          1907459465,
          112637215,
          2680153253,
          3904427059,
          2013776290,
          251722036,
          2517215374,
          3775830040,
          2137656763,
          141376813,
          2439277719,
          3865271297,
          1802195444,
          476864866,
          2238001368,
          4066508878,
          1812370925,
          453092731,
          2181625025,
          4111451223,
          1706088902,
          314042704,
          2344532202,
          4240017532,
          1658658271,
          366619977,
          2362670323,
          4224994405,
          1303535960,
          984961486,
          2747007092,
          3569037538,
          1256170817,
          1037604311,
          2765210733,
          3554079995,
          1131014506,
          879679996,
          2909243462,
          3663771856,
          1141124467,
          855842277,
          2852801631,
          3708648649,
          1342533948,
          654459306,
          3188396048,
          3373015174,
          1466479909,
          544179635,
          3110523913,
          3462522015,
          1591671054,
          702138776,
          2966460450,
          3352799412,
          1504918807,
          783551873,
          3082640443,
          3233442989,
          3988292384,
          2596254646,
          62317068,
          1957810842,
          3939845945,
          2647816111,
          81470997,
          1943803523,
          3814918930,
          2489596804,
          225274430,
          2053790376,
          3826175755,
          2466906013,
          167816743,
          2097651377,
          4027552580,
          2265490386,
          503444072,
          1762050814,
          4150417245,
          2154129355,
          426522225,
          1852507879,
          4275313526,
          2312317920,
          282753626,
          1742555852,
          4189708143,
          2394877945,
          397917763,
          1622183637,
          3604390888,
          2714866558,
          953729732,
          1340076626,
          3518719985,
          2797360999,
          1068828381,
          1219638859,
          3624741850,
          2936675148,
          906185462,
          1090812512,
          3747672003,
          2825379669,
          829329135,
          1181335161,
          3412177804,
          3160834842,
          628085408,
          1382605366,
          3423369109,
          3138078467,
          570562233,
          1426400815,
          3317316542,
          2998733608,
          733239954,
          1555261956,
          3268935591,
          3050360625,
          752459403,
          1541320221,
          2607071920,
          3965973030,
          1969922972,
          40735498,
          2617837225,
          3943577151,
          1913087877,
          83908371,
          2512341634,
          3803740692,
          2075208622,
          213261112,
          2463272603,
          3855990285,
          2094854071,
          198958881,
          2262029012,
          4057260610,
          1759359992,
          534414190,
          2176718541,
          4139329115,
          1873836001,
          414664567,
          2282248934,
          4279200368,
          1711684554,
          285281116,
          2405801727,
          4167216745,
          1634467795,
          376229701,
          2685067896,
          3608007406,
          1308918612,
          956543938,
          2808555105,
          3495958263,
          1231636301,
          1047427035,
          2932959818,
          3654703836,
          1088359270,
          936918e3,
          2847714899,
          3736837829,
          1202900863,
          817233897,
          3183342108,
          3401237130,
          1404277552,
          615818150,
          3134207493,
          3453421203,
          1423857449,
          601450431,
          3009837614,
          3294710456,
          1567103746,
          711928724,
          3020668471,
          3272380065,
          1510334235,
          755167117
        ],
        crc32: function crc32(data) {
          var tbl = util.crypto.crc32Table;
          var crc = 0 ^ -1;
          if (typeof data === "string") {
            data = util.buffer.toBuffer(data);
          }
          for (var i2 = 0; i2 < data.length; i2++) {
            var code = data.readUInt8(i2);
            crc = crc >>> 8 ^ tbl[(crc ^ code) & 255];
          }
          return (crc ^ -1) >>> 0;
        },
        hmac: function hmac(key, string, digest, fn) {
          if (!digest)
            digest = "binary";
          if (digest === "buffer") {
            digest = void 0;
          }
          if (!fn)
            fn = "sha256";
          if (typeof string === "string")
            string = util.buffer.toBuffer(string);
          return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
        },
        md5: function md5(data, digest, callback) {
          return util.crypto.hash("md5", data, digest, callback);
        },
        sha256: function sha256(data, digest, callback) {
          return util.crypto.hash("sha256", data, digest, callback);
        },
        hash: function(algorithm, data, digest, callback) {
          var hash = util.crypto.createHash(algorithm);
          if (!digest) {
            digest = "binary";
          }
          if (digest === "buffer") {
            digest = void 0;
          }
          if (typeof data === "string")
            data = util.buffer.toBuffer(data);
          var sliceFn = util.arraySliceFn(data);
          var isBuffer = util.Buffer.isBuffer(data);
          if (util.isBrowser() && typeof ArrayBuffer !== "undefined" && data && data.buffer instanceof ArrayBuffer)
            isBuffer = true;
          if (callback && typeof data === "object" && typeof data.on === "function" && !isBuffer) {
            data.on("data", function(chunk) {
              hash.update(chunk);
            });
            data.on("error", function(err) {
              callback(err);
            });
            data.on("end", function() {
              callback(null, hash.digest(digest));
            });
          } else if (callback && sliceFn && !isBuffer && typeof FileReader !== "undefined") {
            var index = 0, size = 1024 * 512;
            var reader = new FileReader();
            reader.onerror = function() {
              callback(new Error("Failed to read data."));
            };
            reader.onload = function() {
              var buf = new util.Buffer(new Uint8Array(reader.result));
              hash.update(buf);
              index += buf.length;
              reader._continueReading();
            };
            reader._continueReading = function() {
              if (index >= data.size) {
                callback(null, hash.digest(digest));
                return;
              }
              var back = index + size;
              if (back > data.size)
                back = data.size;
              reader.readAsArrayBuffer(sliceFn.call(data, index, back));
            };
            reader._continueReading();
          } else {
            if (util.isBrowser() && typeof data === "object" && !isBuffer) {
              data = new util.Buffer(new Uint8Array(data));
            }
            var out = hash.update(data).digest(digest);
            if (callback)
              callback(null, out);
            return out;
          }
        },
        toHex: function toHex(data) {
          var out = [];
          for (var i2 = 0; i2 < data.length; i2++) {
            out.push(("0" + data.charCodeAt(i2).toString(16)).substr(-2, 2));
          }
          return out.join("");
        },
        createHash: function createHash(algorithm) {
          return util.crypto.lib.createHash(algorithm);
        }
      },
      abort: {},
      each: function each(object, iterFunction) {
        for (var key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            var ret = iterFunction.call(this, key, object[key]);
            if (ret === util.abort)
              break;
          }
        }
      },
      arrayEach: function arrayEach(array, iterFunction) {
        for (var idx in array) {
          if (Object.prototype.hasOwnProperty.call(array, idx)) {
            var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
            if (ret === util.abort)
              break;
          }
        }
      },
      update: function update(obj1, obj2) {
        util.each(obj2, function iterator(key, item) {
          obj1[key] = item;
        });
        return obj1;
      },
      merge: function merge(obj1, obj2) {
        return util.update(util.copy(obj1), obj2);
      },
      copy: function copy(object) {
        if (object === null || object === void 0)
          return object;
        var dupe = {};
        for (var key in object) {
          dupe[key] = object[key];
        }
        return dupe;
      },
      isEmpty: function isEmpty(obj) {
        for (var prop in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, prop)) {
            return false;
          }
        }
        return true;
      },
      arraySliceFn: function arraySliceFn(obj) {
        var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
        return typeof fn === "function" ? fn : null;
      },
      isType: function isType(obj, type) {
        if (typeof type === "function")
          type = util.typeName(type);
        return Object.prototype.toString.call(obj) === "[object " + type + "]";
      },
      typeName: function typeName(type) {
        if (Object.prototype.hasOwnProperty.call(type, "name"))
          return type.name;
        var str = type.toString();
        var match = str.match(/^\s*function (.+)\(/);
        return match ? match[1] : str;
      },
      error: function error2(err, options) {
        var originalError = null;
        if (typeof err.message === "string" && err.message !== "") {
          if (typeof options === "string" || options && options.message) {
            originalError = util.copy(err);
            originalError.message = err.message;
          }
        }
        err.message = err.message || null;
        if (typeof options === "string") {
          err.message = options;
        } else if (typeof options === "object" && options !== null) {
          util.update(err, options);
          if (options.message)
            err.message = options.message;
          if (options.code || options.name)
            err.code = options.code || options.name;
          if (options.stack)
            err.stack = options.stack;
        }
        if (typeof Object.defineProperty === "function") {
          Object.defineProperty(err, "name", { writable: true, enumerable: false });
          Object.defineProperty(err, "message", { enumerable: true });
        }
        err.name = String(options && options.name || err.name || err.code || "Error");
        err.time = new Date();
        if (originalError)
          err.originalError = originalError;
        return err;
      },
      inherit: function inherit(klass, features) {
        var newObject = null;
        if (features === void 0) {
          features = klass;
          klass = Object;
          newObject = {};
        } else {
          var ctor = function ConstructorWrapper() {
          };
          ctor.prototype = klass.prototype;
          newObject = new ctor();
        }
        if (features.constructor === Object) {
          features.constructor = function() {
            if (klass !== Object) {
              return klass.apply(this, arguments);
            }
          };
        }
        features.constructor.prototype = newObject;
        util.update(features.constructor.prototype, features);
        features.constructor.__super__ = klass;
        return features.constructor;
      },
      mixin: function mixin() {
        var klass = arguments[0];
        for (var i2 = 1; i2 < arguments.length; i2++) {
          for (var prop in arguments[i2].prototype) {
            var fn = arguments[i2].prototype[prop];
            if (prop !== "constructor") {
              klass.prototype[prop] = fn;
            }
          }
        }
        return klass;
      },
      hideProperties: function hideProperties(obj, props) {
        if (typeof Object.defineProperty !== "function")
          return;
        util.arrayEach(props, function(key) {
          Object.defineProperty(obj, key, {
            enumerable: false,
            writable: true,
            configurable: true
          });
        });
      },
      property: function property(obj, name, value, enumerable, isValue) {
        var opts = {
          configurable: true,
          enumerable: enumerable !== void 0 ? enumerable : true
        };
        if (typeof value === "function" && !isValue) {
          opts.get = value;
        } else {
          opts.value = value;
          opts.writable = true;
        }
        Object.defineProperty(obj, name, opts);
      },
      memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
        var cachedValue = null;
        util.property(obj, name, function() {
          if (cachedValue === null) {
            cachedValue = get();
          }
          return cachedValue;
        }, enumerable);
      },
      hoistPayloadMember: function hoistPayloadMember(resp) {
        var req = resp.request;
        var operationName = req.operation;
        var operation = req.service.api.operations[operationName];
        var output = operation.output;
        if (output.payload && !operation.hasEventOutput) {
          var payloadMember = output.members[output.payload];
          var responsePayload = resp.data[output.payload];
          if (payloadMember.type === "structure") {
            util.each(responsePayload, function(key, value) {
              util.property(resp.data, key, value, false);
            });
          }
        }
      },
      computeSha256: function computeSha256(body, done) {
        if (util.isNode()) {
          var Stream3 = util.stream.Stream;
          var fs8 = require("fs");
          if (typeof Stream3 === "function" && body instanceof Stream3) {
            if (typeof body.path === "string") {
              var settings = {};
              if (typeof body.start === "number") {
                settings.start = body.start;
              }
              if (typeof body.end === "number") {
                settings.end = body.end;
              }
              body = fs8.createReadStream(body.path, settings);
            } else {
              return done(new Error("Non-file stream objects are not supported with SigV4"));
            }
          }
        }
        util.crypto.sha256(body, "hex", function(err, sha) {
          if (err)
            done(err);
          else
            done(null, sha);
        });
      },
      isClockSkewed: function isClockSkewed(serverTime) {
        if (serverTime) {
          util.property(AWS2.config, "isClockSkewed", Math.abs(new Date().getTime() - serverTime) >= 3e5, false);
          return AWS2.config.isClockSkewed;
        }
      },
      applyClockOffset: function applyClockOffset(serverTime) {
        if (serverTime)
          AWS2.config.systemClockOffset = serverTime - new Date().getTime();
      },
      extractRequestId: function extractRequestId(resp) {
        var requestId = resp.httpResponse.headers["x-amz-request-id"] || resp.httpResponse.headers["x-amzn-requestid"];
        if (!requestId && resp.data && resp.data.ResponseMetadata) {
          requestId = resp.data.ResponseMetadata.RequestId;
        }
        if (requestId) {
          resp.requestId = requestId;
        }
        if (resp.error) {
          resp.error.requestId = requestId;
        }
      },
      addPromises: function addPromises(constructors, PromiseDependency) {
        var deletePromises = false;
        if (PromiseDependency === void 0 && AWS2 && AWS2.config) {
          PromiseDependency = AWS2.config.getPromisesDependency();
        }
        if (PromiseDependency === void 0 && typeof Promise !== "undefined") {
          PromiseDependency = Promise;
        }
        if (typeof PromiseDependency !== "function")
          deletePromises = true;
        if (!Array.isArray(constructors))
          constructors = [constructors];
        for (var ind = 0; ind < constructors.length; ind++) {
          var constructor = constructors[ind];
          if (deletePromises) {
            if (constructor.deletePromisesFromClass) {
              constructor.deletePromisesFromClass();
            }
          } else if (constructor.addPromisesToClass) {
            constructor.addPromisesToClass(PromiseDependency);
          }
        }
      },
      promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
        return function promise() {
          var self2 = this;
          var args = Array.prototype.slice.call(arguments);
          return new PromiseDependency(function(resolve2, reject) {
            args.push(function(err, data) {
              if (err) {
                reject(err);
              } else {
                resolve2(data);
              }
            });
            self2[methodName].apply(self2, args);
          });
        };
      },
      isDualstackAvailable: function isDualstackAvailable(service) {
        if (!service)
          return false;
        var metadata = require_metadata();
        if (typeof service !== "string")
          service = service.serviceIdentifier;
        if (typeof service !== "string" || !metadata.hasOwnProperty(service))
          return false;
        return !!metadata[service].dualstackAvailable;
      },
      calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions, err) {
        if (!retryDelayOptions)
          retryDelayOptions = {};
        var customBackoff = retryDelayOptions.customBackoff || null;
        if (typeof customBackoff === "function") {
          return customBackoff(retryCount, err);
        }
        var base = typeof retryDelayOptions.base === "number" ? retryDelayOptions.base : 100;
        var delay = Math.random() * (Math.pow(2, retryCount) * base);
        return delay;
      },
      handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
        if (!options)
          options = {};
        var http3 = AWS2.HttpClient.getInstance();
        var httpOptions = options.httpOptions || {};
        var retryCount = 0;
        var errCallback = function(err) {
          var maxRetries = options.maxRetries || 0;
          if (err && err.code === "TimeoutError")
            err.retryable = true;
          if (err && err.retryable && retryCount < maxRetries) {
            var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);
            if (delay >= 0) {
              retryCount++;
              setTimeout(sendRequest, delay + (err.retryAfter || 0));
              return;
            }
          }
          cb(err);
        };
        var sendRequest = function() {
          var data = "";
          http3.handleRequest(httpRequest, httpOptions, function(httpResponse) {
            httpResponse.on("data", function(chunk) {
              data += chunk.toString();
            });
            httpResponse.on("end", function() {
              var statusCode = httpResponse.statusCode;
              if (statusCode < 300) {
                cb(null, data);
              } else {
                var retryAfter = parseInt(httpResponse.headers["retry-after"], 10) * 1e3 || 0;
                var err = util.error(new Error(), {
                  statusCode,
                  retryable: statusCode >= 500 || statusCode === 429
                });
                if (retryAfter && err.retryable)
                  err.retryAfter = retryAfter;
                errCallback(err);
              }
            });
          }, errCallback);
        };
        AWS2.util.defer(sendRequest);
      },
      uuid: {
        v4: function uuidV4() {
          return require_uuid().v4();
        }
      },
      convertPayloadToString: function convertPayloadToString(resp) {
        var req = resp.request;
        var operation = req.operation;
        var rules = req.service.api.operations[operation].output || {};
        if (rules.payload && resp.data[rules.payload]) {
          resp.data[rules.payload] = resp.data[rules.payload].toString();
        }
      },
      defer: function defer(callback) {
        if (typeof process === "object" && typeof process.nextTick === "function") {
          process.nextTick(callback);
        } else if (typeof setImmediate === "function") {
          setImmediate(callback);
        } else {
          setTimeout(callback, 0);
        }
      },
      getRequestPayloadShape: function getRequestPayloadShape(req) {
        var operations = req.service.api.operations;
        if (!operations)
          return void 0;
        var operation = (operations || {})[req.operation];
        if (!operation || !operation.input || !operation.input.payload)
          return void 0;
        return operation.input.members[operation.input.payload];
      },
      getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {
        var profiles = {};
        var profilesFromConfig = {};
        if (process.env[util.configOptInEnv]) {
          var profilesFromConfig = iniLoader.loadFrom({
            isConfig: true,
            filename: process.env[util.sharedConfigFileEnv]
          });
        }
        var profilesFromCreds = {};
        try {
          var profilesFromCreds = iniLoader.loadFrom({
            filename: filename || process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv]
          });
        } catch (error2) {
          if (!process.env[util.configOptInEnv])
            throw error2;
        }
        for (var i2 = 0, profileNames = Object.keys(profilesFromConfig); i2 < profileNames.length; i2++) {
          profiles[profileNames[i2]] = objectAssign(profiles[profileNames[i2]] || {}, profilesFromConfig[profileNames[i2]]);
        }
        for (var i2 = 0, profileNames = Object.keys(profilesFromCreds); i2 < profileNames.length; i2++) {
          profiles[profileNames[i2]] = objectAssign(profiles[profileNames[i2]] || {}, profilesFromCreds[profileNames[i2]]);
        }
        return profiles;
        function objectAssign(target, source) {
          for (var i3 = 0, keys = Object.keys(source); i3 < keys.length; i3++) {
            target[keys[i3]] = source[keys[i3]];
          }
          return target;
        }
      },
      ARN: {
        validate: function validateARN(str) {
          return str && str.indexOf("arn:") === 0 && str.split(":").length >= 6;
        },
        parse: function parseARN(arn) {
          var matched = arn.split(":");
          return {
            partition: matched[1],
            service: matched[2],
            region: matched[3],
            accountId: matched[4],
            resource: matched.slice(5).join(":")
          };
        },
        build: function buildARN(arnObject) {
          if (arnObject.service === void 0 || arnObject.region === void 0 || arnObject.accountId === void 0 || arnObject.resource === void 0)
            throw util.error(new Error("Input ARN object is invalid"));
          return "arn:" + (arnObject.partition || "aws") + ":" + arnObject.service + ":" + arnObject.region + ":" + arnObject.accountId + ":" + arnObject.resource;
        }
      },
      defaultProfile: "default",
      configOptInEnv: "AWS_SDK_LOAD_CONFIG",
      sharedCredentialsFileEnv: "AWS_SHARED_CREDENTIALS_FILE",
      sharedConfigFileEnv: "AWS_CONFIG_FILE",
      imdsDisabledEnv: "AWS_EC2_METADATA_DISABLED"
    };
    module2.exports = util;
  }
});

// node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js
var require_event_message_chunker_stream = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js"(exports, module2) {
    var util = require_core2().util;
    var Transform = require("stream").Transform;
    var allocBuffer = util.buffer.alloc;
    function EventMessageChunkerStream(options) {
      Transform.call(this, options);
      this.currentMessageTotalLength = 0;
      this.currentMessagePendingLength = 0;
      this.currentMessage = null;
      this.messageLengthBuffer = null;
    }
    EventMessageChunkerStream.prototype = Object.create(Transform.prototype);
    EventMessageChunkerStream.prototype._transform = function(chunk, encoding, callback) {
      var chunkLength = chunk.length;
      var currentOffset = 0;
      while (currentOffset < chunkLength) {
        if (!this.currentMessage) {
          var bytesRemaining = chunkLength - currentOffset;
          if (!this.messageLengthBuffer) {
            this.messageLengthBuffer = allocBuffer(4);
          }
          var numBytesForTotal = Math.min(4 - this.currentMessagePendingLength, bytesRemaining);
          chunk.copy(this.messageLengthBuffer, this.currentMessagePendingLength, currentOffset, currentOffset + numBytesForTotal);
          this.currentMessagePendingLength += numBytesForTotal;
          currentOffset += numBytesForTotal;
          if (this.currentMessagePendingLength < 4) {
            break;
          }
          this.allocateMessage(this.messageLengthBuffer.readUInt32BE(0));
          this.messageLengthBuffer = null;
        }
        var numBytesToWrite = Math.min(this.currentMessageTotalLength - this.currentMessagePendingLength, chunkLength - currentOffset);
        chunk.copy(this.currentMessage, this.currentMessagePendingLength, currentOffset, currentOffset + numBytesToWrite);
        this.currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;
        if (this.currentMessageTotalLength && this.currentMessageTotalLength === this.currentMessagePendingLength) {
          this.push(this.currentMessage);
          this.currentMessage = null;
          this.currentMessageTotalLength = 0;
          this.currentMessagePendingLength = 0;
        }
      }
      callback();
    };
    EventMessageChunkerStream.prototype._flush = function(callback) {
      if (this.currentMessageTotalLength) {
        if (this.currentMessageTotalLength === this.currentMessagePendingLength) {
          callback(null, this.currentMessage);
        } else {
          callback(new Error("Truncated event message received."));
        }
      } else {
        callback();
      }
    };
    EventMessageChunkerStream.prototype.allocateMessage = function(size) {
      if (typeof size !== "number") {
        throw new Error("Attempted to allocate an event message where size was not a number: " + size);
      }
      this.currentMessageTotalLength = size;
      this.currentMessagePendingLength = 4;
      this.currentMessage = allocBuffer(size);
      this.currentMessage.writeUInt32BE(size, 0);
    };
    module2.exports = {
      EventMessageChunkerStream
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/int64.js
var require_int64 = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/int64.js"(exports, module2) {
    var util = require_core2().util;
    var toBuffer = util.buffer.toBuffer;
    function Int64(bytes) {
      if (bytes.length !== 8) {
        throw new Error("Int64 buffers must be exactly 8 bytes");
      }
      if (!util.Buffer.isBuffer(bytes))
        bytes = toBuffer(bytes);
      this.bytes = bytes;
    }
    Int64.fromNumber = function(number) {
      if (number > 9223372036854776e3 || number < -9223372036854776e3) {
        throw new Error(number + " is too large (or, if negative, too small) to represent as an Int64");
      }
      var bytes = new Uint8Array(8);
      for (var i2 = 7, remaining = Math.abs(Math.round(number)); i2 > -1 && remaining > 0; i2--, remaining /= 256) {
        bytes[i2] = remaining;
      }
      if (number < 0) {
        negate(bytes);
      }
      return new Int64(bytes);
    };
    Int64.prototype.valueOf = function() {
      var bytes = this.bytes.slice(0);
      var negative = bytes[0] & 128;
      if (negative) {
        negate(bytes);
      }
      return parseInt(bytes.toString("hex"), 16) * (negative ? -1 : 1);
    };
    Int64.prototype.toString = function() {
      return String(this.valueOf());
    };
    function negate(bytes) {
      for (var i2 = 0; i2 < 8; i2++) {
        bytes[i2] ^= 255;
      }
      for (var i2 = 7; i2 > -1; i2--) {
        bytes[i2]++;
        if (bytes[i2] !== 0) {
          break;
        }
      }
    }
    module2.exports = {
      Int64
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/split-message.js
var require_split_message = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/split-message.js"(exports, module2) {
    var util = require_core2().util;
    var toBuffer = util.buffer.toBuffer;
    var PRELUDE_MEMBER_LENGTH = 4;
    var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
    var CHECKSUM_LENGTH = 4;
    var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
    function splitMessage(message) {
      if (!util.Buffer.isBuffer(message))
        message = toBuffer(message);
      if (message.length < MINIMUM_MESSAGE_LENGTH) {
        throw new Error("Provided message too short to accommodate event stream message overhead");
      }
      if (message.length !== message.readUInt32BE(0)) {
        throw new Error("Reported message length does not match received message length");
      }
      var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);
      if (expectedPreludeChecksum !== util.crypto.crc32(message.slice(0, PRELUDE_LENGTH))) {
        throw new Error("The prelude checksum specified in the message (" + expectedPreludeChecksum + ") does not match the calculated CRC32 checksum.");
      }
      var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);
      if (expectedMessageChecksum !== util.crypto.crc32(message.slice(0, message.length - CHECKSUM_LENGTH))) {
        throw new Error("The message checksum did not match the expected value of " + expectedMessageChecksum);
      }
      var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
      var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);
      return {
        headers: message.slice(headersStart, headersEnd),
        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH)
      };
    }
    module2.exports = {
      splitMessage
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/parse-message.js
var require_parse_message = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/parse-message.js"(exports, module2) {
    var Int64 = require_int64().Int64;
    var splitMessage = require_split_message().splitMessage;
    var BOOLEAN_TAG = "boolean";
    var BYTE_TAG = "byte";
    var SHORT_TAG = "short";
    var INT_TAG = "integer";
    var LONG_TAG = "long";
    var BINARY_TAG = "binary";
    var STRING_TAG = "string";
    var TIMESTAMP_TAG = "timestamp";
    var UUID_TAG = "uuid";
    function parseHeaders(headers) {
      var out = {};
      var position = 0;
      while (position < headers.length) {
        var nameLength = headers.readUInt8(position++);
        var name = headers.slice(position, position + nameLength).toString();
        position += nameLength;
        switch (headers.readUInt8(position++)) {
          case 0:
            out[name] = {
              type: BOOLEAN_TAG,
              value: true
            };
            break;
          case 1:
            out[name] = {
              type: BOOLEAN_TAG,
              value: false
            };
            break;
          case 2:
            out[name] = {
              type: BYTE_TAG,
              value: headers.readInt8(position++)
            };
            break;
          case 3:
            out[name] = {
              type: SHORT_TAG,
              value: headers.readInt16BE(position)
            };
            position += 2;
            break;
          case 4:
            out[name] = {
              type: INT_TAG,
              value: headers.readInt32BE(position)
            };
            position += 4;
            break;
          case 5:
            out[name] = {
              type: LONG_TAG,
              value: new Int64(headers.slice(position, position + 8))
            };
            position += 8;
            break;
          case 6:
            var binaryLength = headers.readUInt16BE(position);
            position += 2;
            out[name] = {
              type: BINARY_TAG,
              value: headers.slice(position, position + binaryLength)
            };
            position += binaryLength;
            break;
          case 7:
            var stringLength = headers.readUInt16BE(position);
            position += 2;
            out[name] = {
              type: STRING_TAG,
              value: headers.slice(position, position + stringLength).toString()
            };
            position += stringLength;
            break;
          case 8:
            out[name] = {
              type: TIMESTAMP_TAG,
              value: new Date(new Int64(headers.slice(position, position + 8)).valueOf())
            };
            position += 8;
            break;
          case 9:
            var uuidChars = headers.slice(position, position + 16).toString("hex");
            position += 16;
            out[name] = {
              type: UUID_TAG,
              value: uuidChars.substr(0, 8) + "-" + uuidChars.substr(8, 4) + "-" + uuidChars.substr(12, 4) + "-" + uuidChars.substr(16, 4) + "-" + uuidChars.substr(20)
            };
            break;
          default:
            throw new Error("Unrecognized header type tag");
        }
      }
      return out;
    }
    function parseMessage(message) {
      var parsed = splitMessage(message);
      return { headers: parseHeaders(parsed.headers), body: parsed.body };
    }
    module2.exports = {
      parseMessage
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/parse-event.js
var require_parse_event = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/parse-event.js"(exports, module2) {
    var parseMessage = require_parse_message().parseMessage;
    function parseEvent(parser, message, shape) {
      var parsedMessage = parseMessage(message);
      var messageType = parsedMessage.headers[":message-type"];
      if (messageType) {
        if (messageType.value === "error") {
          throw parseError(parsedMessage);
        } else if (messageType.value !== "event") {
          return;
        }
      }
      var eventType = parsedMessage.headers[":event-type"];
      var eventModel = shape.members[eventType.value];
      if (!eventModel) {
        return;
      }
      var result = {};
      var eventPayloadMemberName = eventModel.eventPayloadMemberName;
      if (eventPayloadMemberName) {
        var payloadShape = eventModel.members[eventPayloadMemberName];
        if (payloadShape.type === "binary") {
          result[eventPayloadMemberName] = parsedMessage.body;
        } else {
          result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
        }
      }
      var eventHeaderNames = eventModel.eventHeaderMemberNames;
      for (var i2 = 0; i2 < eventHeaderNames.length; i2++) {
        var name = eventHeaderNames[i2];
        if (parsedMessage.headers[name]) {
          result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
        }
      }
      var output = {};
      output[eventType.value] = result;
      return output;
    }
    function parseError(message) {
      var errorCode = message.headers[":error-code"];
      var errorMessage = message.headers[":error-message"];
      var error2 = new Error(errorMessage.value || errorMessage);
      error2.code = error2.name = errorCode.value || errorCode;
      return error2;
    }
    module2.exports = {
      parseEvent
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js
var require_event_message_unmarshaller_stream = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js"(exports, module2) {
    var Transform = require("stream").Transform;
    var parseEvent = require_parse_event().parseEvent;
    function EventUnmarshallerStream(options) {
      options = options || {};
      options.readableObjectMode = true;
      Transform.call(this, options);
      this._readableState.objectMode = true;
      this.parser = options.parser;
      this.eventStreamModel = options.eventStreamModel;
    }
    EventUnmarshallerStream.prototype = Object.create(Transform.prototype);
    EventUnmarshallerStream.prototype._transform = function(chunk, encoding, callback) {
      try {
        var event = parseEvent(this.parser, chunk, this.eventStreamModel);
        this.push(event);
        return callback();
      } catch (err) {
        callback(err);
      }
    };
    module2.exports = {
      EventUnmarshallerStream
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js
var require_streaming_create_event_stream = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js"(exports, module2) {
    var EventMessageChunkerStream = require_event_message_chunker_stream().EventMessageChunkerStream;
    var EventUnmarshallerStream = require_event_message_unmarshaller_stream().EventUnmarshallerStream;
    function createEventStream(stream, parser, model) {
      var eventStream = new EventUnmarshallerStream({
        parser,
        eventStreamModel: model
      });
      var eventMessageChunker = new EventMessageChunkerStream();
      stream.pipe(eventMessageChunker).pipe(eventStream);
      stream.on("error", function(err) {
        eventMessageChunker.emit("error", err);
      });
      eventMessageChunker.on("error", function(err) {
        eventStream.emit("error", err);
      });
      return eventStream;
    }
    module2.exports = {
      createEventStream
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/event-message-chunker.js
var require_event_message_chunker = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/event-message-chunker.js"(exports, module2) {
    function eventMessageChunker(buffer) {
      var messages = [];
      var offset = 0;
      while (offset < buffer.length) {
        var totalLength = buffer.readInt32BE(offset);
        var message = buffer.slice(offset, totalLength + offset);
        offset += totalLength;
        messages.push(message);
      }
      return messages;
    }
    module2.exports = {
      eventMessageChunker
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js
var require_buffered_create_event_stream = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js"(exports, module2) {
    var eventMessageChunker = require_event_message_chunker().eventMessageChunker;
    var parseEvent = require_parse_event().parseEvent;
    function createEventStream(body, parser, model) {
      var eventMessages = eventMessageChunker(body);
      var events = [];
      for (var i2 = 0; i2 < eventMessages.length; i2++) {
        events.push(parseEvent(parser, eventMessages[i2], model));
      }
      return events;
    }
    module2.exports = {
      createEventStream
    };
  }
});

// node_modules/aws-sdk/lib/realclock/nodeClock.js
var require_nodeClock = __commonJS({
  "node_modules/aws-sdk/lib/realclock/nodeClock.js"(exports, module2) {
    module2.exports = {
      now: function now() {
        var second = process.hrtime();
        return second[0] * 1e3 + second[1] / 1e6;
      }
    };
  }
});

// node_modules/aws-sdk/lib/publisher/index.js
var require_publisher = __commonJS({
  "node_modules/aws-sdk/lib/publisher/index.js"(exports, module2) {
    var util = require_core2().util;
    var dgram = require("dgram");
    var stringToBuffer = util.buffer.toBuffer;
    var MAX_MESSAGE_SIZE = 1024 * 8;
    function Publisher(options) {
      options = options || {};
      this.enabled = options.enabled || false;
      this.port = options.port || 31e3;
      this.clientId = options.clientId || "";
      this.address = options.host || "127.0.0.1";
      if (this.clientId.length > 255) {
        this.clientId = this.clientId.substr(0, 255);
      }
      this.messagesInFlight = 0;
    }
    Publisher.prototype.fieldsToTrim = {
      UserAgent: 256,
      SdkException: 128,
      SdkExceptionMessage: 512,
      AwsException: 128,
      AwsExceptionMessage: 512,
      FinalSdkException: 128,
      FinalSdkExceptionMessage: 512,
      FinalAwsException: 128,
      FinalAwsExceptionMessage: 512
    };
    Publisher.prototype.trimFields = function(event) {
      var trimmableFields = Object.keys(this.fieldsToTrim);
      for (var i2 = 0, iLen = trimmableFields.length; i2 < iLen; i2++) {
        var field = trimmableFields[i2];
        if (event.hasOwnProperty(field)) {
          var maxLength = this.fieldsToTrim[field];
          var value = event[field];
          if (value && value.length > maxLength) {
            event[field] = value.substr(0, maxLength);
          }
        }
      }
      return event;
    };
    Publisher.prototype.eventHandler = function(event) {
      event.ClientId = this.clientId;
      this.trimFields(event);
      var message = stringToBuffer(JSON.stringify(event));
      if (!this.enabled || message.length > MAX_MESSAGE_SIZE) {
        return;
      }
      this.publishDatagram(message);
    };
    Publisher.prototype.publishDatagram = function(message) {
      var self2 = this;
      var client = this.getClient();
      this.messagesInFlight++;
      this.client.send(message, 0, message.length, this.port, this.address, function(err, bytes) {
        if (--self2.messagesInFlight <= 0) {
          self2.destroyClient();
        }
      });
    };
    Publisher.prototype.getClient = function() {
      if (!this.client) {
        this.client = dgram.createSocket("udp4");
      }
      return this.client;
    };
    Publisher.prototype.destroyClient = function() {
      if (this.client) {
        this.client.close();
        this.client = void 0;
      }
    };
    module2.exports = {
      Publisher
    };
  }
});

// node_modules/aws-sdk/lib/publisher/configuration.js
var require_configuration = __commonJS({
  "node_modules/aws-sdk/lib/publisher/configuration.js"(exports, module2) {
    var AWS2 = require_core2();
    function resolveMonitoringConfig() {
      var config = {
        port: void 0,
        clientId: void 0,
        enabled: void 0,
        host: void 0
      };
      if (fromEnvironment(config) || fromConfigFile(config))
        return toJSType(config);
      return toJSType(config);
    }
    function fromEnvironment(config) {
      config.port = config.port || process.env.AWS_CSM_PORT;
      config.enabled = config.enabled || process.env.AWS_CSM_ENABLED;
      config.clientId = config.clientId || process.env.AWS_CSM_CLIENT_ID;
      config.host = config.host || process.env.AWS_CSM_HOST;
      return config.port && config.enabled && config.clientId && config.host || ["false", "0"].indexOf(config.enabled) >= 0;
    }
    function fromConfigFile(config) {
      var sharedFileConfig;
      try {
        var configFile = AWS2.util.iniLoader.loadFrom({
          isConfig: true,
          filename: process.env[AWS2.util.sharedConfigFileEnv]
        });
        var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS2.util.defaultProfile];
      } catch (err) {
        return false;
      }
      if (!sharedFileConfig)
        return config;
      config.port = config.port || sharedFileConfig.csm_port;
      config.enabled = config.enabled || sharedFileConfig.csm_enabled;
      config.clientId = config.clientId || sharedFileConfig.csm_client_id;
      config.host = config.host || sharedFileConfig.csm_host;
      return config.port && config.enabled && config.clientId && config.host;
    }
    function toJSType(config) {
      var falsyNotations = ["false", "0", void 0];
      if (!config.enabled || falsyNotations.indexOf(config.enabled.toLowerCase()) >= 0) {
        config.enabled = false;
      } else {
        config.enabled = true;
      }
      config.port = config.port ? parseInt(config.port, 10) : void 0;
      return config;
    }
    module2.exports = resolveMonitoringConfig;
  }
});

// node_modules/aws-sdk/lib/shared-ini/ini-loader.js
var require_ini_loader = __commonJS({
  "node_modules/aws-sdk/lib/shared-ini/ini-loader.js"(exports, module2) {
    var AWS2 = require_core2();
    var os = require("os");
    var path8 = require("path");
    function parseFile(filename, isConfig) {
      var content = AWS2.util.ini.parse(AWS2.util.readFileSync(filename));
      var tmpContent = {};
      Object.keys(content).forEach(function(profileName) {
        var profileContent = content[profileName];
        profileName = isConfig ? profileName.replace(/^profile\s/, "") : profileName;
        Object.defineProperty(tmpContent, profileName, {
          value: profileContent,
          enumerable: true
        });
      });
      return tmpContent;
    }
    AWS2.IniLoader = AWS2.util.inherit({
      constructor: function IniLoader2() {
        this.resolvedProfiles = {};
      },
      clearCachedFiles: function clearCachedFiles() {
        this.resolvedProfiles = {};
      },
      loadFrom: function loadFrom(options) {
        options = options || {};
        var isConfig = options.isConfig === true;
        var filename = options.filename || this.getDefaultFilePath(isConfig);
        if (!this.resolvedProfiles[filename]) {
          var fileContent = this.parseFile(filename, isConfig);
          Object.defineProperty(this.resolvedProfiles, filename, { value: fileContent });
        }
        return this.resolvedProfiles[filename];
      },
      parseFile,
      getDefaultFilePath: function getDefaultFilePath(isConfig) {
        return path8.join(this.getHomeDir(), ".aws", isConfig ? "config" : "credentials");
      },
      getHomeDir: function getHomeDir() {
        var env = process.env;
        var home = env.HOME || env.USERPROFILE || (env.HOMEPATH ? (env.HOMEDRIVE || "C:/") + env.HOMEPATH : null);
        if (home) {
          return home;
        }
        if (typeof os.homedir === "function") {
          return os.homedir();
        }
        throw AWS2.util.error(new Error("Cannot load credentials, HOME path not set"));
      }
    });
    var IniLoader = AWS2.IniLoader;
    module2.exports = {
      IniLoader,
      parseFile
    };
  }
});

// node_modules/aws-sdk/lib/shared-ini/index.js
var require_shared_ini = __commonJS({
  "node_modules/aws-sdk/lib/shared-ini/index.js"(exports, module2) {
    var IniLoader = require_ini_loader().IniLoader;
    module2.exports.iniLoader = new IniLoader();
  }
});

// node_modules/aws-sdk/lib/config_regional_endpoint.js
var require_config_regional_endpoint = __commonJS({
  "node_modules/aws-sdk/lib/config_regional_endpoint.js"(exports, module2) {
    var AWS2 = require_core2();
    function validateRegionalEndpointsFlagValue(configValue, errorOptions) {
      if (typeof configValue !== "string")
        return void 0;
      else if (["legacy", "regional"].indexOf(configValue.toLowerCase()) >= 0) {
        return configValue.toLowerCase();
      } else {
        throw AWS2.util.error(new Error(), errorOptions);
      }
    }
    function resolveRegionalEndpointsFlag(originalConfig, options) {
      originalConfig = originalConfig || {};
      var resolved;
      if (originalConfig[options.clientConfig]) {
        resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {
          code: "InvalidConfiguration",
          message: 'invalid "' + options.clientConfig + '" configuration. Expect "legacy"  or "regional". Got "' + originalConfig[options.clientConfig] + '".'
        });
        if (resolved)
          return resolved;
      }
      if (!AWS2.util.isNode())
        return resolved;
      if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {
        var envFlag = process.env[options.env];
        resolved = validateRegionalEndpointsFlagValue(envFlag, {
          code: "InvalidEnvironmentalVariable",
          message: "invalid " + options.env + ' environmental variable. Expect "legacy"  or "regional". Got "' + process.env[options.env] + '".'
        });
        if (resolved)
          return resolved;
      }
      var profile = {};
      try {
        var profiles = AWS2.util.getProfilesFromSharedConfig(AWS2.util.iniLoader);
        profile = profiles[process.env.AWS_PROFILE || AWS2.util.defaultProfile];
      } catch (e2) {
      }
      ;
      if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {
        var fileFlag = profile[options.sharedConfig];
        resolved = validateRegionalEndpointsFlagValue(fileFlag, {
          code: "InvalidConfiguration",
          message: "invalid " + options.sharedConfig + ' profile config. Expect "legacy"  or "regional". Got "' + profile[options.sharedConfig] + '".'
        });
        if (resolved)
          return resolved;
      }
      return resolved;
    }
    module2.exports = resolveRegionalEndpointsFlag;
  }
});

// node_modules/aws-sdk/lib/services/sts.js
var require_sts = __commonJS({
  "node_modules/aws-sdk/lib/services/sts.js"() {
    var AWS2 = require_core2();
    var resolveRegionalEndpointsFlag = require_config_regional_endpoint();
    var ENV_REGIONAL_ENDPOINT_ENABLED = "AWS_STS_REGIONAL_ENDPOINTS";
    var CONFIG_REGIONAL_ENDPOINT_ENABLED = "sts_regional_endpoints";
    AWS2.util.update(AWS2.STS.prototype, {
      credentialsFrom: function credentialsFrom(data, credentials) {
        if (!data)
          return null;
        if (!credentials)
          credentials = new AWS2.TemporaryCredentials();
        credentials.expired = false;
        credentials.accessKeyId = data.Credentials.AccessKeyId;
        credentials.secretAccessKey = data.Credentials.SecretAccessKey;
        credentials.sessionToken = data.Credentials.SessionToken;
        credentials.expireTime = data.Credentials.Expiration;
        return credentials;
      },
      assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
        return this.makeUnauthenticatedRequest("assumeRoleWithWebIdentity", params, callback);
      },
      assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
        return this.makeUnauthenticatedRequest("assumeRoleWithSAML", params, callback);
      },
      setupRequestListeners: function setupRequestListeners(request) {
        request.addListener("validate", this.optInRegionalEndpoint, true);
      },
      optInRegionalEndpoint: function optInRegionalEndpoint(req) {
        var service = req.service;
        var config = service.config;
        config.stsRegionalEndpoints = resolveRegionalEndpointsFlag(service._originalConfig, {
          env: ENV_REGIONAL_ENDPOINT_ENABLED,
          sharedConfig: CONFIG_REGIONAL_ENDPOINT_ENABLED,
          clientConfig: "stsRegionalEndpoints"
        });
        if (config.stsRegionalEndpoints === "regional" && service.isGlobalEndpoint) {
          if (!config.region) {
            throw AWS2.util.error(new Error(), { code: "ConfigError", message: "Missing region in config" });
          }
          var insertPoint = config.endpoint.indexOf(".amazonaws.com");
          var regionalEndpoint2 = config.endpoint.substring(0, insertPoint) + "." + config.region + config.endpoint.substring(insertPoint);
          req.httpRequest.updateEndpoint(regionalEndpoint2);
          req.httpRequest.region = config.region;
        }
      }
    });
  }
});

// node_modules/aws-sdk/apis/sts-2011-06-15.min.json
var require_sts_2011_06_15_min = __commonJS({
  "node_modules/aws-sdk/apis/sts-2011-06-15.min.json"(exports, module2) {
    module2.exports = {
      version: "2.0",
      metadata: {
        apiVersion: "2011-06-15",
        endpointPrefix: "sts",
        globalEndpoint: "sts.amazonaws.com",
        protocol: "query",
        serviceAbbreviation: "AWS STS",
        serviceFullName: "AWS Security Token Service",
        serviceId: "STS",
        signatureVersion: "v4",
        uid: "sts-2011-06-15",
        xmlNamespace: "https://sts.amazonaws.com/doc/2011-06-15/"
      },
      operations: {
        AssumeRole: {
          input: {
            type: "structure",
            required: [
              "RoleArn",
              "RoleSessionName"
            ],
            members: {
              RoleArn: {},
              RoleSessionName: {},
              PolicyArns: {
                shape: "S4"
              },
              Policy: {},
              DurationSeconds: {
                type: "integer"
              },
              Tags: {
                shape: "S8"
              },
              TransitiveTagKeys: {
                type: "list",
                member: {}
              },
              ExternalId: {},
              SerialNumber: {},
              TokenCode: {},
              SourceIdentity: {}
            }
          },
          output: {
            resultWrapper: "AssumeRoleResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Si"
              },
              AssumedRoleUser: {
                shape: "Sn"
              },
              PackedPolicySize: {
                type: "integer"
              },
              SourceIdentity: {}
            }
          }
        },
        AssumeRoleWithSAML: {
          input: {
            type: "structure",
            required: [
              "RoleArn",
              "PrincipalArn",
              "SAMLAssertion"
            ],
            members: {
              RoleArn: {},
              PrincipalArn: {},
              SAMLAssertion: {},
              PolicyArns: {
                shape: "S4"
              },
              Policy: {},
              DurationSeconds: {
                type: "integer"
              }
            }
          },
          output: {
            resultWrapper: "AssumeRoleWithSAMLResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Si"
              },
              AssumedRoleUser: {
                shape: "Sn"
              },
              PackedPolicySize: {
                type: "integer"
              },
              Subject: {},
              SubjectType: {},
              Issuer: {},
              Audience: {},
              NameQualifier: {},
              SourceIdentity: {}
            }
          }
        },
        AssumeRoleWithWebIdentity: {
          input: {
            type: "structure",
            required: [
              "RoleArn",
              "RoleSessionName",
              "WebIdentityToken"
            ],
            members: {
              RoleArn: {},
              RoleSessionName: {},
              WebIdentityToken: {},
              ProviderId: {},
              PolicyArns: {
                shape: "S4"
              },
              Policy: {},
              DurationSeconds: {
                type: "integer"
              }
            }
          },
          output: {
            resultWrapper: "AssumeRoleWithWebIdentityResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Si"
              },
              SubjectFromWebIdentityToken: {},
              AssumedRoleUser: {
                shape: "Sn"
              },
              PackedPolicySize: {
                type: "integer"
              },
              Provider: {},
              Audience: {},
              SourceIdentity: {}
            }
          }
        },
        DecodeAuthorizationMessage: {
          input: {
            type: "structure",
            required: [
              "EncodedMessage"
            ],
            members: {
              EncodedMessage: {}
            }
          },
          output: {
            resultWrapper: "DecodeAuthorizationMessageResult",
            type: "structure",
            members: {
              DecodedMessage: {}
            }
          }
        },
        GetAccessKeyInfo: {
          input: {
            type: "structure",
            required: [
              "AccessKeyId"
            ],
            members: {
              AccessKeyId: {}
            }
          },
          output: {
            resultWrapper: "GetAccessKeyInfoResult",
            type: "structure",
            members: {
              Account: {}
            }
          }
        },
        GetCallerIdentity: {
          input: {
            type: "structure",
            members: {}
          },
          output: {
            resultWrapper: "GetCallerIdentityResult",
            type: "structure",
            members: {
              UserId: {},
              Account: {},
              Arn: {}
            }
          }
        },
        GetFederationToken: {
          input: {
            type: "structure",
            required: [
              "Name"
            ],
            members: {
              Name: {},
              Policy: {},
              PolicyArns: {
                shape: "S4"
              },
              DurationSeconds: {
                type: "integer"
              },
              Tags: {
                shape: "S8"
              }
            }
          },
          output: {
            resultWrapper: "GetFederationTokenResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Si"
              },
              FederatedUser: {
                type: "structure",
                required: [
                  "FederatedUserId",
                  "Arn"
                ],
                members: {
                  FederatedUserId: {},
                  Arn: {}
                }
              },
              PackedPolicySize: {
                type: "integer"
              }
            }
          }
        },
        GetSessionToken: {
          input: {
            type: "structure",
            members: {
              DurationSeconds: {
                type: "integer"
              },
              SerialNumber: {},
              TokenCode: {}
            }
          },
          output: {
            resultWrapper: "GetSessionTokenResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Si"
              }
            }
          }
        }
      },
      shapes: {
        S4: {
          type: "list",
          member: {
            type: "structure",
            members: {
              arn: {}
            }
          }
        },
        S8: {
          type: "list",
          member: {
            type: "structure",
            required: [
              "Key",
              "Value"
            ],
            members: {
              Key: {},
              Value: {}
            }
          }
        },
        Si: {
          type: "structure",
          required: [
            "AccessKeyId",
            "SecretAccessKey",
            "SessionToken",
            "Expiration"
          ],
          members: {
            AccessKeyId: {},
            SecretAccessKey: {},
            SessionToken: {},
            Expiration: {
              type: "timestamp"
            }
          }
        },
        Sn: {
          type: "structure",
          required: [
            "AssumedRoleId",
            "Arn"
          ],
          members: {
            AssumedRoleId: {},
            Arn: {}
          }
        }
      }
    };
  }
});

// node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json
var require_sts_2011_06_15_paginators = __commonJS({
  "node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json"(exports, module2) {
    module2.exports = {
      pagination: {}
    };
  }
});

// node_modules/aws-sdk/clients/sts.js
var require_sts2 = __commonJS({
  "node_modules/aws-sdk/clients/sts.js"(exports, module2) {
    require_node_loader();
    var AWS2 = require_core2();
    var Service = AWS2.Service;
    var apiLoader = AWS2.apiLoader;
    apiLoader.services["sts"] = {};
    AWS2.STS = Service.defineService("sts", ["2011-06-15"]);
    require_sts();
    Object.defineProperty(apiLoader.services["sts"], "2011-06-15", {
      get: function get() {
        var model = require_sts_2011_06_15_min();
        model.paginators = require_sts_2011_06_15_paginators().pagination;
        return model;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = AWS2.STS;
  }
});

// node_modules/aws-sdk/lib/credentials/temporary_credentials.js
var require_temporary_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/temporary_credentials.js"() {
    var AWS2 = require_core2();
    var STS = require_sts2();
    AWS2.TemporaryCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function TemporaryCredentials(params, masterCredentials) {
        AWS2.Credentials.call(this);
        this.loadMasterCredentials(masterCredentials);
        this.expired = true;
        this.params = params || {};
        if (this.params.RoleArn) {
          this.params.RoleSessionName = this.params.RoleSessionName || "temporary-credentials";
        }
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      load: function load(callback) {
        var self2 = this;
        self2.createClients();
        self2.masterCredentials.get(function() {
          self2.service.config.credentials = self2.masterCredentials;
          var operation = self2.params.RoleArn ? self2.service.assumeRole : self2.service.getSessionToken;
          operation.call(self2.service, function(err, data) {
            if (!err) {
              self2.service.credentialsFrom(data, self2);
            }
            callback(err);
          });
        });
      },
      loadMasterCredentials: function loadMasterCredentials(masterCredentials) {
        this.masterCredentials = masterCredentials || AWS2.config.credentials;
        while (this.masterCredentials.masterCredentials) {
          this.masterCredentials = this.masterCredentials.masterCredentials;
        }
        if (typeof this.masterCredentials.get !== "function") {
          this.masterCredentials = new AWS2.Credentials(this.masterCredentials);
        }
      },
      createClients: function() {
        this.service = this.service || new STS({ params: this.params });
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js
var require_chainable_temporary_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js"() {
    var AWS2 = require_core2();
    var STS = require_sts2();
    AWS2.ChainableTemporaryCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function ChainableTemporaryCredentials(options) {
        AWS2.Credentials.call(this);
        options = options || {};
        this.errorCode = "ChainableTemporaryCredentialsProviderFailure";
        this.expired = true;
        this.tokenCodeFn = null;
        var params = AWS2.util.copy(options.params) || {};
        if (params.RoleArn) {
          params.RoleSessionName = params.RoleSessionName || "temporary-credentials";
        }
        if (params.SerialNumber) {
          if (!options.tokenCodeFn || typeof options.tokenCodeFn !== "function") {
            throw new AWS2.util.error(new Error("tokenCodeFn must be a function when params.SerialNumber is given"), { code: this.errorCode });
          } else {
            this.tokenCodeFn = options.tokenCodeFn;
          }
        }
        var config = AWS2.util.merge({
          params,
          credentials: options.masterCredentials || AWS2.config.credentials
        }, options.stsConfig || {});
        this.service = new STS(config);
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      load: function load(callback) {
        var self2 = this;
        var operation = self2.service.config.params.RoleArn ? "assumeRole" : "getSessionToken";
        this.getTokenCode(function(err, tokenCode) {
          var params = {};
          if (err) {
            callback(err);
            return;
          }
          if (tokenCode) {
            params.TokenCode = tokenCode;
          }
          self2.service[operation](params, function(err2, data) {
            if (!err2) {
              self2.service.credentialsFrom(data, self2);
            }
            callback(err2);
          });
        });
      },
      getTokenCode: function getTokenCode(callback) {
        var self2 = this;
        if (this.tokenCodeFn) {
          this.tokenCodeFn(this.service.config.params.SerialNumber, function(err, token2) {
            if (err) {
              var message = err;
              if (err instanceof Error) {
                message = err.message;
              }
              callback(AWS2.util.error(new Error("Error fetching MFA token: " + message), { code: self2.errorCode }));
              return;
            }
            callback(null, token2);
          });
        } else {
          callback(null);
        }
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/web_identity_credentials.js
var require_web_identity_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/web_identity_credentials.js"() {
    var AWS2 = require_core2();
    var STS = require_sts2();
    AWS2.WebIdentityCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function WebIdentityCredentials(params, clientConfig) {
        AWS2.Credentials.call(this);
        this.expired = true;
        this.params = params;
        this.params.RoleSessionName = this.params.RoleSessionName || "web-identity";
        this.data = null;
        this._clientConfig = AWS2.util.copy(clientConfig || {});
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      load: function load(callback) {
        var self2 = this;
        self2.createClients();
        self2.service.assumeRoleWithWebIdentity(function(err, data) {
          self2.data = null;
          if (!err) {
            self2.data = data;
            self2.service.credentialsFrom(data, self2);
          }
          callback(err);
        });
      },
      createClients: function() {
        if (!this.service) {
          var stsConfig = AWS2.util.merge({}, this._clientConfig);
          stsConfig.params = this.params;
          this.service = new STS(stsConfig);
        }
      }
    });
  }
});

// node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json
var require_cognito_identity_2014_06_30_min = __commonJS({
  "node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json"(exports, module2) {
    module2.exports = {
      version: "2.0",
      metadata: {
        apiVersion: "2014-06-30",
        endpointPrefix: "cognito-identity",
        jsonVersion: "1.1",
        protocol: "json",
        serviceFullName: "Amazon Cognito Identity",
        serviceId: "Cognito Identity",
        signatureVersion: "v4",
        targetPrefix: "AWSCognitoIdentityService",
        uid: "cognito-identity-2014-06-30"
      },
      operations: {
        CreateIdentityPool: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolName",
              "AllowUnauthenticatedIdentities"
            ],
            members: {
              IdentityPoolName: {},
              AllowUnauthenticatedIdentities: {
                type: "boolean"
              },
              AllowClassicFlow: {
                type: "boolean"
              },
              SupportedLoginProviders: {
                shape: "S5"
              },
              DeveloperProviderName: {},
              OpenIdConnectProviderARNs: {
                shape: "S9"
              },
              CognitoIdentityProviders: {
                shape: "Sb"
              },
              SamlProviderARNs: {
                shape: "Sg"
              },
              IdentityPoolTags: {
                shape: "Sh"
              }
            }
          },
          output: {
            shape: "Sk"
          }
        },
        DeleteIdentities: {
          input: {
            type: "structure",
            required: [
              "IdentityIdsToDelete"
            ],
            members: {
              IdentityIdsToDelete: {
                type: "list",
                member: {}
              }
            }
          },
          output: {
            type: "structure",
            members: {
              UnprocessedIdentityIds: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    IdentityId: {},
                    ErrorCode: {}
                  }
                }
              }
            }
          }
        },
        DeleteIdentityPool: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {}
            }
          }
        },
        DescribeIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId"
            ],
            members: {
              IdentityId: {}
            }
          },
          output: {
            shape: "Sv"
          }
        },
        DescribeIdentityPool: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {}
            }
          },
          output: {
            shape: "Sk"
          }
        },
        GetCredentialsForIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId"
            ],
            members: {
              IdentityId: {},
              Logins: {
                shape: "S10"
              },
              CustomRoleArn: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              Credentials: {
                type: "structure",
                members: {
                  AccessKeyId: {},
                  SecretKey: {},
                  SessionToken: {},
                  Expiration: {
                    type: "timestamp"
                  }
                }
              }
            }
          },
          authtype: "none"
        },
        GetId: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              AccountId: {},
              IdentityPoolId: {},
              Logins: {
                shape: "S10"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {}
            }
          },
          authtype: "none"
        },
        GetIdentityPoolRoles: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              Roles: {
                shape: "S1c"
              },
              RoleMappings: {
                shape: "S1e"
              }
            }
          }
        },
        GetOpenIdToken: {
          input: {
            type: "structure",
            required: [
              "IdentityId"
            ],
            members: {
              IdentityId: {},
              Logins: {
                shape: "S10"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              Token: {}
            }
          },
          authtype: "none"
        },
        GetOpenIdTokenForDeveloperIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "Logins"
            ],
            members: {
              IdentityPoolId: {},
              IdentityId: {},
              Logins: {
                shape: "S10"
              },
              PrincipalTags: {
                shape: "S1s"
              },
              TokenDuration: {
                type: "long"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              Token: {}
            }
          }
        },
        GetPrincipalTagAttributeMap: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "IdentityProviderName"
            ],
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: "boolean"
              },
              PrincipalTags: {
                shape: "S1s"
              }
            }
          }
        },
        ListIdentities: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "MaxResults"
            ],
            members: {
              IdentityPoolId: {},
              MaxResults: {
                type: "integer"
              },
              NextToken: {},
              HideDisabled: {
                type: "boolean"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              Identities: {
                type: "list",
                member: {
                  shape: "Sv"
                }
              },
              NextToken: {}
            }
          }
        },
        ListIdentityPools: {
          input: {
            type: "structure",
            required: [
              "MaxResults"
            ],
            members: {
              MaxResults: {
                type: "integer"
              },
              NextToken: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPools: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    IdentityPoolId: {},
                    IdentityPoolName: {}
                  }
                }
              },
              NextToken: {}
            }
          }
        },
        ListTagsForResource: {
          input: {
            type: "structure",
            required: [
              "ResourceArn"
            ],
            members: {
              ResourceArn: {}
            }
          },
          output: {
            type: "structure",
            members: {
              Tags: {
                shape: "Sh"
              }
            }
          }
        },
        LookupDeveloperIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {},
              IdentityId: {},
              DeveloperUserIdentifier: {},
              MaxResults: {
                type: "integer"
              },
              NextToken: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              DeveloperUserIdentifierList: {
                type: "list",
                member: {}
              },
              NextToken: {}
            }
          }
        },
        MergeDeveloperIdentities: {
          input: {
            type: "structure",
            required: [
              "SourceUserIdentifier",
              "DestinationUserIdentifier",
              "DeveloperProviderName",
              "IdentityPoolId"
            ],
            members: {
              SourceUserIdentifier: {},
              DestinationUserIdentifier: {},
              DeveloperProviderName: {},
              IdentityPoolId: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {}
            }
          }
        },
        SetIdentityPoolRoles: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "Roles"
            ],
            members: {
              IdentityPoolId: {},
              Roles: {
                shape: "S1c"
              },
              RoleMappings: {
                shape: "S1e"
              }
            }
          }
        },
        SetPrincipalTagAttributeMap: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "IdentityProviderName"
            ],
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: "boolean"
              },
              PrincipalTags: {
                shape: "S1s"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: "boolean"
              },
              PrincipalTags: {
                shape: "S1s"
              }
            }
          }
        },
        TagResource: {
          input: {
            type: "structure",
            required: [
              "ResourceArn",
              "Tags"
            ],
            members: {
              ResourceArn: {},
              Tags: {
                shape: "Sh"
              }
            }
          },
          output: {
            type: "structure",
            members: {}
          }
        },
        UnlinkDeveloperIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId",
              "IdentityPoolId",
              "DeveloperProviderName",
              "DeveloperUserIdentifier"
            ],
            members: {
              IdentityId: {},
              IdentityPoolId: {},
              DeveloperProviderName: {},
              DeveloperUserIdentifier: {}
            }
          }
        },
        UnlinkIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId",
              "Logins",
              "LoginsToRemove"
            ],
            members: {
              IdentityId: {},
              Logins: {
                shape: "S10"
              },
              LoginsToRemove: {
                shape: "Sw"
              }
            }
          },
          authtype: "none"
        },
        UntagResource: {
          input: {
            type: "structure",
            required: [
              "ResourceArn",
              "TagKeys"
            ],
            members: {
              ResourceArn: {},
              TagKeys: {
                type: "list",
                member: {}
              }
            }
          },
          output: {
            type: "structure",
            members: {}
          }
        },
        UpdateIdentityPool: {
          input: {
            shape: "Sk"
          },
          output: {
            shape: "Sk"
          }
        }
      },
      shapes: {
        S5: {
          type: "map",
          key: {},
          value: {}
        },
        S9: {
          type: "list",
          member: {}
        },
        Sb: {
          type: "list",
          member: {
            type: "structure",
            members: {
              ProviderName: {},
              ClientId: {},
              ServerSideTokenCheck: {
                type: "boolean"
              }
            }
          }
        },
        Sg: {
          type: "list",
          member: {}
        },
        Sh: {
          type: "map",
          key: {},
          value: {}
        },
        Sk: {
          type: "structure",
          required: [
            "IdentityPoolId",
            "IdentityPoolName",
            "AllowUnauthenticatedIdentities"
          ],
          members: {
            IdentityPoolId: {},
            IdentityPoolName: {},
            AllowUnauthenticatedIdentities: {
              type: "boolean"
            },
            AllowClassicFlow: {
              type: "boolean"
            },
            SupportedLoginProviders: {
              shape: "S5"
            },
            DeveloperProviderName: {},
            OpenIdConnectProviderARNs: {
              shape: "S9"
            },
            CognitoIdentityProviders: {
              shape: "Sb"
            },
            SamlProviderARNs: {
              shape: "Sg"
            },
            IdentityPoolTags: {
              shape: "Sh"
            }
          }
        },
        Sv: {
          type: "structure",
          members: {
            IdentityId: {},
            Logins: {
              shape: "Sw"
            },
            CreationDate: {
              type: "timestamp"
            },
            LastModifiedDate: {
              type: "timestamp"
            }
          }
        },
        Sw: {
          type: "list",
          member: {}
        },
        S10: {
          type: "map",
          key: {},
          value: {}
        },
        S1c: {
          type: "map",
          key: {},
          value: {}
        },
        S1e: {
          type: "map",
          key: {},
          value: {
            type: "structure",
            required: [
              "Type"
            ],
            members: {
              Type: {},
              AmbiguousRoleResolution: {},
              RulesConfiguration: {
                type: "structure",
                required: [
                  "Rules"
                ],
                members: {
                  Rules: {
                    type: "list",
                    member: {
                      type: "structure",
                      required: [
                        "Claim",
                        "MatchType",
                        "Value",
                        "RoleARN"
                      ],
                      members: {
                        Claim: {},
                        MatchType: {},
                        Value: {},
                        RoleARN: {}
                      }
                    }
                  }
                }
              }
            }
          }
        },
        S1s: {
          type: "map",
          key: {},
          value: {}
        }
      }
    };
  }
});

// node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json
var require_cognito_identity_2014_06_30_paginators = __commonJS({
  "node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json"(exports, module2) {
    module2.exports = {
      pagination: {
        ListIdentityPools: {
          input_token: "NextToken",
          limit_key: "MaxResults",
          output_token: "NextToken",
          result_key: "IdentityPools"
        }
      }
    };
  }
});

// node_modules/aws-sdk/clients/cognitoidentity.js
var require_cognitoidentity = __commonJS({
  "node_modules/aws-sdk/clients/cognitoidentity.js"(exports, module2) {
    require_node_loader();
    var AWS2 = require_core2();
    var Service = AWS2.Service;
    var apiLoader = AWS2.apiLoader;
    apiLoader.services["cognitoidentity"] = {};
    AWS2.CognitoIdentity = Service.defineService("cognitoidentity", ["2014-06-30"]);
    Object.defineProperty(apiLoader.services["cognitoidentity"], "2014-06-30", {
      get: function get() {
        var model = require_cognito_identity_2014_06_30_min();
        model.paginators = require_cognito_identity_2014_06_30_paginators().pagination;
        return model;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = AWS2.CognitoIdentity;
  }
});

// node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js
var require_cognito_identity_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js"() {
    var AWS2 = require_core2();
    var CognitoIdentity = require_cognitoidentity();
    var STS = require_sts2();
    AWS2.CognitoIdentityCredentials = AWS2.util.inherit(AWS2.Credentials, {
      localStorageKey: {
        id: "aws.cognito.identity-id.",
        providers: "aws.cognito.identity-providers."
      },
      constructor: function CognitoIdentityCredentials(params, clientConfig) {
        AWS2.Credentials.call(this);
        this.expired = true;
        this.params = params;
        this.data = null;
        this._identityId = null;
        this._clientConfig = AWS2.util.copy(clientConfig || {});
        this.loadCachedId();
        var self2 = this;
        Object.defineProperty(this, "identityId", {
          get: function() {
            self2.loadCachedId();
            return self2._identityId || self2.params.IdentityId;
          },
          set: function(identityId) {
            self2._identityId = identityId;
          }
        });
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      load: function load(callback) {
        var self2 = this;
        self2.createClients();
        self2.data = null;
        self2._identityId = null;
        self2.getId(function(err) {
          if (!err) {
            if (!self2.params.RoleArn) {
              self2.getCredentialsForIdentity(callback);
            } else {
              self2.getCredentialsFromSTS(callback);
            }
          } else {
            self2.clearIdOnNotAuthorized(err);
            callback(err);
          }
        });
      },
      clearCachedId: function clearCache() {
        this._identityId = null;
        delete this.params.IdentityId;
        var poolId = this.params.IdentityPoolId;
        var loginId = this.params.LoginId || "";
        delete this.storage[this.localStorageKey.id + poolId + loginId];
        delete this.storage[this.localStorageKey.providers + poolId + loginId];
      },
      clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
        var self2 = this;
        if (err.code == "NotAuthorizedException") {
          self2.clearCachedId();
        }
      },
      getId: function getId(callback) {
        var self2 = this;
        if (typeof self2.params.IdentityId === "string") {
          return callback(null, self2.params.IdentityId);
        }
        self2.cognito.getId(function(err, data) {
          if (!err && data.IdentityId) {
            self2.params.IdentityId = data.IdentityId;
            callback(null, data.IdentityId);
          } else {
            callback(err);
          }
        });
      },
      loadCredentials: function loadCredentials(data, credentials) {
        if (!data || !credentials)
          return;
        credentials.expired = false;
        credentials.accessKeyId = data.Credentials.AccessKeyId;
        credentials.secretAccessKey = data.Credentials.SecretKey;
        credentials.sessionToken = data.Credentials.SessionToken;
        credentials.expireTime = data.Credentials.Expiration;
      },
      getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
        var self2 = this;
        self2.cognito.getCredentialsForIdentity(function(err, data) {
          if (!err) {
            self2.cacheId(data);
            self2.data = data;
            self2.loadCredentials(self2.data, self2);
          } else {
            self2.clearIdOnNotAuthorized(err);
          }
          callback(err);
        });
      },
      getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
        var self2 = this;
        self2.cognito.getOpenIdToken(function(err, data) {
          if (!err) {
            self2.cacheId(data);
            self2.params.WebIdentityToken = data.Token;
            self2.webIdentityCredentials.refresh(function(webErr) {
              if (!webErr) {
                self2.data = self2.webIdentityCredentials.data;
                self2.sts.credentialsFrom(self2.data, self2);
              }
              callback(webErr);
            });
          } else {
            self2.clearIdOnNotAuthorized(err);
            callback(err);
          }
        });
      },
      loadCachedId: function loadCachedId() {
        var self2 = this;
        if (AWS2.util.isBrowser() && !self2.params.IdentityId) {
          var id = self2.getStorage("id");
          if (id && self2.params.Logins) {
            var actualProviders = Object.keys(self2.params.Logins);
            var cachedProviders = (self2.getStorage("providers") || "").split(",");
            var intersect = cachedProviders.filter(function(n) {
              return actualProviders.indexOf(n) !== -1;
            });
            if (intersect.length !== 0) {
              self2.params.IdentityId = id;
            }
          } else if (id) {
            self2.params.IdentityId = id;
          }
        }
      },
      createClients: function() {
        var clientConfig = this._clientConfig;
        this.webIdentityCredentials = this.webIdentityCredentials || new AWS2.WebIdentityCredentials(this.params, clientConfig);
        if (!this.cognito) {
          var cognitoConfig = AWS2.util.merge({}, clientConfig);
          cognitoConfig.params = this.params;
          this.cognito = new CognitoIdentity(cognitoConfig);
        }
        this.sts = this.sts || new STS(clientConfig);
      },
      cacheId: function cacheId(data) {
        this._identityId = data.IdentityId;
        this.params.IdentityId = this._identityId;
        if (AWS2.util.isBrowser()) {
          this.setStorage("id", data.IdentityId);
          if (this.params.Logins) {
            this.setStorage("providers", Object.keys(this.params.Logins).join(","));
          }
        }
      },
      getStorage: function getStorage(key) {
        return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || "")];
      },
      setStorage: function setStorage(key, val) {
        try {
          this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || "")] = val;
        } catch (_) {
        }
      },
      storage: function() {
        try {
          var storage = AWS2.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === "object" ? window.localStorage : {};
          storage["aws.test-storage"] = "foobar";
          delete storage["aws.test-storage"];
          return storage;
        } catch (_) {
          return {};
        }
      }()
    });
  }
});

// node_modules/aws-sdk/lib/credentials/saml_credentials.js
var require_saml_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/saml_credentials.js"() {
    var AWS2 = require_core2();
    var STS = require_sts2();
    AWS2.SAMLCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function SAMLCredentials(params) {
        AWS2.Credentials.call(this);
        this.expired = true;
        this.params = params;
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      load: function load(callback) {
        var self2 = this;
        self2.createClients();
        self2.service.assumeRoleWithSAML(function(err, data) {
          if (!err) {
            self2.service.credentialsFrom(data, self2);
          }
          callback(err);
        });
      },
      createClients: function() {
        this.service = this.service || new STS({ params: this.params });
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/process_credentials.js
var require_process_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/process_credentials.js"() {
    var AWS2 = require_core2();
    var proc = require("child_process");
    var iniLoader = AWS2.util.iniLoader;
    AWS2.ProcessCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function ProcessCredentials(options) {
        AWS2.Credentials.call(this);
        options = options || {};
        this.filename = options.filename;
        this.profile = options.profile || process.env.AWS_PROFILE || AWS2.util.defaultProfile;
        this.get(options.callback || AWS2.util.fn.noop);
      },
      load: function load(callback) {
        var self2 = this;
        try {
          var profiles = AWS2.util.getProfilesFromSharedConfig(iniLoader, this.filename);
          var profile = profiles[this.profile] || {};
          if (Object.keys(profile).length === 0) {
            throw AWS2.util.error(new Error("Profile " + this.profile + " not found"), { code: "ProcessCredentialsProviderFailure" });
          }
          if (profile["credential_process"]) {
            this.loadViaCredentialProcess(profile, function(err, data) {
              if (err) {
                callback(err, null);
              } else {
                self2.expired = false;
                self2.accessKeyId = data.AccessKeyId;
                self2.secretAccessKey = data.SecretAccessKey;
                self2.sessionToken = data.SessionToken;
                if (data.Expiration) {
                  self2.expireTime = new Date(data.Expiration);
                }
                callback(null);
              }
            });
          } else {
            throw AWS2.util.error(new Error("Profile " + this.profile + " did not include credential process"), { code: "ProcessCredentialsProviderFailure" });
          }
        } catch (err) {
          callback(err);
        }
      },
      loadViaCredentialProcess: function loadViaCredentialProcess(profile, callback) {
        proc.exec(profile["credential_process"], { env: process.env }, function(err, stdOut, stdErr) {
          if (err) {
            callback(AWS2.util.error(new Error("credential_process returned error"), { code: "ProcessCredentialsProviderFailure" }), null);
          } else {
            try {
              var credData = JSON.parse(stdOut);
              if (credData.Expiration) {
                var currentTime = AWS2.util.date.getDate();
                var expireTime = new Date(credData.Expiration);
                if (expireTime < currentTime) {
                  throw Error("credential_process returned expired credentials");
                }
              }
              if (credData.Version !== 1) {
                throw Error("credential_process does not return Version == 1");
              }
              callback(null, credData);
            } catch (err2) {
              callback(AWS2.util.error(new Error(err2.message), { code: "ProcessCredentialsProviderFailure" }), null);
            }
          }
        });
      },
      refresh: function refresh(callback) {
        iniLoader.clearCachedFiles();
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }
    });
  }
});

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/xml2js/lib/defaults.js"(exports) {
    (function() {
      exports.defaults = {
        "0.1": {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: "@",
          charkey: "#",
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: "@@",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          emptyTag: ""
        },
        "0.2": {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: "$",
          charkey: "_",
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          preserveChildrenOrder: false,
          childkey: "$$",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          rootName: "root",
          xmldec: {
            "version": "1.0",
            "encoding": "UTF-8",
            "standalone": true
          },
          doctype: null,
          renderOpts: {
            "pretty": true,
            "indent": "  ",
            "newline": "\n"
          },
          headless: false,
          chunkSize: 1e4,
          emptyTag: "",
          cdata: false
        }
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/xmlbuilder/lib/Utility.js"(exports, module2) {
    (function() {
      var assign, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
      assign = function() {
        var i2, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i2 = 0, len = sources.length; i2 < len; i2++) {
            source = sources[i2];
            if (source != null) {
              for (key in source) {
                if (!hasProp.call(source, key))
                  continue;
                target[key] = source[key];
              }
            }
          }
        }
        return target;
      };
      isFunction = function(val) {
        return !!val && Object.prototype.toString.call(val) === "[object Function]";
      };
      isObject = function(val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
      };
      isArray = function(val) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === "[object Array]";
        }
      };
      isEmpty = function(val) {
        var key;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key in val) {
            if (!hasProp.call(val, key))
              continue;
            return false;
          }
          return true;
        }
      };
      isPlainObject = function(val) {
        var ctor, proto;
        return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
      };
      module2.exports.assign = assign;
      module2.exports.isFunction = isFunction;
      module2.exports.isObject = isObject;
      module2.exports.isArray = isArray;
      module2.exports.isEmpty = isEmpty;
      module2.exports.isPlainObject = isPlainObject;
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports, module2) {
    (function() {
      var XMLAttribute;
      module2.exports = XMLAttribute = function() {
        function XMLAttribute2(parent, name, value) {
          this.options = parent.options;
          this.stringify = parent.stringify;
          if (name == null) {
            throw new Error("Missing attribute name of element " + parent.name);
          }
          if (value == null) {
            throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
          }
          this.name = this.stringify.attName(name);
          this.value = this.stringify.attValue(value);
        }
        XMLAttribute2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLAttribute2.prototype.toString = function(options) {
          return this.options.writer.set(options).attribute(this);
        };
        return XMLAttribute2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLElement.js"(exports, module2) {
    (function() {
      var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction;
      XMLNode = require_XMLNode();
      XMLAttribute = require_XMLAttribute();
      module2.exports = XMLElement = function(superClass) {
        extend(XMLElement2, superClass);
        function XMLElement2(parent, name, attributes) {
          XMLElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing element name");
          }
          this.name = this.stringify.eleName(name);
          this.attributes = {};
          if (attributes != null) {
            this.attribute(attributes);
          }
          if (parent.isDocument) {
            this.isRoot = true;
            this.documentObject = parent;
            parent.rootObject = this;
          }
        }
        XMLElement2.prototype.clone = function() {
          var att, attName, clonedSelf, ref1;
          clonedSelf = Object.create(this);
          if (clonedSelf.isRoot) {
            clonedSelf.documentObject = null;
          }
          clonedSelf.attributes = {};
          ref1 = this.attributes;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName))
              continue;
            att = ref1[attName];
            clonedSelf.attributes[attName] = att.clone();
          }
          clonedSelf.children = [];
          this.children.forEach(function(child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
        XMLElement2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (name != null) {
            name = name.valueOf();
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (!this.options.skipNullAttributes || value != null) {
              this.attributes[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLElement2.prototype.removeAttribute = function(name) {
          var attName, i2, len;
          if (name == null) {
            throw new Error("Missing attribute name");
          }
          name = name.valueOf();
          if (Array.isArray(name)) {
            for (i2 = 0, len = name.length; i2 < len; i2++) {
              attName = name[i2];
              delete this.attributes[attName];
            }
          } else {
            delete this.attributes[name];
          }
          return this;
        };
        XMLElement2.prototype.toString = function(options) {
          return this.options.writer.set(options).element(this);
        };
        XMLElement2.prototype.att = function(name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.a = function(name, value) {
          return this.attribute(name, value);
        };
        return XMLElement2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCData.js"(exports, module2) {
    (function() {
      var XMLCData, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLCData = function(superClass) {
        extend(XMLCData2, superClass);
        function XMLCData2(parent, text) {
          XMLCData2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing CDATA text");
          }
          this.text = this.stringify.cdata(text);
        }
        XMLCData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCData2.prototype.toString = function(options) {
          return this.options.writer.set(options).cdata(this);
        };
        return XMLCData2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  "node_modules/xmlbuilder/lib/XMLComment.js"(exports, module2) {
    (function() {
      var XMLComment, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLComment = function(superClass) {
        extend(XMLComment2, superClass);
        function XMLComment2(parent, text) {
          XMLComment2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing comment text");
          }
          this.text = this.stringify.comment(text);
        }
        XMLComment2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLComment2.prototype.toString = function(options) {
          return this.options.writer.set(options).comment(this);
        };
        return XMLComment2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports, module2) {
    (function() {
      var XMLDeclaration, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      module2.exports = XMLDeclaration = function(superClass) {
        extend(XMLDeclaration2, superClass);
        function XMLDeclaration2(parent, version2, encoding, standalone) {
          var ref;
          XMLDeclaration2.__super__.constructor.call(this, parent);
          if (isObject(version2)) {
            ref = version2, version2 = ref.version, encoding = ref.encoding, standalone = ref.standalone;
          }
          if (!version2) {
            version2 = "1.0";
          }
          this.version = this.stringify.xmlVersion(version2);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        XMLDeclaration2.prototype.toString = function(options) {
          return this.options.writer.set(options).declaration(this);
        };
        return XMLDeclaration2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports, module2) {
    (function() {
      var XMLDTDAttList, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDAttList = function(superClass) {
        extend(XMLDTDAttList2, superClass);
        function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          XMLDTDAttList2.__super__.constructor.call(this, parent);
          if (elementName == null) {
            throw new Error("Missing DTD element name");
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name");
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type");
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default");
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT");
          }
          this.elementName = this.stringify.eleName(elementName);
          this.attributeName = this.stringify.attName(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          this.defaultValueType = defaultValueType;
        }
        XMLDTDAttList2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdAttList(this);
        };
        return XMLDTDAttList2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports, module2) {
    (function() {
      var XMLDTDEntity, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDEntity = function(superClass) {
        extend(XMLDTDEntity2, superClass);
        function XMLDTDEntity2(parent, pe, name, value) {
          XMLDTDEntity2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing entity name");
          }
          if (value == null) {
            throw new Error("Missing entity value");
          }
          this.pe = !!pe;
          this.name = this.stringify.eleName(name);
          if (!isObject(value)) {
            this.value = this.stringify.dtdEntityValue(value);
          } else {
            if (!value.pubID && !value.sysID) {
              throw new Error("Public and/or system identifiers are required for an external entity");
            }
            if (value.pubID && !value.sysID) {
              throw new Error("System identifier is required for a public external entity");
            }
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
            if (value.nData != null) {
              this.nData = this.stringify.dtdNData(value.nData);
            }
            if (this.pe && this.nData) {
              throw new Error("Notation declaration is not allowed in a parameter entity");
            }
          }
        }
        XMLDTDEntity2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdEntity(this);
        };
        return XMLDTDEntity2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports, module2) {
    (function() {
      var XMLDTDElement, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDElement = function(superClass) {
        extend(XMLDTDElement2, superClass);
        function XMLDTDElement2(parent, name, value) {
          XMLDTDElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD element name");
          }
          if (!value) {
            value = "(#PCDATA)";
          }
          if (Array.isArray(value)) {
            value = "(" + value.join(",") + ")";
          }
          this.name = this.stringify.eleName(name);
          this.value = this.stringify.dtdElementValue(value);
        }
        XMLDTDElement2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdElement(this);
        };
        return XMLDTDElement2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports, module2) {
    (function() {
      var XMLDTDNotation, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDNotation = function(superClass) {
        extend(XMLDTDNotation2, superClass);
        function XMLDTDNotation2(parent, name, value) {
          XMLDTDNotation2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing notation name");
          }
          if (!value.pubID && !value.sysID) {
            throw new Error("Public or system identifiers are required for an external entity");
          }
          this.name = this.stringify.eleName(name);
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
        }
        XMLDTDNotation2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdNotation(this);
        };
        return XMLDTDNotation2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocType.js"(exports, module2) {
    (function() {
      var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      module2.exports = XMLDocType = function(superClass) {
        extend(XMLDocType2, superClass);
        function XMLDocType2(parent, pubID, sysID) {
          var ref, ref1;
          XMLDocType2.__super__.constructor.call(this, parent);
          this.documentObject = parent;
          if (isObject(pubID)) {
            ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
          }
          if (sysID == null) {
            ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
        XMLDocType2.prototype.element = function(name, value) {
          var child;
          child = new XMLDTDElement(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var child;
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.entity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, false, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.pEntity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, true, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.notation = function(name, value) {
          var child;
          child = new XMLDTDNotation(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.toString = function(options) {
          return this.options.writer.set(options).docType(this);
        };
        XMLDocType2.prototype.ele = function(name, value) {
          return this.element(name, value);
        };
        XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocType2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocType2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        XMLDocType2.prototype.up = function() {
          return this.root() || this.documentObject;
        };
        return XMLDocType2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  "node_modules/xmlbuilder/lib/XMLRaw.js"(exports, module2) {
    (function() {
      var XMLNode, XMLRaw, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLRaw = function(superClass) {
        extend(XMLRaw2, superClass);
        function XMLRaw2(parent, text) {
          XMLRaw2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing raw text");
          }
          this.value = this.stringify.raw(text);
        }
        XMLRaw2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLRaw2.prototype.toString = function(options) {
          return this.options.writer.set(options).raw(this);
        };
        return XMLRaw2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  "node_modules/xmlbuilder/lib/XMLText.js"(exports, module2) {
    (function() {
      var XMLNode, XMLText, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLText = function(superClass) {
        extend(XMLText2, superClass);
        function XMLText2(parent, text) {
          XMLText2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing element text");
          }
          this.value = this.stringify.eleText(text);
        }
        XMLText2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLText2.prototype.toString = function(options) {
          return this.options.writer.set(options).text(this);
        };
        return XMLText2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports, module2) {
    (function() {
      var XMLNode, XMLProcessingInstruction, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLProcessingInstruction = function(superClass) {
        extend(XMLProcessingInstruction2, superClass);
        function XMLProcessingInstruction2(parent, target, value) {
          XMLProcessingInstruction2.__super__.constructor.call(this, parent);
          if (target == null) {
            throw new Error("Missing instruction target");
          }
          this.target = this.stringify.insTarget(target);
          if (value) {
            this.value = this.stringify.insValue(value);
          }
        }
        XMLProcessingInstruction2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLProcessingInstruction2.prototype.toString = function(options) {
          return this.options.writer.set(options).processingInstruction(this);
        };
        return XMLProcessingInstruction2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNode.js"(exports, module2) {
    (function() {
      var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      module2.exports = XMLNode = function() {
        function XMLNode2(parent) {
          this.parent = parent;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          this.children = [];
          if (!XMLElement) {
            XMLElement = require_XMLElement();
            XMLCData = require_XMLCData();
            XMLComment = require_XMLComment();
            XMLDeclaration = require_XMLDeclaration();
            XMLDocType = require_XMLDocType();
            XMLRaw = require_XMLRaw();
            XMLText = require_XMLText();
            XMLProcessingInstruction = require_XMLProcessingInstruction();
          }
        }
        XMLNode2.prototype.element = function(name, attributes, text) {
          var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
          lastChild = null;
          if (attributes == null) {
            attributes = {};
          }
          attributes = attributes.valueOf();
          if (!isObject(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          if (name != null) {
            name = name.valueOf();
          }
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              item = name[j];
              lastChild = this.element(item);
            }
          } else if (isFunction(name)) {
            lastChild = this.element(name.apply());
          } else if (isObject(name)) {
            for (key in name) {
              if (!hasProp.call(name, key))
                continue;
              val = name[key];
              if (isFunction(val)) {
                val = val.apply();
              }
              if (isObject(val) && isEmpty(val)) {
                val = null;
              }
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                for (k = 0, len1 = val.length; k < len1; k++) {
                  item = val[k];
                  childNode = {};
                  childNode[key] = item;
                  lastChild = this.element(childNode);
                }
              } else if (isObject(val)) {
                lastChild = this.element(key);
                lastChild.element(val);
              } else {
                lastChild = this.element(key, val);
              }
            }
          } else {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.text(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
              lastChild = this.cdata(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
              lastChild = this.comment(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
              lastChild = this.raw(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
              lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
            } else {
              lastChild = this.node(name, attributes, text);
            }
          }
          if (lastChild == null) {
            throw new Error("Could not create any elements with: " + name);
          }
          return lastChild;
        };
        XMLNode2.prototype.insertBefore = function(name, attributes, text) {
          var child, i2, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level");
          }
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.insertAfter = function(name, attributes, text) {
          var child, i2, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level");
          }
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.remove = function() {
          var i2, ref1;
          if (this.isRoot) {
            throw new Error("Cannot remove the root element");
          }
          i2 = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i2, i2 - i2 + 1].concat(ref1 = [])), ref1;
          return this.parent;
        };
        XMLNode2.prototype.node = function(name, attributes, text) {
          var child, ref1;
          if (name != null) {
            name = name.valueOf();
          }
          attributes || (attributes = {});
          attributes = attributes.valueOf();
          if (!isObject(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          child = new XMLElement(this, name, attributes);
          if (text != null) {
            child.text(text);
          }
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.text = function(value) {
          var child;
          child = new XMLText(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.cdata = function(value) {
          var child;
          child = new XMLCData(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.comment = function(value) {
          var child;
          child = new XMLComment(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.commentBefore = function(value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.commentAfter = function(value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.raw = function(value) {
          var child;
          child = new XMLRaw(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.instruction = function(target, value) {
          var insTarget, insValue, instruction, j, len;
          if (target != null) {
            target = target.valueOf();
          }
          if (value != null) {
            value = value.valueOf();
          }
          if (Array.isArray(target)) {
            for (j = 0, len = target.length; j < len; j++) {
              insTarget = target[j];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value);
            this.children.push(instruction);
          }
          return this;
        };
        XMLNode2.prototype.instructionBefore = function(target, value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.instructionAfter = function(target, value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.declaration = function(version2, encoding, standalone) {
          var doc, xmldec;
          doc = this.document();
          xmldec = new XMLDeclaration(doc, version2, encoding, standalone);
          if (doc.children[0] instanceof XMLDeclaration) {
            doc.children[0] = xmldec;
          } else {
            doc.children.unshift(xmldec);
          }
          return doc.root() || doc;
        };
        XMLNode2.prototype.doctype = function(pubID, sysID) {
          var child, doc, doctype, i2, j, k, len, len1, ref1, ref2;
          doc = this.document();
          doctype = new XMLDocType(doc, pubID, sysID);
          ref1 = doc.children;
          for (i2 = j = 0, len = ref1.length; j < len; i2 = ++j) {
            child = ref1[i2];
            if (child instanceof XMLDocType) {
              doc.children[i2] = doctype;
              return doctype;
            }
          }
          ref2 = doc.children;
          for (i2 = k = 0, len1 = ref2.length; k < len1; i2 = ++k) {
            child = ref2[i2];
            if (child.isRoot) {
              doc.children.splice(i2, 0, doctype);
              return doctype;
            }
          }
          doc.children.push(doctype);
          return doctype;
        };
        XMLNode2.prototype.up = function() {
          if (this.isRoot) {
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          }
          return this.parent;
        };
        XMLNode2.prototype.root = function() {
          var node;
          node = this;
          while (node) {
            if (node.isDocument) {
              return node.rootObject;
            } else if (node.isRoot) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.document = function() {
          var node;
          node = this;
          while (node) {
            if (node.isDocument) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.end = function(options) {
          return this.document().end(options);
        };
        XMLNode2.prototype.prev = function() {
          var i2;
          i2 = this.parent.children.indexOf(this);
          if (i2 < 1) {
            throw new Error("Already at the first node");
          }
          return this.parent.children[i2 - 1];
        };
        XMLNode2.prototype.next = function() {
          var i2;
          i2 = this.parent.children.indexOf(this);
          if (i2 === -1 || i2 === this.parent.children.length - 1) {
            throw new Error("Already at the last node");
          }
          return this.parent.children[i2 + 1];
        };
        XMLNode2.prototype.importDocument = function(doc) {
          var clonedRoot;
          clonedRoot = doc.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
        XMLNode2.prototype.ele = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.doc = function() {
          return this.document();
        };
        XMLNode2.prototype.dec = function(version2, encoding, standalone) {
          return this.declaration(version2, encoding, standalone);
        };
        XMLNode2.prototype.dtd = function(pubID, sysID) {
          return this.doctype(pubID, sysID);
        };
        XMLNode2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLNode2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.u = function() {
          return this.up();
        };
        XMLNode2.prototype.importXMLBuilder = function(doc) {
          return this.importDocument(doc);
        };
        return XMLNode2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports, module2) {
    (function() {
      var XMLStringifier, bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, hasProp = {}.hasOwnProperty;
      module2.exports = XMLStringifier = function() {
        function XMLStringifier2(options) {
          this.assertLegalChar = bind(this.assertLegalChar, this);
          var key, ref, value;
          options || (options = {});
          this.noDoubleEncoding = options.noDoubleEncoding;
          ref = options.stringify || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this[key] = value;
          }
        }
        XMLStringifier2.prototype.eleName = function(val) {
          val = "" + val || "";
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.eleText = function(val) {
          val = "" + val || "";
          return this.assertLegalChar(this.elEscape(val));
        };
        XMLStringifier2.prototype.cdata = function(val) {
          val = "" + val || "";
          val = val.replace("]]>", "]]]]><![CDATA[>");
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.comment = function(val) {
          val = "" + val || "";
          if (val.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.raw = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.attName = function(val) {
          return val = "" + val || "";
        };
        XMLStringifier2.prototype.attValue = function(val) {
          val = "" + val || "";
          return this.attEscape(val);
        };
        XMLStringifier2.prototype.insTarget = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.insValue = function(val) {
          val = "" + val || "";
          if (val.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlVersion = function(val) {
          val = "" + val || "";
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlEncoding = function(val) {
          val = "" + val || "";
          if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
            throw new Error("Invalid encoding: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlStandalone = function(val) {
          if (val) {
            return "yes";
          } else {
            return "no";
          }
        };
        XMLStringifier2.prototype.dtdPubID = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdSysID = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdElementValue = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdAttType = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdAttDefault = function(val) {
          if (val != null) {
            return "" + val || "";
          } else {
            return val;
          }
        };
        XMLStringifier2.prototype.dtdEntityValue = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdNData = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.convertAttKey = "@";
        XMLStringifier2.prototype.convertPIKey = "?";
        XMLStringifier2.prototype.convertTextKey = "#text";
        XMLStringifier2.prototype.convertCDataKey = "#cdata";
        XMLStringifier2.prototype.convertCommentKey = "#comment";
        XMLStringifier2.prototype.convertRawKey = "#raw";
        XMLStringifier2.prototype.assertLegalChar = function(str) {
          var res;
          res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
          if (res) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
          return str;
        };
        XMLStringifier2.prototype.elEscape = function(str) {
          var ampregex;
          ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
        };
        XMLStringifier2.prototype.attEscape = function(str) {
          var ampregex;
          ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
        };
        return XMLStringifier2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports, module2) {
    (function() {
      var XMLWriterBase, hasProp = {}.hasOwnProperty;
      module2.exports = XMLWriterBase = function() {
        function XMLWriterBase2(options) {
          var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
          options || (options = {});
          this.pretty = options.pretty || false;
          this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
          if (this.pretty) {
            this.indent = (ref1 = options.indent) != null ? ref1 : "  ";
            this.newline = (ref2 = options.newline) != null ? ref2 : "\n";
            this.offset = (ref3 = options.offset) != null ? ref3 : 0;
            this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
          } else {
            this.indent = "";
            this.newline = "";
            this.offset = 0;
            this.dontprettytextnodes = 0;
          }
          this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : "";
          if (this.spacebeforeslash === true) {
            this.spacebeforeslash = " ";
          }
          this.newlinedefault = this.newline;
          this.prettydefault = this.pretty;
          ref6 = options.writer || {};
          for (key in ref6) {
            if (!hasProp.call(ref6, key))
              continue;
            value = ref6[key];
            this[key] = value;
          }
        }
        XMLWriterBase2.prototype.set = function(options) {
          var key, ref, value;
          options || (options = {});
          if ("pretty" in options) {
            this.pretty = options.pretty;
          }
          if ("allowEmpty" in options) {
            this.allowEmpty = options.allowEmpty;
          }
          if (this.pretty) {
            this.indent = "indent" in options ? options.indent : "  ";
            this.newline = "newline" in options ? options.newline : "\n";
            this.offset = "offset" in options ? options.offset : 0;
            this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0;
          } else {
            this.indent = "";
            this.newline = "";
            this.offset = 0;
            this.dontprettytextnodes = 0;
          }
          this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : "";
          if (this.spacebeforeslash === true) {
            this.spacebeforeslash = " ";
          }
          this.newlinedefault = this.newline;
          this.prettydefault = this.pretty;
          ref = options.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this[key] = value;
          }
          return this;
        };
        XMLWriterBase2.prototype.space = function(level) {
          var indent;
          if (this.pretty) {
            indent = (level || 0) + this.offset + 1;
            if (indent > 0) {
              return new Array(indent).join(this.indent);
            } else {
              return "";
            }
          } else {
            return "";
          }
        };
        return XMLWriterBase2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports, module2) {
    (function() {
      var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStringWriter = function(superClass) {
        extend(XMLStringWriter2, superClass);
        function XMLStringWriter2(options) {
          XMLStringWriter2.__super__.constructor.call(this, options);
        }
        XMLStringWriter2.prototype.document = function(doc) {
          var child, i2, len, r2, ref;
          this.textispresent = false;
          r2 = "";
          ref = doc.children;
          for (i2 = 0, len = ref.length; i2 < len; i2++) {
            child = ref[i2];
            r2 += function() {
              switch (false) {
                case !(child instanceof XMLDeclaration):
                  return this.declaration(child);
                case !(child instanceof XMLDocType):
                  return this.docType(child);
                case !(child instanceof XMLComment):
                  return this.comment(child);
                case !(child instanceof XMLProcessingInstruction):
                  return this.processingInstruction(child);
                default:
                  return this.element(child, 0);
              }
            }.call(this);
          }
          if (this.pretty && r2.slice(-this.newline.length) === this.newline) {
            r2 = r2.slice(0, -this.newline.length);
          }
          return r2;
        };
        XMLStringWriter2.prototype.attribute = function(att) {
          return " " + att.name + '="' + att.value + '"';
        };
        XMLStringWriter2.prototype.cdata = function(node, level) {
          return this.space(level) + "<![CDATA[" + node.text + "]]>" + this.newline;
        };
        XMLStringWriter2.prototype.comment = function(node, level) {
          return this.space(level) + "<!-- " + node.text + " -->" + this.newline;
        };
        XMLStringWriter2.prototype.declaration = function(node, level) {
          var r2;
          r2 = this.space(level);
          r2 += '<?xml version="' + node.version + '"';
          if (node.encoding != null) {
            r2 += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r2 += ' standalone="' + node.standalone + '"';
          }
          r2 += this.spacebeforeslash + "?>";
          r2 += this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.docType = function(node, level) {
          var child, i2, len, r2, ref;
          level || (level = 0);
          r2 = this.space(level);
          r2 += "<!DOCTYPE " + node.root().name;
          if (node.pubID && node.sysID) {
            r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r2 += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r2 += " [";
            r2 += this.newline;
            ref = node.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              r2 += function() {
                switch (false) {
                  case !(child instanceof XMLDTDAttList):
                    return this.dtdAttList(child, level + 1);
                  case !(child instanceof XMLDTDElement):
                    return this.dtdElement(child, level + 1);
                  case !(child instanceof XMLDTDEntity):
                    return this.dtdEntity(child, level + 1);
                  case !(child instanceof XMLDTDNotation):
                    return this.dtdNotation(child, level + 1);
                  case !(child instanceof XMLCData):
                    return this.cdata(child, level + 1);
                  case !(child instanceof XMLComment):
                    return this.comment(child, level + 1);
                  case !(child instanceof XMLProcessingInstruction):
                    return this.processingInstruction(child, level + 1);
                  default:
                    throw new Error("Unknown DTD node type: " + child.constructor.name);
                }
              }.call(this);
            }
            r2 += "]";
          }
          r2 += this.spacebeforeslash + ">";
          r2 += this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.element = function(node, level) {
          var att, child, i2, j, len, len1, name, r2, ref, ref1, ref2, space, textispresentwasset;
          level || (level = 0);
          textispresentwasset = false;
          if (this.textispresent) {
            this.newline = "";
            this.pretty = false;
          } else {
            this.newline = this.newlinedefault;
            this.pretty = this.prettydefault;
          }
          space = this.space(level);
          r2 = "";
          r2 += space + "<" + node.name;
          ref = node.attributes;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            r2 += this.attribute(att);
          }
          if (node.children.length === 0 || node.children.every(function(e2) {
            return e2.value === "";
          })) {
            if (this.allowEmpty) {
              r2 += "></" + node.name + ">" + this.newline;
            } else {
              r2 += this.spacebeforeslash + "/>" + this.newline;
            }
          } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
            r2 += ">";
            r2 += node.children[0].value;
            r2 += "</" + node.name + ">" + this.newline;
          } else {
            if (this.dontprettytextnodes) {
              ref1 = node.children;
              for (i2 = 0, len = ref1.length; i2 < len; i2++) {
                child = ref1[i2];
                if (child.value != null) {
                  this.textispresent++;
                  textispresentwasset = true;
                  break;
                }
              }
            }
            if (this.textispresent) {
              this.newline = "";
              this.pretty = false;
              space = this.space(level);
            }
            r2 += ">" + this.newline;
            ref2 = node.children;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              child = ref2[j];
              r2 += function() {
                switch (false) {
                  case !(child instanceof XMLCData):
                    return this.cdata(child, level + 1);
                  case !(child instanceof XMLComment):
                    return this.comment(child, level + 1);
                  case !(child instanceof XMLElement):
                    return this.element(child, level + 1);
                  case !(child instanceof XMLRaw):
                    return this.raw(child, level + 1);
                  case !(child instanceof XMLText):
                    return this.text(child, level + 1);
                  case !(child instanceof XMLProcessingInstruction):
                    return this.processingInstruction(child, level + 1);
                  default:
                    throw new Error("Unknown XML node type: " + child.constructor.name);
                }
              }.call(this);
            }
            if (textispresentwasset) {
              this.textispresent--;
            }
            if (!this.textispresent) {
              this.newline = this.newlinedefault;
              this.pretty = this.prettydefault;
            }
            r2 += space + "</" + node.name + ">" + this.newline;
          }
          return r2;
        };
        XMLStringWriter2.prototype.processingInstruction = function(node, level) {
          var r2;
          r2 = this.space(level) + "<?" + node.target;
          if (node.value) {
            r2 += " " + node.value;
          }
          r2 += this.spacebeforeslash + "?>" + this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.raw = function(node, level) {
          return this.space(level) + node.value + this.newline;
        };
        XMLStringWriter2.prototype.text = function(node, level) {
          return this.space(level) + node.value + this.newline;
        };
        XMLStringWriter2.prototype.dtdAttList = function(node, level) {
          var r2;
          r2 = this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r2 += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r2 += ' "' + node.defaultValue + '"';
          }
          r2 += this.spacebeforeslash + ">" + this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.dtdElement = function(node, level) {
          return this.space(level) + "<!ELEMENT " + node.name + " " + node.value + this.spacebeforeslash + ">" + this.newline;
        };
        XMLStringWriter2.prototype.dtdEntity = function(node, level) {
          var r2;
          r2 = this.space(level) + "<!ENTITY";
          if (node.pe) {
            r2 += " %";
          }
          r2 += " " + node.name;
          if (node.value) {
            r2 += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r2 += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r2 += " NDATA " + node.nData;
            }
          }
          r2 += this.spacebeforeslash + ">" + this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.dtdNotation = function(node, level) {
          var r2;
          r2 = this.space(level) + "<!NOTATION " + node.name;
          if (node.pubID && node.sysID) {
            r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r2 += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r2 += ' SYSTEM "' + node.sysID + '"';
          }
          r2 += this.spacebeforeslash + ">" + this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.openNode = function(node, level) {
          var att, name, r2, ref;
          level || (level = 0);
          if (node instanceof XMLElement) {
            r2 = this.space(level) + "<" + node.name;
            ref = node.attributes;
            for (name in ref) {
              if (!hasProp.call(ref, name))
                continue;
              att = ref[name];
              r2 += this.attribute(att);
            }
            r2 += (node.children ? ">" : "/>") + this.newline;
            return r2;
          } else {
            r2 = this.space(level) + "<!DOCTYPE " + node.rootNodeName;
            if (node.pubID && node.sysID) {
              r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r2 += ' SYSTEM "' + node.sysID + '"';
            }
            r2 += (node.children ? " [" : ">") + this.newline;
            return r2;
          }
        };
        XMLStringWriter2.prototype.closeNode = function(node, level) {
          level || (level = 0);
          switch (false) {
            case !(node instanceof XMLElement):
              return this.space(level) + "</" + node.name + ">" + this.newline;
            case !(node instanceof XMLDocType):
              return this.space(level) + "]>" + this.newline;
          }
        };
        return XMLStringWriter2;
      }(XMLWriterBase);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocument.js"(exports, module2) {
    (function() {
      var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isPlainObject = require_Utility().isPlainObject;
      XMLNode = require_XMLNode();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocument = function(superClass) {
        extend(XMLDocument2, superClass);
        function XMLDocument2(options) {
          XMLDocument2.__super__.constructor.call(this, null);
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.stringify = new XMLStringifier(options);
          this.isDocument = true;
        }
        XMLDocument2.prototype.end = function(writer) {
          var writerOptions;
          if (!writer) {
            writer = this.options.writer;
          } else if (isPlainObject(writer)) {
            writerOptions = writer;
            writer = this.options.writer.set(writerOptions);
          }
          return writer.document(this);
        };
        XMLDocument2.prototype.toString = function(options) {
          return this.options.writer.set(options).document(this);
        };
        return XMLDocument2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports, module2) {
    (function() {
      var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocumentCB = function() {
        function XMLDocumentCB2(options, onData, onEnd) {
          var writerOptions;
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter(options);
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter(writerOptions);
          }
          this.options = options;
          this.writer = options.writer;
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function() {
          };
          this.onEndCallback = onEnd || function() {
          };
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        XMLDocumentCB2.prototype.node = function(name, attributes, text) {
          var ref1;
          if (name == null) {
            throw new Error("Missing node name");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error("Document can only have one root node");
          }
          this.openCurrent();
          name = name.valueOf();
          if (attributes == null) {
            attributes = {};
          }
          attributes = attributes.valueOf();
          if (!isObject(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          this.currentNode = new XMLElement(this, name, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text != null) {
            this.text(text);
          }
          return this;
        };
        XMLDocumentCB2.prototype.element = function(name, attributes, text) {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.dtdElement.apply(this, arguments);
          } else {
            return this.node(name, attributes, text);
          }
        };
        XMLDocumentCB2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error("att() can only be used immediately after an ele() call in callback mode");
          }
          if (name != null) {
            name = name.valueOf();
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (!this.options.skipNullAttributes || value != null) {
              this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.text = function(value) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value);
          this.onData(this.writer.text(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.cdata = function(value) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value);
          this.onData(this.writer.cdata(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.comment = function(value) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value);
          this.onData(this.writer.comment(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.raw = function(value) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value);
          this.onData(this.writer.raw(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.instruction = function(target, value) {
          var i2, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = target.valueOf();
          }
          if (value != null) {
            value = value.valueOf();
          }
          if (Array.isArray(target)) {
            for (i2 = 0, len = target.length; i2 < len; i2++) {
              insTarget = target[i2];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            node = new XMLProcessingInstruction(this, target, value);
            this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
          }
          return this;
        };
        XMLDocumentCB2.prototype.declaration = function(version2, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node");
          }
          node = new XMLDeclaration(this, version2, encoding, standalone);
          this.onData(this.writer.declaration(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
          this.openCurrent();
          if (root == null) {
            throw new Error("Missing root node name");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        };
        XMLDocumentCB2.prototype.dtdElement = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name, value);
          this.onData(this.writer.dtdElement(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.entity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name, value);
          this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.pEntity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name, value);
          this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.notation = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name, value);
          this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.up = function() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        };
        XMLDocumentCB2.prototype.end = function() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        };
        XMLDocumentCB2.prototype.openCurrent = function() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        };
        XMLDocumentCB2.prototype.openNode = function(node) {
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
              this.root = node;
            }
            this.onData(this.writer.openNode(node, this.currentLevel));
            return node.isOpen = true;
          }
        };
        XMLDocumentCB2.prototype.closeNode = function(node) {
          if (!node.isClosed) {
            this.onData(this.writer.closeNode(node, this.currentLevel));
            return node.isClosed = true;
          }
        };
        XMLDocumentCB2.prototype.onData = function(chunk) {
          this.documentStarted = true;
          return this.onDataCallback(chunk);
        };
        XMLDocumentCB2.prototype.onEnd = function() {
          this.documentCompleted = true;
          return this.onEndCallback();
        };
        XMLDocumentCB2.prototype.ele = function() {
          return this.element.apply(this, arguments);
        };
        XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.dec = function(version2, encoding, standalone) {
          return this.declaration(version2, encoding, standalone);
        };
        XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
          return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLDocumentCB2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLDocumentCB2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.att = function() {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.a = function() {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocumentCB2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocumentCB2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        return XMLDocumentCB2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports, module2) {
    (function() {
      var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStreamWriter = function(superClass) {
        extend(XMLStreamWriter2, superClass);
        function XMLStreamWriter2(stream, options) {
          XMLStreamWriter2.__super__.constructor.call(this, options);
          this.stream = stream;
        }
        XMLStreamWriter2.prototype.document = function(doc) {
          var child, i2, j, len, len1, ref, ref1, results;
          ref = doc.children;
          for (i2 = 0, len = ref.length; i2 < len; i2++) {
            child = ref[i2];
            child.isLastRootNode = false;
          }
          doc.children[doc.children.length - 1].isLastRootNode = true;
          ref1 = doc.children;
          results = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            child = ref1[j];
            switch (false) {
              case !(child instanceof XMLDeclaration):
                results.push(this.declaration(child));
                break;
              case !(child instanceof XMLDocType):
                results.push(this.docType(child));
                break;
              case !(child instanceof XMLComment):
                results.push(this.comment(child));
                break;
              case !(child instanceof XMLProcessingInstruction):
                results.push(this.processingInstruction(child));
                break;
              default:
                results.push(this.element(child));
            }
          }
          return results;
        };
        XMLStreamWriter2.prototype.attribute = function(att) {
          return this.stream.write(" " + att.name + '="' + att.value + '"');
        };
        XMLStreamWriter2.prototype.cdata = function(node, level) {
          return this.stream.write(this.space(level) + "<![CDATA[" + node.text + "]]>" + this.endline(node));
        };
        XMLStreamWriter2.prototype.comment = function(node, level) {
          return this.stream.write(this.space(level) + "<!-- " + node.text + " -->" + this.endline(node));
        };
        XMLStreamWriter2.prototype.declaration = function(node, level) {
          this.stream.write(this.space(level));
          this.stream.write('<?xml version="' + node.version + '"');
          if (node.encoding != null) {
            this.stream.write(' encoding="' + node.encoding + '"');
          }
          if (node.standalone != null) {
            this.stream.write(' standalone="' + node.standalone + '"');
          }
          this.stream.write(this.spacebeforeslash + "?>");
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.docType = function(node, level) {
          var child, i2, len, ref;
          level || (level = 0);
          this.stream.write(this.space(level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node));
            ref = node.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              switch (false) {
                case !(child instanceof XMLDTDAttList):
                  this.dtdAttList(child, level + 1);
                  break;
                case !(child instanceof XMLDTDElement):
                  this.dtdElement(child, level + 1);
                  break;
                case !(child instanceof XMLDTDEntity):
                  this.dtdEntity(child, level + 1);
                  break;
                case !(child instanceof XMLDTDNotation):
                  this.dtdNotation(child, level + 1);
                  break;
                case !(child instanceof XMLCData):
                  this.cdata(child, level + 1);
                  break;
                case !(child instanceof XMLComment):
                  this.comment(child, level + 1);
                  break;
                case !(child instanceof XMLProcessingInstruction):
                  this.processingInstruction(child, level + 1);
                  break;
                default:
                  throw new Error("Unknown DTD node type: " + child.constructor.name);
              }
            }
            this.stream.write("]");
          }
          this.stream.write(this.spacebeforeslash + ">");
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.element = function(node, level) {
          var att, child, i2, len, name, ref, ref1, space;
          level || (level = 0);
          space = this.space(level);
          this.stream.write(space + "<" + node.name);
          ref = node.attributes;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            this.attribute(att);
          }
          if (node.children.length === 0 || node.children.every(function(e2) {
            return e2.value === "";
          })) {
            if (this.allowEmpty) {
              this.stream.write("></" + node.name + ">");
            } else {
              this.stream.write(this.spacebeforeslash + "/>");
            }
          } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
            this.stream.write(">");
            this.stream.write(node.children[0].value);
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.newline);
            ref1 = node.children;
            for (i2 = 0, len = ref1.length; i2 < len; i2++) {
              child = ref1[i2];
              switch (false) {
                case !(child instanceof XMLCData):
                  this.cdata(child, level + 1);
                  break;
                case !(child instanceof XMLComment):
                  this.comment(child, level + 1);
                  break;
                case !(child instanceof XMLElement):
                  this.element(child, level + 1);
                  break;
                case !(child instanceof XMLRaw):
                  this.raw(child, level + 1);
                  break;
                case !(child instanceof XMLText):
                  this.text(child, level + 1);
                  break;
                case !(child instanceof XMLProcessingInstruction):
                  this.processingInstruction(child, level + 1);
                  break;
                default:
                  throw new Error("Unknown XML node type: " + child.constructor.name);
              }
            }
            this.stream.write(space + "</" + node.name + ">");
          }
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.processingInstruction = function(node, level) {
          this.stream.write(this.space(level) + "<?" + node.target);
          if (node.value) {
            this.stream.write(" " + node.value);
          }
          return this.stream.write(this.spacebeforeslash + "?>" + this.endline(node));
        };
        XMLStreamWriter2.prototype.raw = function(node, level) {
          return this.stream.write(this.space(level) + node.value + this.endline(node));
        };
        XMLStreamWriter2.prototype.text = function(node, level) {
          return this.stream.write(this.space(level) + node.value + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdAttList = function(node, level) {
          this.stream.write(this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType);
          if (node.defaultValueType !== "#DEFAULT") {
            this.stream.write(" " + node.defaultValueType);
          }
          if (node.defaultValue) {
            this.stream.write(' "' + node.defaultValue + '"');
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdElement = function(node, level) {
          this.stream.write(this.space(level) + "<!ELEMENT " + node.name + " " + node.value);
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdEntity = function(node, level) {
          this.stream.write(this.space(level) + "<!ENTITY");
          if (node.pe) {
            this.stream.write(" %");
          }
          this.stream.write(" " + node.name);
          if (node.value) {
            this.stream.write(' "' + node.value + '"');
          } else {
            if (node.pubID && node.sysID) {
              this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
            } else if (node.sysID) {
              this.stream.write(' SYSTEM "' + node.sysID + '"');
            }
            if (node.nData) {
              this.stream.write(" NDATA " + node.nData);
            }
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdNotation = function(node, level) {
          this.stream.write(this.space(level) + "<!NOTATION " + node.name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.pubID) {
            this.stream.write(' PUBLIC "' + node.pubID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.endline = function(node) {
          if (!node.isLastRootNode) {
            return this.newline;
          } else {
            return "";
          }
        };
        return XMLStreamWriter2;
      }(XMLWriterBase);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/xmlbuilder/lib/index.js"(exports, module2) {
    (function() {
      var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
      ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      module2.exports.create = function(name, xmldec, doctype, options) {
        var doc, root;
        if (name == null) {
          throw new Error("Root element needs a name");
        }
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root = doc.element(name);
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.doctype(options);
          }
        }
        return root;
      };
      module2.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
          ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };
      module2.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
      };
      module2.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/builder.js
var require_builder3 = __commonJS({
  "node_modules/xml2js/lib/builder.js"(exports) {
    (function() {
      "use strict";
      var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
      builder = require_lib2();
      defaults = require_defaults().defaults;
      requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
      };
      wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
      };
      escapeCDATA = function(entry) {
        return entry.replace("]]>", "]]]]><![CDATA[>");
      };
      exports.Builder = function() {
        function Builder(opts) {
          var key, ref, value;
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value = opts[key];
            this.options[key] = value;
          }
        }
        Builder.prototype.buildObject = function(rootObj) {
          var attrkey, charkey, render, rootElement, rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render = function(_this) {
            return function(element, obj) {
              var attr, child, entry, index, key, value;
              if (typeof obj !== "object") {
                if (_this.options.cdata && requiresCDATA(obj)) {
                  element.raw(wrapCDATA(obj));
                } else {
                  element.txt(obj);
                }
              } else if (Array.isArray(obj)) {
                for (index in obj) {
                  if (!hasProp.call(obj, index))
                    continue;
                  child = obj[index];
                  for (key in child) {
                    entry = child[key];
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else {
                for (key in obj) {
                  if (!hasProp.call(obj, key))
                    continue;
                  child = obj[key];
                  if (key === attrkey) {
                    if (typeof child === "object") {
                      for (attr in child) {
                        value = child[attr];
                        element = element.att(attr, value);
                      }
                    }
                  } else if (key === charkey) {
                    if (_this.options.cdata && requiresCDATA(child)) {
                      element = element.raw(wrapCDATA(child));
                    } else {
                      element = element.txt(child);
                    }
                  } else if (Array.isArray(child)) {
                    for (index in child) {
                      if (!hasProp.call(child, index))
                        continue;
                      entry = child[index];
                      if (typeof entry === "string") {
                        if (_this.options.cdata && requiresCDATA(entry)) {
                          element = element.ele(key).raw(wrapCDATA(entry)).up();
                        } else {
                          element = element.ele(key, entry).up();
                        }
                      } else {
                        element = render(element.ele(key), entry).up();
                      }
                    }
                  } else if (typeof child === "object") {
                    element = render(element.ele(key), child).up();
                  } else {
                    if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                      element = element.ele(key).raw(wrapCDATA(child)).up();
                    } else {
                      if (child == null) {
                        child = "";
                      }
                      element = element.ele(key, child.toString()).up();
                    }
                  }
                }
              }
              return element;
            };
          }(this);
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless,
            allowSurrogateChars: this.options.allowSurrogateChars
          });
          return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
      }();
    }).call(exports);
  }
});

// node_modules/xml2js/node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/xml2js/node_modules/sax/lib/sax.js"(exports) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S2.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F2() {
          }
          F2.prototype = o;
          var newf = new F2();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i2 in o)
            if (o.hasOwnProperty(i2))
              a.push(i2);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
          var len = parser[buffers[i2]].length;
          if (len > maxAllowed) {
            switch (buffers[i2]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error2(parser, "Max buffer length exceeded: " + buffers[i2]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m2 = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m2 + parser.position;
      }
      function clearBuffers(parser) {
        for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
          parser[buffers[i2]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream3;
      try {
        Stream3 = require("stream").Stream;
      } catch (ex) {
        Stream3 = function() {
        };
      }
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream3.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h2) {
              if (!h2) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h2;
                return h2;
              }
              me.on(ev, h2);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream3.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require("string_decoder").StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream3.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S2 = 0;
      sax.STATE = {
        BEGIN: S2++,
        BEGIN_WHITESPACE: S2++,
        TEXT: S2++,
        TEXT_ENTITY: S2++,
        OPEN_WAKA: S2++,
        SGML_DECL: S2++,
        SGML_DECL_QUOTED: S2++,
        DOCTYPE: S2++,
        DOCTYPE_QUOTED: S2++,
        DOCTYPE_DTD: S2++,
        DOCTYPE_DTD_QUOTED: S2++,
        COMMENT_STARTING: S2++,
        COMMENT: S2++,
        COMMENT_ENDING: S2++,
        COMMENT_ENDED: S2++,
        CDATA: S2++,
        CDATA_ENDING: S2++,
        CDATA_ENDING_2: S2++,
        PROC_INST: S2++,
        PROC_INST_BODY: S2++,
        PROC_INST_ENDING: S2++,
        OPEN_TAG: S2++,
        OPEN_TAG_SLASH: S2++,
        ATTRIB: S2++,
        ATTRIB_NAME: S2++,
        ATTRIB_NAME_SAW_WHITE: S2++,
        ATTRIB_VALUE: S2++,
        ATTRIB_VALUE_QUOTED: S2++,
        ATTRIB_VALUE_CLOSED: S2++,
        ATTRIB_VALUE_UNQUOTED: S2++,
        ATTRIB_VALUE_ENTITY_Q: S2++,
        ATTRIB_VALUE_ENTITY_U: S2++,
        CLOSE_TAG: S2++,
        CLOSE_TAG_SAW_WHITE: S2++,
        SCRIPT: S2++,
        SCRIPT_ENDING: S2++
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e2 = sax.ENTITIES[key];
        var s3 = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
        sax.ENTITIES[key] = s3;
      });
      for (var s2 in sax.STATE) {
        sax.STATE[sax.STATE[s2]] = s2;
      }
      S2 = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error2(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
          error2(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error2(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i2 = name.indexOf(":");
        var qualName = i2 < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i2 = 0, l = parser.attribList.length; i2 < l; i2++) {
            var nv = parser.attribList[i2];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S2.SCRIPT;
          } else {
            parser.state = S2.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S2.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S2.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t2 = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t2--) {
          var close = parser.tags[t2];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t2 < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S2.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s3 = parser.tags.length;
        while (s3-- > t2) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x2 = {};
          for (var i2 in tag.ns) {
            x2[i2] = tag.ns[i2];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t2 === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S2.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S2.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S2.TEXT;
        }
      }
      function charAt(chunk, i2) {
        var result = "";
        if (i2 < chunk.length) {
          result = chunk.charAt(i2);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error2(parser, "Cannot write after close. Assign an onready handler.");
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i2 = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i2++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S2.BEGIN:
              parser.state = S2.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S2.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S2.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i2 - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i2++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i2 - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S2.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S2.SCRIPT:
              if (c === "<") {
                parser.state = S2.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S2.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S2.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S2.SCRIPT;
              }
              continue;
            case S2.OPEN_WAKA:
              if (c === "!") {
                parser.state = S2.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S2.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S2.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S2.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S2.TEXT;
              }
              continue;
            case S2.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S2.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S2.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S2.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(parser, "Inappropriately located doctype declaration");
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S2.TEXT;
              } else if (isQuote(c)) {
                parser.state = S2.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S2.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S2.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S2.DOCTYPE:
              if (c === ">") {
                parser.state = S2.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S2.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S2.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S2.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S2.DOCTYPE;
              }
              continue;
            case S2.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S2.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S2.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S2.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S2.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S2.COMMENT:
              if (c === "-") {
                parser.state = S2.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S2.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S2.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S2.COMMENT;
              }
              continue;
            case S2.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S2.COMMENT;
              } else {
                parser.state = S2.TEXT;
              }
              continue;
            case S2.CDATA:
              if (c === "]") {
                parser.state = S2.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S2.CDATA_ENDING:
              if (c === "]") {
                parser.state = S2.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S2.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.PROC_INST:
              if (c === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S2.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S2.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S2.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S2.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S2.PROC_INST_BODY;
              }
              continue;
            case S2.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S2.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S2.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S2.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S2.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S2.ATTRIB_VALUE_CLOSED;
              continue;
            case S2.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S2.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S2.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S2.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S2.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S2.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S2.TEXT_ENTITY:
            case S2.ATTRIB_VALUE_ENTITY_Q:
            case S2.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S2.TEXT_ENTITY:
                  returnState = S2.TEXT;
                  buffer = "textNode";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S2.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_U:
                  returnState = S2.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS({
  "node_modules/xml2js/lib/bom.js"(exports) {
    (function() {
      "use strict";
      exports.stripBOM = function(str) {
        if (str[0] === "\uFEFF") {
          return str.substring(1);
        } else {
          return str;
        }
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS({
  "node_modules/xml2js/lib/processors.js"(exports) {
    (function() {
      "use strict";
      var prefixMatch;
      prefixMatch = new RegExp(/(?!xmlns)^.*:/);
      exports.normalize = function(str) {
        return str.toLowerCase();
      };
      exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
      };
      exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, "");
      };
      exports.parseNumbers = function(str) {
        if (!isNaN(str)) {
          str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
      };
      exports.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) {
          str = str.toLowerCase() === "true";
        }
        return str;
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/parser.js
var require_parser2 = __commonJS({
  "node_modules/xml2js/lib/parser.js"(exports) {
    (function() {
      "use strict";
      var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate2, bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      sax = require_sax();
      events = require("events");
      bom = require_bom();
      processors = require_processors();
      setImmediate2 = require("timers").setImmediate;
      defaults = require_defaults().defaults;
      isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
      };
      processItem = function(processors2, item, key) {
        var i2, len, process2;
        for (i2 = 0, len = processors2.length; i2 < len; i2++) {
          process2 = processors2[i2];
          item = process2(item, key);
        }
        return item;
      };
      exports.Parser = function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
          this.parseString = bind(this.parseString, this);
          this.reset = bind(this.reset, this);
          this.assignOrPush = bind(this.assignOrPush, this);
          this.processAsync = bind(this.processAsync, this);
          var key, ref, value;
          if (!(this instanceof exports.Parser)) {
            return new exports.Parser(opts);
          }
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value = opts[key];
            this.options[key] = value;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + "ns";
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors.normalize);
          }
          this.reset();
        }
        Parser.prototype.processAsync = function() {
          var chunk, err;
          try {
            if (this.remaining.length <= this.options.chunkSize) {
              chunk = this.remaining;
              this.remaining = "";
              this.saxParser = this.saxParser.write(chunk);
              return this.saxParser.close();
            } else {
              chunk = this.remaining.substr(0, this.options.chunkSize);
              this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
              this.saxParser = this.saxParser.write(chunk);
              return setImmediate2(this.processAsync);
            }
          } catch (error1) {
            err = error1;
            if (!this.saxParser.errThrown) {
              this.saxParser.errThrown = true;
              return this.emit(err);
            }
          }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return obj[key] = newValue;
            } else {
              return obj[key] = [newValue];
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              obj[key] = [obj[key]];
            }
            return obj[key].push(newValue);
          }
        };
        Parser.prototype.reset = function() {
          var attrkey, charkey, ontext, stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = function(_this) {
            return function(error2) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit("error", error2);
              }
            };
          }(this);
          this.saxParser.onend = function(_this) {
            return function() {
              if (!_this.saxParser.ended) {
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = function(_this) {
            return function(node) {
              var key, newValue, obj, processedKey, ref;
              obj = {};
              obj[charkey] = "";
              if (!_this.options.ignoreAttrs) {
                ref = node.attributes;
                for (key in ref) {
                  if (!hasProp.call(ref, key))
                    continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = {};
                  }
                  newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                  processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    obj[attrkey][processedKey] = newValue;
                  }
                }
              }
              obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local
                };
              }
              return stack.push(obj);
            };
          }(this);
          this.saxParser.onclosetag = function(_this) {
            return function() {
              var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s2, xpath;
              obj = stack.pop();
              nodeName = obj["#name"];
              if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                delete obj["#name"];
              }
              if (obj.cdata === true) {
                cdata = obj.cdata;
                delete obj.cdata;
              }
              s2 = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                }
                obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
              }
              if (_this.options.validator != null) {
                xpath = "/" + function() {
                  var i2, len, results;
                  results = [];
                  for (i2 = 0, len = stack.length; i2 < len; i2++) {
                    node = stack[i2];
                    results.push(node["#name"]);
                  }
                  return results;
                }().concat(nodeName).join("/");
                (function() {
                  var err;
                  try {
                    return obj = _this.options.validator(xpath, s2 && s2[nodeName], obj);
                  } catch (error1) {
                    err = error1;
                    return _this.emit("error", err);
                  }
                })();
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                if (!_this.options.preserveChildrenOrder) {
                  node = {};
                  if (_this.options.attrkey in obj) {
                    node[_this.options.attrkey] = obj[_this.options.attrkey];
                    delete obj[_this.options.attrkey];
                  }
                  if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                    node[_this.options.charkey] = obj[_this.options.charkey];
                    delete obj[_this.options.charkey];
                  }
                  if (Object.getOwnPropertyNames(obj).length > 0) {
                    node[_this.options.childkey] = obj;
                  }
                  obj = node;
                } else if (s2) {
                  s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                  objClone = {};
                  for (key in obj) {
                    if (!hasProp.call(obj, key))
                      continue;
                    objClone[key] = obj[key];
                  }
                  s2[_this.options.childkey].push(objClone);
                  delete obj["#name"];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s2, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = {};
                  obj[nodeName] = old;
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          ontext = function(_this) {
            return function(text) {
              var charChild, s2;
              s2 = stack[stack.length - 1];
              if (s2) {
                s2[charkey] += text;
                if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                  s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                  charChild = {
                    "#name": "__text__"
                  };
                  charChild[charkey] = text;
                  if (_this.options.normalize) {
                    charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                  }
                  s2[_this.options.childkey].push(charChild);
                }
                return s2;
              }
            };
          }(this);
          this.saxParser.ontext = ontext;
          return this.saxParser.oncdata = function(_this) {
            return function(text) {
              var s2;
              s2 = ontext(text);
              if (s2) {
                return s2.cdata = true;
              }
            };
          }(this);
        };
        Parser.prototype.parseString = function(str, cb) {
          var err;
          if (cb != null && typeof cb === "function") {
            this.on("end", function(result) {
              this.reset();
              return cb(null, result);
            });
            this.on("error", function(err2) {
              this.reset();
              return cb(err2);
            });
          }
          try {
            str = str.toString();
            if (str.trim() === "") {
              this.emit("end", null);
              return true;
            }
            str = bom.stripBOM(str);
            if (this.options.async) {
              this.remaining = str;
              setImmediate2(this.processAsync);
              return this.saxParser;
            }
            return this.saxParser.write(str).close();
          } catch (error1) {
            err = error1;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit("error", err);
              return this.saxParser.errThrown = true;
            } else if (this.saxParser.ended) {
              throw err;
            }
          }
        };
        return Parser;
      }(events.EventEmitter);
      exports.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
          if (typeof b === "function") {
            cb = b;
          }
          if (typeof a === "object") {
            options = a;
          }
        } else {
          if (typeof a === "function") {
            cb = a;
          }
          options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml2js/lib/xml2js.js"(exports) {
    (function() {
      "use strict";
      var builder, defaults, parser, processors, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      defaults = require_defaults();
      builder = require_builder3();
      parser = require_parser2();
      processors = require_processors();
      exports.defaults = defaults.defaults;
      exports.processors = processors;
      exports.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
          this.message = message;
        }
        return ValidationError;
      }(Error);
      exports.Builder = builder.Builder;
      exports.Parser = parser.Parser;
      exports.parseString = parser.parseString;
    }).call(exports);
  }
});

// node_modules/aws-sdk/lib/xml/node_parser.js
var require_node_parser = __commonJS({
  "node_modules/aws-sdk/lib/xml/node_parser.js"(exports, module2) {
    var AWS2 = require_core2();
    var util = AWS2.util;
    var Shape = AWS2.Model.Shape;
    var xml2js = require_xml2js();
    var options = {
      explicitCharkey: false,
      trim: false,
      normalize: false,
      explicitRoot: false,
      emptyTag: null,
      explicitArray: true,
      ignoreAttrs: false,
      mergeAttrs: false,
      validator: null
    };
    function NodeXmlParser() {
    }
    NodeXmlParser.prototype.parse = function(xml, shape) {
      shape = shape || {};
      var result = null;
      var error2 = null;
      var parser = new xml2js.Parser(options);
      parser.parseString(xml, function(e2, r2) {
        error2 = e2;
        result = r2;
      });
      if (result) {
        var data = parseXml(result, shape);
        if (result.ResponseMetadata) {
          data.ResponseMetadata = parseXml(result.ResponseMetadata[0], {});
        }
        return data;
      } else if (error2) {
        throw util.error(error2, { code: "XMLParserError", retryable: true });
      } else {
        return parseXml({}, shape);
      }
    };
    function parseXml(xml, shape) {
      switch (shape.type) {
        case "structure":
          return parseStructure(xml, shape);
        case "map":
          return parseMap(xml, shape);
        case "list":
          return parseList(xml, shape);
        case void 0:
        case null:
          return parseUnknown(xml);
        default:
          return parseScalar(xml, shape);
      }
    }
    function parseStructure(xml, shape) {
      var data = {};
      if (xml === null)
        return data;
      util.each(shape.members, function(memberName, memberShape) {
        var xmlName = memberShape.name;
        if (Object.prototype.hasOwnProperty.call(xml, xmlName) && Array.isArray(xml[xmlName])) {
          var xmlChild = xml[xmlName];
          if (!memberShape.flattened)
            xmlChild = xmlChild[0];
          data[memberName] = parseXml(xmlChild, memberShape);
        } else if (memberShape.isXmlAttribute && xml.$ && Object.prototype.hasOwnProperty.call(xml.$, xmlName)) {
          data[memberName] = parseScalar(xml.$[xmlName], memberShape);
        } else if (memberShape.type === "list" && !shape.api.xmlNoDefaultLists) {
          data[memberName] = memberShape.defaultValue;
        }
      });
      return data;
    }
    function parseMap(xml, shape) {
      var data = {};
      if (xml === null)
        return data;
      var xmlKey = shape.key.name || "key";
      var xmlValue = shape.value.name || "value";
      var iterable = shape.flattened ? xml : xml.entry;
      if (Array.isArray(iterable)) {
        util.arrayEach(iterable, function(child) {
          data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);
        });
      }
      return data;
    }
    function parseList(xml, shape) {
      var data = [];
      var name = shape.member.name || "member";
      if (shape.flattened) {
        util.arrayEach(xml, function(xmlChild) {
          data.push(parseXml(xmlChild, shape.member));
        });
      } else if (xml && Array.isArray(xml[name])) {
        util.arrayEach(xml[name], function(child) {
          data.push(parseXml(child, shape.member));
        });
      }
      return data;
    }
    function parseScalar(text, shape) {
      if (text && text.$ && text.$.encoding === "base64") {
        shape = new Shape.create({ type: text.$.encoding });
      }
      if (text && text._)
        text = text._;
      if (typeof shape.toType === "function") {
        return shape.toType(text);
      } else {
        return text;
      }
    }
    function parseUnknown(xml) {
      if (xml === void 0 || xml === null)
        return "";
      if (typeof xml === "string")
        return xml;
      if (Array.isArray(xml)) {
        var arr = [];
        for (i2 = 0; i2 < xml.length; i2++) {
          arr.push(parseXml(xml[i2], {}));
        }
        return arr;
      }
      var keys = Object.keys(xml), i2;
      if (keys.length === 0 || keys.length === 1 && keys[0] === "$") {
        return {};
      }
      var data = {};
      for (i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2], value = xml[key];
        if (key === "$")
          continue;
        if (value.length > 1) {
          data[key] = parseList(value, { member: {} });
        } else {
          data[key] = parseXml(value[0], {});
        }
      }
      return data;
    }
    module2.exports = NodeXmlParser;
  }
});

// node_modules/aws-sdk/lib/http/node.js
var require_node = __commonJS({
  "node_modules/aws-sdk/lib/http/node.js"() {
    var AWS2 = require_core2();
    var Stream3 = AWS2.util.stream.Stream;
    var TransformStream = AWS2.util.stream.Transform;
    var ReadableStream2 = AWS2.util.stream.Readable;
    require_http();
    var CONNECTION_REUSE_ENV_NAME = "AWS_NODEJS_CONNECTION_REUSE_ENABLED";
    AWS2.NodeHttpClient = AWS2.util.inherit({
      handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
        var self2 = this;
        var endpoint = httpRequest.endpoint;
        var pathPrefix = "";
        if (!httpOptions)
          httpOptions = {};
        if (httpOptions.proxy) {
          pathPrefix = endpoint.protocol + "//" + endpoint.hostname;
          if (endpoint.port !== 80 && endpoint.port !== 443) {
            pathPrefix += ":" + endpoint.port;
          }
          endpoint = new AWS2.Endpoint(httpOptions.proxy);
        }
        var useSSL = endpoint.protocol === "https:";
        var http3 = useSSL ? require("https") : require("http");
        var options = {
          host: endpoint.hostname,
          port: endpoint.port,
          method: httpRequest.method,
          headers: httpRequest.headers,
          path: pathPrefix + httpRequest.path
        };
        if (!httpOptions.agent) {
          options.agent = this.getAgent(useSSL, {
            keepAlive: process.env[CONNECTION_REUSE_ENV_NAME] === "1" ? true : false
          });
        }
        AWS2.util.update(options, httpOptions);
        delete options.proxy;
        delete options.timeout;
        var stream = http3.request(options, function(httpResp) {
          if (stream.didCallback)
            return;
          callback(httpResp);
          httpResp.emit("headers", httpResp.statusCode, httpResp.headers, httpResp.statusMessage);
        });
        httpRequest.stream = stream;
        stream.didCallback = false;
        if (httpOptions.connectTimeout) {
          var connectTimeoutId;
          stream.on("socket", function(socket) {
            if (socket.connecting) {
              connectTimeoutId = setTimeout(function connectTimeout() {
                if (stream.didCallback)
                  return;
                stream.didCallback = true;
                stream.abort();
                errCallback(AWS2.util.error(new Error("Socket timed out without establishing a connection"), { code: "TimeoutError" }));
              }, httpOptions.connectTimeout);
              socket.on("connect", function() {
                clearTimeout(connectTimeoutId);
                connectTimeoutId = null;
              });
            }
          });
        }
        stream.setTimeout(httpOptions.timeout || 0, function() {
          if (stream.didCallback)
            return;
          stream.didCallback = true;
          var msg = "Connection timed out after " + httpOptions.timeout + "ms";
          errCallback(AWS2.util.error(new Error(msg), { code: "TimeoutError" }));
          stream.abort();
        });
        stream.on("error", function(err) {
          if (connectTimeoutId) {
            clearTimeout(connectTimeoutId);
            connectTimeoutId = null;
          }
          if (stream.didCallback)
            return;
          stream.didCallback = true;
          if (err.code === "ECONNRESET" || err.code === "EPIPE" || err.code === "ETIMEDOUT") {
            errCallback(AWS2.util.error(err, { code: "TimeoutError" }));
          } else {
            errCallback(err);
          }
        });
        var expect = httpRequest.headers.Expect || httpRequest.headers.expect;
        if (expect === "100-continue") {
          stream.once("continue", function() {
            self2.writeBody(stream, httpRequest);
          });
        } else {
          this.writeBody(stream, httpRequest);
        }
        return stream;
      },
      writeBody: function writeBody(stream, httpRequest) {
        var body = httpRequest.body;
        var totalBytes = parseInt(httpRequest.headers["Content-Length"], 10);
        if (body instanceof Stream3) {
          var progressStream = this.progressStream(stream, totalBytes);
          if (progressStream) {
            body.pipe(progressStream).pipe(stream);
          } else {
            body.pipe(stream);
          }
        } else if (body) {
          stream.once("finish", function() {
            stream.emit("sendProgress", {
              loaded: totalBytes,
              total: totalBytes
            });
          });
          stream.end(body);
        } else {
          stream.end();
        }
      },
      getAgent: function getAgent(useSSL, agentOptions) {
        var http3 = useSSL ? require("https") : require("http");
        if (useSSL) {
          if (!AWS2.NodeHttpClient.sslAgent) {
            AWS2.NodeHttpClient.sslAgent = new http3.Agent(AWS2.util.merge({
              rejectUnauthorized: process.env.NODE_TLS_REJECT_UNAUTHORIZED === "0" ? false : true
            }, agentOptions || {}));
            AWS2.NodeHttpClient.sslAgent.setMaxListeners(0);
            Object.defineProperty(AWS2.NodeHttpClient.sslAgent, "maxSockets", {
              enumerable: true,
              get: function() {
                var defaultMaxSockets = 50;
                var globalAgent = http3.globalAgent;
                if (globalAgent && globalAgent.maxSockets !== Infinity && typeof globalAgent.maxSockets === "number") {
                  return globalAgent.maxSockets;
                }
                return defaultMaxSockets;
              }
            });
          }
          return AWS2.NodeHttpClient.sslAgent;
        } else {
          if (!AWS2.NodeHttpClient.agent) {
            AWS2.NodeHttpClient.agent = new http3.Agent(agentOptions);
          }
          return AWS2.NodeHttpClient.agent;
        }
      },
      progressStream: function progressStream(stream, totalBytes) {
        if (typeof TransformStream === "undefined") {
          return;
        }
        var loadedBytes = 0;
        var reporter = new TransformStream();
        reporter._transform = function(chunk, encoding, callback) {
          if (chunk) {
            loadedBytes += chunk.length;
            stream.emit("sendProgress", {
              loaded: loadedBytes,
              total: totalBytes
            });
          }
          callback(null, chunk);
        };
        return reporter;
      },
      emitter: null
    });
    AWS2.HttpClient.prototype = AWS2.NodeHttpClient.prototype;
    AWS2.HttpClient.streamsApiVersion = ReadableStream2 ? 2 : 1;
  }
});

// node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js
var require_token_file_web_identity_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js"() {
    var AWS2 = require_core2();
    var fs8 = require("fs");
    var STS = require_sts2();
    var iniLoader = AWS2.util.iniLoader;
    AWS2.TokenFileWebIdentityCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function TokenFileWebIdentityCredentials(clientConfig) {
        AWS2.Credentials.call(this);
        this.data = null;
        this.clientConfig = AWS2.util.copy(clientConfig || {});
      },
      getParamsFromEnv: function getParamsFromEnv() {
        var ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE", ENV_ROLE_ARN = "AWS_ROLE_ARN";
        if (process.env[ENV_TOKEN_FILE] && process.env[ENV_ROLE_ARN]) {
          return [{
            envTokenFile: process.env[ENV_TOKEN_FILE],
            roleArn: process.env[ENV_ROLE_ARN],
            roleSessionName: process.env["AWS_ROLE_SESSION_NAME"]
          }];
        }
      },
      getParamsFromSharedConfig: function getParamsFromSharedConfig() {
        var profiles = AWS2.util.getProfilesFromSharedConfig(iniLoader);
        var profileName = process.env.AWS_PROFILE || AWS2.util.defaultProfile;
        var profile = profiles[profileName] || {};
        if (Object.keys(profile).length === 0) {
          throw AWS2.util.error(new Error("Profile " + profileName + " not found"), { code: "TokenFileWebIdentityCredentialsProviderFailure" });
        }
        var paramsArray = [];
        while (!profile["web_identity_token_file"] && profile["source_profile"]) {
          paramsArray.unshift({
            roleArn: profile["role_arn"],
            roleSessionName: profile["role_session_name"]
          });
          var sourceProfile = profile["source_profile"];
          profile = profiles[sourceProfile];
        }
        paramsArray.unshift({
          envTokenFile: profile["web_identity_token_file"],
          roleArn: profile["role_arn"],
          roleSessionName: profile["role_session_name"]
        });
        return paramsArray;
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      assumeRoleChaining: function assumeRoleChaining(paramsArray, callback) {
        var self2 = this;
        if (paramsArray.length === 0) {
          self2.service.credentialsFrom(self2.data, self2);
          callback();
        } else {
          var params = paramsArray.shift();
          self2.service.config.credentials = self2.service.credentialsFrom(self2.data, self2);
          self2.service.assumeRole({
            RoleArn: params.roleArn,
            RoleSessionName: params.roleSessionName || "token-file-web-identity"
          }, function(err, data) {
            self2.data = null;
            if (err) {
              callback(err);
            } else {
              self2.data = data;
              self2.assumeRoleChaining(paramsArray, callback);
            }
          });
        }
      },
      load: function load(callback) {
        var self2 = this;
        try {
          var paramsArray = self2.getParamsFromEnv();
          if (!paramsArray) {
            paramsArray = self2.getParamsFromSharedConfig();
          }
          if (paramsArray) {
            var params = paramsArray.shift();
            var oidcToken = fs8.readFileSync(params.envTokenFile, { encoding: "ascii" });
            if (!self2.service) {
              self2.createClients();
            }
            self2.service.assumeRoleWithWebIdentity({
              WebIdentityToken: oidcToken,
              RoleArn: params.roleArn,
              RoleSessionName: params.roleSessionName || "token-file-web-identity"
            }, function(err, data) {
              self2.data = null;
              if (err) {
                callback(err);
              } else {
                self2.data = data;
                self2.assumeRoleChaining(paramsArray, callback);
              }
            });
          }
        } catch (err) {
          callback(err);
        }
      },
      createClients: function() {
        if (!this.service) {
          var stsConfig = AWS2.util.merge({}, this.clientConfig);
          this.service = new STS(stsConfig);
          this.service.retryableError = function(error2) {
            if (error2.code === "IDPCommunicationErrorException" || error2.code === "InvalidIdentityToken") {
              return true;
            } else {
              return AWS2.Service.prototype.retryableError.call(this, error2);
            }
          };
        }
      }
    });
  }
});

// node_modules/aws-sdk/lib/metadata_service/get_endpoint.js
var require_get_endpoint = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service/get_endpoint.js"(exports, module2) {
    var getEndpoint = function() {
      return {
        IPv4: "http://169.254.169.254",
        IPv6: "http://[fd00:ec2::254]"
      };
    };
    module2.exports = getEndpoint;
  }
});

// node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js
var require_get_endpoint_mode = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js"(exports, module2) {
    var getEndpointMode = function() {
      return {
        IPv4: "IPv4",
        IPv6: "IPv6"
      };
    };
    module2.exports = getEndpointMode;
  }
});

// node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js
var require_get_endpoint_config_options = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js"(exports, module2) {
    var ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
    var CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
    var getEndpointConfigOptions = function() {
      return {
        environmentVariableSelector: function(env) {
          return env[ENV_ENDPOINT_NAME];
        },
        configFileSelector: function(profile) {
          return profile[CONFIG_ENDPOINT_NAME];
        },
        default: void 0
      };
    };
    module2.exports = getEndpointConfigOptions;
  }
});

// node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js
var require_get_endpoint_mode_config_options = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js"(exports, module2) {
    var EndpointMode = require_get_endpoint_mode()();
    var ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
    var CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
    var getEndpointModeConfigOptions = function() {
      return {
        environmentVariableSelector: function(env) {
          return env[ENV_ENDPOINT_MODE_NAME];
        },
        configFileSelector: function(profile) {
          return profile[CONFIG_ENDPOINT_MODE_NAME];
        },
        default: EndpointMode.IPv4
      };
    };
    module2.exports = getEndpointModeConfigOptions;
  }
});

// node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js
var require_get_metadata_service_endpoint = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js"(exports, module2) {
    var AWS2 = require_core2();
    var Endpoint = require_get_endpoint()();
    var EndpointMode = require_get_endpoint_mode()();
    var ENDPOINT_CONFIG_OPTIONS = require_get_endpoint_config_options()();
    var ENDPOINT_MODE_CONFIG_OPTIONS = require_get_endpoint_mode_config_options()();
    var getMetadataServiceEndpoint = function() {
      var endpoint = AWS2.util.loadConfig(ENDPOINT_CONFIG_OPTIONS);
      if (endpoint !== void 0)
        return endpoint;
      var endpointMode = AWS2.util.loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS);
      switch (endpointMode) {
        case EndpointMode.IPv4:
          return Endpoint.IPv4;
        case EndpointMode.IPv6:
          return Endpoint.IPv6;
        default:
          throw new Error("Unsupported endpoint mode: " + endpointMode);
      }
    };
    module2.exports = getMetadataServiceEndpoint;
  }
});

// node_modules/aws-sdk/lib/metadata_service.js
var require_metadata_service = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service.js"(exports, module2) {
    var AWS2 = require_core2();
    require_http();
    var inherit = AWS2.util.inherit;
    var getMetadataServiceEndpoint = require_get_metadata_service_endpoint();
    var URL2 = require("url").URL;
    AWS2.MetadataService = inherit({
      endpoint: getMetadataServiceEndpoint(),
      httpOptions: { timeout: 0 },
      disableFetchToken: false,
      constructor: function MetadataService(options) {
        if (options && options.host) {
          options.endpoint = "http://" + options.host;
          delete options.host;
        }
        AWS2.util.update(this, options);
      },
      request: function request(path8, options, callback) {
        if (arguments.length === 2) {
          callback = options;
          options = {};
        }
        if (process.env[AWS2.util.imdsDisabledEnv]) {
          callback(new Error("EC2 Instance Metadata Service access disabled"));
          return;
        }
        path8 = path8 || "/";
        if (URL2) {
          new URL2(this.endpoint);
        }
        var httpRequest = new AWS2.HttpRequest(this.endpoint + path8);
        httpRequest.method = options.method || "GET";
        if (options.headers) {
          httpRequest.headers = options.headers;
        }
        AWS2.util.handleRequestWithRetries(httpRequest, this, callback);
      },
      loadCredentialsCallbacks: [],
      fetchMetadataToken: function fetchMetadataToken(callback) {
        var self2 = this;
        var tokenFetchPath = "/latest/api/token";
        self2.request(tokenFetchPath, {
          "method": "PUT",
          "headers": {
            "x-aws-ec2-metadata-token-ttl-seconds": "21600"
          }
        }, callback);
      },
      fetchCredentials: function fetchCredentials(options, cb) {
        var self2 = this;
        var basePath = "/latest/meta-data/iam/security-credentials/";
        self2.request(basePath, options, function(err, roleName) {
          if (err) {
            self2.disableFetchToken = !(err.statusCode === 401);
            cb(AWS2.util.error(err, {
              message: "EC2 Metadata roleName request returned error"
            }));
            return;
          }
          roleName = roleName.split("\n")[0];
          self2.request(basePath + roleName, options, function(credErr, credData) {
            if (credErr) {
              self2.disableFetchToken = !(credErr.statusCode === 401);
              cb(AWS2.util.error(credErr, {
                message: "EC2 Metadata creds request returned error"
              }));
              return;
            }
            try {
              var credentials = JSON.parse(credData);
              cb(null, credentials);
            } catch (parseError) {
              cb(parseError);
            }
          });
        });
      },
      loadCredentials: function loadCredentials(callback) {
        var self2 = this;
        self2.loadCredentialsCallbacks.push(callback);
        if (self2.loadCredentialsCallbacks.length > 1) {
          return;
        }
        function callbacks(err, creds) {
          var cb;
          while ((cb = self2.loadCredentialsCallbacks.shift()) !== void 0) {
            cb(err, creds);
          }
        }
        if (self2.disableFetchToken) {
          self2.fetchCredentials({}, callbacks);
        } else {
          self2.fetchMetadataToken(function(tokenError, token2) {
            if (tokenError) {
              if (tokenError.code === "TimeoutError") {
                self2.disableFetchToken = true;
              } else if (tokenError.retryable === true) {
                callbacks(AWS2.util.error(tokenError, {
                  message: "EC2 Metadata token request returned error"
                }));
                return;
              } else if (tokenError.statusCode === 400) {
                callbacks(AWS2.util.error(tokenError, {
                  message: "EC2 Metadata token request returned 400"
                }));
                return;
              }
            }
            var options = {};
            if (token2) {
              options.headers = {
                "x-aws-ec2-metadata-token": token2
              };
            }
            self2.fetchCredentials(options, callbacks);
          });
        }
      }
    });
    module2.exports = AWS2.MetadataService;
  }
});

// node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js
var require_ec2_metadata_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js"() {
    var AWS2 = require_core2();
    require_metadata_service();
    AWS2.EC2MetadataCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function EC2MetadataCredentials(options) {
        AWS2.Credentials.call(this);
        options = options ? AWS2.util.copy(options) : {};
        options = AWS2.util.merge({ maxRetries: this.defaultMaxRetries }, options);
        if (!options.httpOptions)
          options.httpOptions = {};
        options.httpOptions = AWS2.util.merge({
          timeout: this.defaultTimeout,
          connectTimeout: this.defaultConnectTimeout
        }, options.httpOptions);
        this.metadataService = new AWS2.MetadataService(options);
        this.logger = options.logger || AWS2.config && AWS2.config.logger;
      },
      defaultTimeout: 1e3,
      defaultConnectTimeout: 1e3,
      defaultMaxRetries: 3,
      originalExpiration: void 0,
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      load: function load(callback) {
        var self2 = this;
        self2.metadataService.loadCredentials(function(err, creds) {
          if (err) {
            if (self2.hasLoadedCredentials()) {
              self2.extendExpirationIfExpired();
              callback();
            } else {
              callback(err);
            }
          } else {
            self2.setCredentials(creds);
            self2.extendExpirationIfExpired();
            callback();
          }
        });
      },
      hasLoadedCredentials: function hasLoadedCredentials() {
        return this.AccessKeyId && this.secretAccessKey;
      },
      extendExpirationIfExpired: function extendExpirationIfExpired() {
        if (this.needsRefresh()) {
          this.originalExpiration = this.originalExpiration || this.expireTime;
          this.expired = false;
          var nextTimeout = 15 * 60 + Math.floor(Math.random() * 5 * 60);
          var currentTime = AWS2.util.date.getDate().getTime();
          this.expireTime = new Date(currentTime + nextTimeout * 1e3);
          this.logger.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted again at " + this.expireTime + "\nFor more information, please visit: https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html");
        }
      },
      setCredentials: function setCredentials(creds) {
        var currentTime = AWS2.util.date.getDate().getTime();
        var expireTime = new Date(creds.Expiration);
        this.expired = currentTime >= expireTime ? true : false;
        this.metadata = creds;
        this.accessKeyId = creds.AccessKeyId;
        this.secretAccessKey = creds.SecretAccessKey;
        this.sessionToken = creds.Token;
        this.expireTime = expireTime;
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/remote_credentials.js
var require_remote_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/remote_credentials.js"() {
    var AWS2 = require_core2();
    var ENV_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
    var ENV_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
    var ENV_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
    var FULL_URI_UNRESTRICTED_PROTOCOLS = ["https:"];
    var FULL_URI_ALLOWED_PROTOCOLS = ["http:", "https:"];
    var FULL_URI_ALLOWED_HOSTNAMES = ["localhost", "127.0.0.1"];
    var RELATIVE_URI_HOST = "169.254.170.2";
    AWS2.RemoteCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function RemoteCredentials(options) {
        AWS2.Credentials.call(this);
        options = options ? AWS2.util.copy(options) : {};
        if (!options.httpOptions)
          options.httpOptions = {};
        options.httpOptions = AWS2.util.merge(this.httpOptions, options.httpOptions);
        AWS2.util.update(this, options);
      },
      httpOptions: { timeout: 1e3 },
      maxRetries: 3,
      isConfiguredForEcsCredentials: function isConfiguredForEcsCredentials() {
        return Boolean(process && process.env && (process.env[ENV_RELATIVE_URI] || process.env[ENV_FULL_URI]));
      },
      getECSFullUri: function getECSFullUri() {
        if (process && process.env) {
          var relative = process.env[ENV_RELATIVE_URI], full = process.env[ENV_FULL_URI];
          if (relative) {
            return "http://" + RELATIVE_URI_HOST + relative;
          } else if (full) {
            var parsed = AWS2.util.urlParse(full);
            if (FULL_URI_ALLOWED_PROTOCOLS.indexOf(parsed.protocol) < 0) {
              throw AWS2.util.error(new Error("Unsupported protocol:  AWS.RemoteCredentials supports " + FULL_URI_ALLOWED_PROTOCOLS.join(",") + " only; " + parsed.protocol + " requested."), { code: "ECSCredentialsProviderFailure" });
            }
            if (FULL_URI_UNRESTRICTED_PROTOCOLS.indexOf(parsed.protocol) < 0 && FULL_URI_ALLOWED_HOSTNAMES.indexOf(parsed.hostname) < 0) {
              throw AWS2.util.error(new Error("Unsupported hostname: AWS.RemoteCredentials only supports " + FULL_URI_ALLOWED_HOSTNAMES.join(",") + " for " + parsed.protocol + "; " + parsed.protocol + "//" + parsed.hostname + " requested."), { code: "ECSCredentialsProviderFailure" });
            }
            return full;
          } else {
            throw AWS2.util.error(new Error("Variable " + ENV_RELATIVE_URI + " or " + ENV_FULL_URI + " must be set to use AWS.RemoteCredentials."), { code: "ECSCredentialsProviderFailure" });
          }
        } else {
          throw AWS2.util.error(new Error("No process info available"), { code: "ECSCredentialsProviderFailure" });
        }
      },
      getECSAuthToken: function getECSAuthToken() {
        if (process && process.env && process.env[ENV_FULL_URI]) {
          return process.env[ENV_AUTH_TOKEN];
        }
      },
      credsFormatIsValid: function credsFormatIsValid(credData) {
        return !!credData.accessKeyId && !!credData.secretAccessKey && !!credData.sessionToken && !!credData.expireTime;
      },
      formatCreds: function formatCreds(credData) {
        if (!!credData.credentials) {
          credData = credData.credentials;
        }
        return {
          expired: false,
          accessKeyId: credData.accessKeyId || credData.AccessKeyId,
          secretAccessKey: credData.secretAccessKey || credData.SecretAccessKey,
          sessionToken: credData.sessionToken || credData.Token,
          expireTime: new Date(credData.expiration || credData.Expiration)
        };
      },
      request: function request(url, callback) {
        var httpRequest = new AWS2.HttpRequest(url);
        httpRequest.method = "GET";
        httpRequest.headers.Accept = "application/json";
        var token2 = this.getECSAuthToken();
        if (token2) {
          httpRequest.headers.Authorization = token2;
        }
        AWS2.util.handleRequestWithRetries(httpRequest, this, callback);
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      load: function load(callback) {
        var self2 = this;
        var fullUri;
        try {
          fullUri = this.getECSFullUri();
        } catch (err) {
          callback(err);
          return;
        }
        this.request(fullUri, function(err, data) {
          if (!err) {
            try {
              data = JSON.parse(data);
              var creds = self2.formatCreds(data);
              if (!self2.credsFormatIsValid(creds)) {
                throw AWS2.util.error(new Error("Response data is not in valid format"), { code: "ECSCredentialsProviderFailure" });
              }
              AWS2.util.update(self2, creds);
            } catch (dataError) {
              err = dataError;
            }
          }
          callback(err, creds);
        });
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/ecs_credentials.js
var require_ecs_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/ecs_credentials.js"() {
    var AWS2 = require_core2();
    AWS2.ECSCredentials = AWS2.RemoteCredentials;
  }
});

// node_modules/aws-sdk/lib/credentials/environment_credentials.js
var require_environment_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/environment_credentials.js"() {
    var AWS2 = require_core2();
    AWS2.EnvironmentCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function EnvironmentCredentials(envPrefix) {
        AWS2.Credentials.call(this);
        this.envPrefix = envPrefix;
        this.get(function() {
        });
      },
      refresh: function refresh(callback) {
        if (!callback)
          callback = AWS2.util.fn.callback;
        if (!process || !process.env) {
          callback(AWS2.util.error(new Error("No process info or environment variables available"), { code: "EnvironmentCredentialsProviderFailure" }));
          return;
        }
        var keys = ["ACCESS_KEY_ID", "SECRET_ACCESS_KEY", "SESSION_TOKEN"];
        var values = [];
        for (var i2 = 0; i2 < keys.length; i2++) {
          var prefix = "";
          if (this.envPrefix)
            prefix = this.envPrefix + "_";
          values[i2] = process.env[prefix + keys[i2]];
          if (!values[i2] && keys[i2] !== "SESSION_TOKEN") {
            callback(AWS2.util.error(new Error("Variable " + prefix + keys[i2] + " not set."), { code: "EnvironmentCredentialsProviderFailure" }));
            return;
          }
        }
        this.expired = false;
        AWS2.Credentials.apply(this, values);
        callback();
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/file_system_credentials.js
var require_file_system_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/file_system_credentials.js"() {
    var AWS2 = require_core2();
    AWS2.FileSystemCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function FileSystemCredentials(filename) {
        AWS2.Credentials.call(this);
        this.filename = filename;
        this.get(function() {
        });
      },
      refresh: function refresh(callback) {
        if (!callback)
          callback = AWS2.util.fn.callback;
        try {
          var creds = JSON.parse(AWS2.util.readFileSync(this.filename));
          AWS2.Credentials.call(this, creds);
          if (!this.accessKeyId || !this.secretAccessKey) {
            throw AWS2.util.error(new Error("Credentials not set in " + this.filename), { code: "FileSystemCredentialsProviderFailure" });
          }
          this.expired = false;
          callback();
        } catch (err) {
          callback(err);
        }
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js
var require_shared_ini_file_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js"() {
    var AWS2 = require_core2();
    var STS = require_sts2();
    var iniLoader = AWS2.util.iniLoader;
    var ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
    AWS2.SharedIniFileCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function SharedIniFileCredentials(options) {
        AWS2.Credentials.call(this);
        options = options || {};
        this.filename = options.filename;
        this.profile = options.profile || process.env.AWS_PROFILE || AWS2.util.defaultProfile;
        this.disableAssumeRole = Boolean(options.disableAssumeRole);
        this.preferStaticCredentials = Boolean(options.preferStaticCredentials);
        this.tokenCodeFn = options.tokenCodeFn || null;
        this.httpOptions = options.httpOptions || null;
        this.get(options.callback || AWS2.util.fn.noop);
      },
      load: function load(callback) {
        var self2 = this;
        try {
          var profiles = AWS2.util.getProfilesFromSharedConfig(iniLoader, this.filename);
          var profile = profiles[this.profile] || {};
          if (Object.keys(profile).length === 0) {
            throw AWS2.util.error(new Error("Profile " + this.profile + " not found"), { code: "SharedIniFileCredentialsProviderFailure" });
          }
          var preferStaticCredentialsToRoleArn = Boolean(this.preferStaticCredentials && profile["aws_access_key_id"] && profile["aws_secret_access_key"]);
          if (profile["role_arn"] && !preferStaticCredentialsToRoleArn) {
            this.loadRoleProfile(profiles, profile, function(err, data) {
              if (err) {
                callback(err);
              } else {
                self2.expired = false;
                self2.accessKeyId = data.Credentials.AccessKeyId;
                self2.secretAccessKey = data.Credentials.SecretAccessKey;
                self2.sessionToken = data.Credentials.SessionToken;
                self2.expireTime = data.Credentials.Expiration;
                callback(null);
              }
            });
            return;
          }
          this.accessKeyId = profile["aws_access_key_id"];
          this.secretAccessKey = profile["aws_secret_access_key"];
          this.sessionToken = profile["aws_session_token"];
          if (!this.accessKeyId || !this.secretAccessKey) {
            throw AWS2.util.error(new Error("Credentials not set for profile " + this.profile), { code: "SharedIniFileCredentialsProviderFailure" });
          }
          this.expired = false;
          callback(null);
        } catch (err) {
          callback(err);
        }
      },
      refresh: function refresh(callback) {
        iniLoader.clearCachedFiles();
        this.coalesceRefresh(callback || AWS2.util.fn.callback, this.disableAssumeRole);
      },
      loadRoleProfile: function loadRoleProfile(creds, roleProfile, callback) {
        if (this.disableAssumeRole) {
          throw AWS2.util.error(new Error("Role assumption profiles are disabled. Failed to load profile " + this.profile + " from " + creds.filename), { code: "SharedIniFileCredentialsProviderFailure" });
        }
        var self2 = this;
        var roleArn = roleProfile["role_arn"];
        var roleSessionName = roleProfile["role_session_name"];
        var externalId = roleProfile["external_id"];
        var mfaSerial = roleProfile["mfa_serial"];
        var sourceProfileName = roleProfile["source_profile"];
        var profileRegion = roleProfile["region"] || ASSUME_ROLE_DEFAULT_REGION;
        if (!sourceProfileName) {
          throw AWS2.util.error(new Error("source_profile is not set using profile " + this.profile), { code: "SharedIniFileCredentialsProviderFailure" });
        }
        var sourceProfileExistanceTest = creds[sourceProfileName];
        if (typeof sourceProfileExistanceTest !== "object") {
          throw AWS2.util.error(new Error("source_profile " + sourceProfileName + " using profile " + this.profile + " does not exist"), { code: "SharedIniFileCredentialsProviderFailure" });
        }
        var sourceCredentials = new AWS2.SharedIniFileCredentials(AWS2.util.merge(this.options || {}, {
          profile: sourceProfileName,
          preferStaticCredentials: true
        }));
        this.roleArn = roleArn;
        var sts = new STS({
          credentials: sourceCredentials,
          region: profileRegion,
          httpOptions: this.httpOptions
        });
        var roleParams = {
          RoleArn: roleArn,
          RoleSessionName: roleSessionName || "aws-sdk-js-" + Date.now()
        };
        if (externalId) {
          roleParams.ExternalId = externalId;
        }
        if (mfaSerial && self2.tokenCodeFn) {
          roleParams.SerialNumber = mfaSerial;
          self2.tokenCodeFn(mfaSerial, function(err, token2) {
            if (err) {
              var message;
              if (err instanceof Error) {
                message = err.message;
              } else {
                message = err;
              }
              callback(AWS2.util.error(new Error("Error fetching MFA token: " + message), { code: "SharedIniFileCredentialsProviderFailure" }));
              return;
            }
            roleParams.TokenCode = token2;
            sts.assumeRole(roleParams, callback);
          });
          return;
        }
        sts.assumeRole(roleParams, callback);
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/sso_credentials.js
var require_sso_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/sso_credentials.js"() {
    var AWS2 = require_core2();
    var path8 = require("path");
    var crypto = require("crypto");
    var iniLoader = AWS2.util.iniLoader;
    AWS2.SsoCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: function SsoCredentials(options) {
        AWS2.Credentials.call(this);
        options = options || {};
        this.errorCode = "SsoCredentialsProviderFailure";
        this.expired = true;
        this.filename = options.filename;
        this.profile = options.profile || process.env.AWS_PROFILE || AWS2.util.defaultProfile;
        this.service = options.ssoClient;
        this.get(options.callback || AWS2.util.fn.noop);
      },
      load: function load(callback) {
        var EXPIRE_WINDOW_MS = 15 * 60 * 1e3;
        var self2 = this;
        try {
          var profiles = AWS2.util.getProfilesFromSharedConfig(iniLoader, this.filename);
          var profile = profiles[this.profile] || {};
          if (Object.keys(profile).length === 0) {
            throw AWS2.util.error(new Error("Profile " + this.profile + " not found"), { code: self2.errorCode });
          }
          if (!profile.sso_start_url || !profile.sso_account_id || !profile.sso_region || !profile.sso_role_name) {
            throw AWS2.util.error(new Error("Profile " + this.profile + ' does not have valid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html'), { code: self2.errorCode });
          }
          var hasher = crypto.createHash("sha1");
          var fileName = hasher.update(profile.sso_start_url).digest("hex") + ".json";
          var cachePath = path8.join(iniLoader.getHomeDir(), ".aws", "sso", "cache", fileName);
          var cacheFile = AWS2.util.readFileSync(cachePath);
          var cacheContent = null;
          if (cacheFile) {
            cacheContent = JSON.parse(cacheFile);
          }
          if (!cacheContent) {
            throw AWS2.util.error(new Error("Cached credentials not found under " + this.profile + " profile. Please make sure you log in with aws sso login first"), { code: self2.errorCode });
          }
          if (!cacheContent.startUrl || !cacheContent.region || !cacheContent.accessToken || !cacheContent.expiresAt) {
            throw AWS2.util.error(new Error("Cached credentials are missing required properties. Try running aws sso login."));
          }
          if (new Date(cacheContent.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS) {
            throw AWS2.util.error(new Error("The SSO session associated with this profile has expired. To refresh this SSO session run aws sso login with the corresponding profile."));
          }
          if (!self2.service || self2.service.config.region !== profile.sso_region) {
            self2.service = new AWS2.SSO({ region: profile.sso_region });
          }
          var request = {
            accessToken: cacheContent.accessToken,
            accountId: profile.sso_account_id,
            roleName: profile.sso_role_name
          };
          self2.service.getRoleCredentials(request, function(err, data) {
            if (err || !data || !data.roleCredentials) {
              callback(AWS2.util.error(err || new Error('Please log in using "aws sso login"'), { code: self2.errorCode }), null);
            } else if (!data.roleCredentials.accessKeyId || !data.roleCredentials.secretAccessKey || !data.roleCredentials.sessionToken || !data.roleCredentials.expiration) {
              throw AWS2.util.error(new Error("SSO returns an invalid temporary credential."));
            } else {
              self2.expired = false;
              self2.accessKeyId = data.roleCredentials.accessKeyId;
              self2.secretAccessKey = data.roleCredentials.secretAccessKey;
              self2.sessionToken = data.roleCredentials.sessionToken;
              self2.expireTime = new Date(data.roleCredentials.expiration);
              callback(null);
            }
          });
        } catch (err) {
          callback(err);
        }
      },
      refresh: function refresh(callback) {
        iniLoader.clearCachedFiles();
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }
    });
  }
});

// node_modules/aws-sdk/lib/node_loader.js
var require_node_loader = __commonJS({
  "node_modules/aws-sdk/lib/node_loader.js"(exports, module2) {
    var util = require_util();
    var region_utils = require_utils4();
    var isFipsRegion = region_utils.isFipsRegion;
    var getRealRegion = region_utils.getRealRegion;
    util.isBrowser = function() {
      return false;
    };
    util.isNode = function() {
      return true;
    };
    util.crypto.lib = require("crypto");
    util.Buffer = require("buffer").Buffer;
    util.domain = require("domain");
    util.stream = require("stream");
    util.url = require("url");
    util.querystring = require("querystring");
    util.environment = "nodejs";
    util.createEventStream = util.stream.Readable ? require_streaming_create_event_stream().createEventStream : require_buffered_create_event_stream().createEventStream;
    util.realClock = require_nodeClock();
    util.clientSideMonitoring = {
      Publisher: require_publisher().Publisher,
      configProvider: require_configuration()
    };
    util.iniLoader = require_shared_ini().iniLoader;
    util.getSystemErrorName = require("util").getSystemErrorName;
    util.loadConfig = function(options) {
      var envValue = options.environmentVariableSelector(process.env);
      if (envValue !== void 0) {
        return envValue;
      }
      var configFile = {};
      try {
        configFile = util.iniLoader ? util.iniLoader.loadFrom({
          isConfig: true,
          filename: process.env[util.sharedConfigFileEnv]
        }) : {};
      } catch (e2) {
      }
      var sharedFileConfig = configFile[process.env.AWS_PROFILE || util.defaultProfile] || {};
      var configValue = options.configFileSelector(sharedFileConfig);
      if (configValue !== void 0) {
        return configValue;
      }
      if (typeof options.default === "function") {
        return options.default();
      }
      return options.default;
    };
    var AWS2;
    module2.exports = AWS2 = require_core2();
    require_credentials();
    require_credential_provider_chain();
    require_temporary_credentials();
    require_chainable_temporary_credentials();
    require_web_identity_credentials();
    require_cognito_identity_credentials();
    require_saml_credentials();
    require_process_credentials();
    AWS2.XML.Parser = require_node_parser();
    require_node();
    require_ini_loader();
    require_token_file_web_identity_credentials();
    require_ec2_metadata_credentials();
    require_remote_credentials();
    require_ecs_credentials();
    require_environment_credentials();
    require_file_system_credentials();
    require_shared_ini_file_credentials();
    require_process_credentials();
    require_sso_credentials();
    AWS2.CredentialProviderChain.defaultProviders = [
      function() {
        return new AWS2.EnvironmentCredentials("AWS");
      },
      function() {
        return new AWS2.EnvironmentCredentials("AMAZON");
      },
      function() {
        return new AWS2.SsoCredentials();
      },
      function() {
        return new AWS2.SharedIniFileCredentials();
      },
      function() {
        return new AWS2.ECSCredentials();
      },
      function() {
        return new AWS2.ProcessCredentials();
      },
      function() {
        return new AWS2.TokenFileWebIdentityCredentials();
      },
      function() {
        return new AWS2.EC2MetadataCredentials();
      }
    ];
    var getRegion = function() {
      var env = process.env;
      var region = env.AWS_REGION || env.AMAZON_REGION;
      if (env[AWS2.util.configOptInEnv]) {
        var toCheck = [
          { filename: env[AWS2.util.sharedCredentialsFileEnv] },
          { isConfig: true, filename: env[AWS2.util.sharedConfigFileEnv] }
        ];
        var iniLoader = AWS2.util.iniLoader;
        while (!region && toCheck.length) {
          var configFile = {};
          var fileInfo = toCheck.shift();
          try {
            configFile = iniLoader.loadFrom(fileInfo);
          } catch (err) {
            if (fileInfo.isConfig)
              throw err;
          }
          var profile = configFile[env.AWS_PROFILE || AWS2.util.defaultProfile];
          region = profile && profile.region;
        }
      }
      return region;
    };
    var getBooleanValue = function(value) {
      return value === "true" ? true : value === "false" ? false : void 0;
    };
    var USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
      environmentVariableSelector: function(env) {
        return getBooleanValue(env["AWS_USE_FIPS_ENDPOINT"]);
      },
      configFileSelector: function(profile) {
        return getBooleanValue(profile["use_fips_endpoint"]);
      },
      default: false
    };
    var USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
      environmentVariableSelector: function(env) {
        return getBooleanValue(env["AWS_USE_DUALSTACK_ENDPOINT"]);
      },
      configFileSelector: function(profile) {
        return getBooleanValue(profile["use_dualstack_endpoint"]);
      },
      default: false
    };
    AWS2.util.update(AWS2.Config.prototype.keys, {
      credentials: function() {
        var credentials = null;
        new AWS2.CredentialProviderChain([
          function() {
            return new AWS2.EnvironmentCredentials("AWS");
          },
          function() {
            return new AWS2.EnvironmentCredentials("AMAZON");
          },
          function() {
            return new AWS2.SharedIniFileCredentials({ disableAssumeRole: true });
          }
        ]).resolve(function(err, creds) {
          if (!err)
            credentials = creds;
        });
        return credentials;
      },
      credentialProvider: function() {
        return new AWS2.CredentialProviderChain();
      },
      logger: function() {
        return process.env.AWSJS_DEBUG ? console : null;
      },
      region: function() {
        var region = getRegion();
        return region ? getRealRegion(region) : void 0;
      },
      useFipsEndpoint: function() {
        var region = getRegion();
        return isFipsRegion(region) ? true : util.loadConfig(USE_FIPS_ENDPOINT_CONFIG_OPTIONS);
      },
      useDualstackEndpoint: function() {
        return util.loadConfig(USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS);
      }
    });
    AWS2.config = new AWS2.Config();
  }
});

// node_modules/aws-sdk/lib/services/s3util.js
var require_s3util = __commonJS({
  "node_modules/aws-sdk/lib/services/s3util.js"(exports, module2) {
    var AWS2 = require_core2();
    var regionUtil = require_region_config();
    var s3util = {
      isArnInParam: function isArnInParam(req, paramName) {
        var inputShape = (req.service.api.operations[req.operation] || {}).input || {};
        var inputMembers = inputShape.members || {};
        if (!req.params[paramName] || !inputMembers[paramName])
          return false;
        return AWS2.util.ARN.validate(req.params[paramName]);
      },
      validateArnService: function validateArnService(req) {
        var parsedArn = req._parsedArn;
        if (parsedArn.service !== "s3" && parsedArn.service !== "s3-outposts" && parsedArn.service !== "s3-object-lambda") {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "expect 's3' or 's3-outposts' or 's3-object-lambda' in ARN service component"
          });
        }
      },
      validateArnAccount: function validateArnAccount(req) {
        var parsedArn = req._parsedArn;
        if (!/[0-9]{12}/.exec(parsedArn.accountId)) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: 'ARN accountID does not match regex "[0-9]{12}"'
          });
        }
      },
      validateS3AccessPointArn: function validateS3AccessPointArn(req) {
        var parsedArn = req._parsedArn;
        var delimiter = parsedArn.resource["accesspoint".length];
        if (parsedArn.resource.split(delimiter).length !== 2) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "Access Point ARN should have one resource accesspoint/{accesspointName}"
          });
        }
        var accessPoint = parsedArn.resource.split(delimiter)[1];
        var accessPointPrefix = accessPoint + "-" + parsedArn.accountId;
        if (!s3util.dnsCompatibleBucketName(accessPointPrefix) || accessPointPrefix.match(/\./)) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "Access point resource in ARN is not DNS compatible. Got " + accessPoint
          });
        }
        req._parsedArn.accessPoint = accessPoint;
      },
      validateOutpostsArn: function validateOutpostsArn(req) {
        var parsedArn = req._parsedArn;
        if (parsedArn.resource.indexOf("outpost:") !== 0 && parsedArn.resource.indexOf("outpost/") !== 0) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "ARN resource should begin with 'outpost/'"
          });
        }
        var delimiter = parsedArn.resource["outpost".length];
        var outpostId = parsedArn.resource.split(delimiter)[1];
        var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
        if (!dnsHostRegex.test(outpostId)) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "Outpost resource in ARN is not DNS compatible. Got " + outpostId
          });
        }
        req._parsedArn.outpostId = outpostId;
      },
      validateOutpostsAccessPointArn: function validateOutpostsAccessPointArn(req) {
        var parsedArn = req._parsedArn;
        var delimiter = parsedArn.resource["outpost".length];
        if (parsedArn.resource.split(delimiter).length !== 4) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "Outposts ARN should have two resources outpost/{outpostId}/accesspoint/{accesspointName}"
          });
        }
        var accessPoint = parsedArn.resource.split(delimiter)[3];
        var accessPointPrefix = accessPoint + "-" + parsedArn.accountId;
        if (!s3util.dnsCompatibleBucketName(accessPointPrefix) || accessPointPrefix.match(/\./)) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "Access point resource in ARN is not DNS compatible. Got " + accessPoint
          });
        }
        req._parsedArn.accessPoint = accessPoint;
      },
      validateArnRegion: function validateArnRegion(req, options) {
        if (options === void 0) {
          options = {};
        }
        var useArnRegion = s3util.loadUseArnRegionConfig(req);
        var regionFromArn = req._parsedArn.region;
        var clientRegion = req.service.config.region;
        var useFipsEndpoint = req.service.config.useFipsEndpoint;
        var allowFipsEndpoint = options.allowFipsEndpoint || false;
        if (!regionFromArn) {
          var message = "ARN region is empty";
          if (req._parsedArn.service === "s3") {
            message = message + "\nYou may want to use multi-regional ARN. The feature is not supported in current SDK. You should consider switching to V3(https://github.com/aws/aws-sdk-js-v3).";
          }
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message
          });
        }
        if (useFipsEndpoint && !allowFipsEndpoint) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "ARN endpoint is not compatible with FIPS region"
          });
        }
        if (regionFromArn.indexOf("fips") >= 0) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "FIPS region not allowed in ARN"
          });
        }
        if (!useArnRegion && regionFromArn !== clientRegion) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "Configured region conflicts with access point region"
          });
        } else if (useArnRegion && regionUtil.getEndpointSuffix(regionFromArn) !== regionUtil.getEndpointSuffix(clientRegion)) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "Configured region and access point region not in same partition"
          });
        }
        if (req.service.config.useAccelerateEndpoint) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "useAccelerateEndpoint config is not supported with access point ARN"
          });
        }
        if (req._parsedArn.service === "s3-outposts" && req.service.config.useDualstackEndpoint) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "Dualstack is not supported with outposts access point ARN"
          });
        }
      },
      loadUseArnRegionConfig: function loadUseArnRegionConfig(req) {
        var envName = "AWS_S3_USE_ARN_REGION";
        var configName = "s3_use_arn_region";
        var useArnRegion = true;
        var originalConfig = req.service._originalConfig || {};
        if (req.service.config.s3UseArnRegion !== void 0) {
          return req.service.config.s3UseArnRegion;
        } else if (originalConfig.s3UseArnRegion !== void 0) {
          useArnRegion = originalConfig.s3UseArnRegion === true;
        } else if (AWS2.util.isNode()) {
          if (process.env[envName]) {
            var value = process.env[envName].trim().toLowerCase();
            if (["false", "true"].indexOf(value) < 0) {
              throw AWS2.util.error(new Error(), {
                code: "InvalidConfiguration",
                message: envName + " only accepts true or false. Got " + process.env[envName],
                retryable: false
              });
            }
            useArnRegion = value === "true";
          } else {
            var profiles = {};
            var profile = {};
            try {
              profiles = AWS2.util.getProfilesFromSharedConfig(AWS2.util.iniLoader);
              profile = profiles[process.env.AWS_PROFILE || AWS2.util.defaultProfile];
            } catch (e2) {
            }
            if (profile[configName]) {
              if (["false", "true"].indexOf(profile[configName].trim().toLowerCase()) < 0) {
                throw AWS2.util.error(new Error(), {
                  code: "InvalidConfiguration",
                  message: configName + " only accepts true or false. Got " + profile[configName],
                  retryable: false
                });
              }
              useArnRegion = profile[configName].trim().toLowerCase() === "true";
            }
          }
        }
        req.service.config.s3UseArnRegion = useArnRegion;
        return useArnRegion;
      },
      validatePopulateUriFromArn: function validatePopulateUriFromArn(req) {
        if (req.service._originalConfig && req.service._originalConfig.endpoint) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "Custom endpoint is not compatible with access point ARN"
          });
        }
        if (req.service.config.s3ForcePathStyle) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "Cannot construct path-style endpoint with access point"
          });
        }
      },
      dnsCompatibleBucketName: function dnsCompatibleBucketName(bucketName) {
        var b = bucketName;
        var domain = new RegExp(/^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/);
        var ipAddress = new RegExp(/(\d+\.){3}\d+/);
        var dots = new RegExp(/\.\./);
        return b.match(domain) && !b.match(ipAddress) && !b.match(dots) ? true : false;
      }
    };
    module2.exports = s3util;
  }
});

// node_modules/aws-sdk/lib/s3/managed_upload.js
var require_managed_upload = __commonJS({
  "node_modules/aws-sdk/lib/s3/managed_upload.js"(exports, module2) {
    var AWS2 = require_core2();
    var byteLength = AWS2.util.string.byteLength;
    var Buffer4 = AWS2.util.Buffer;
    AWS2.S3.ManagedUpload = AWS2.util.inherit({
      constructor: function ManagedUpload(options) {
        var self2 = this;
        AWS2.SequentialExecutor.call(self2);
        self2.body = null;
        self2.sliceFn = null;
        self2.callback = null;
        self2.parts = {};
        self2.completeInfo = [];
        self2.fillQueue = function() {
          self2.callback(new Error("Unsupported body payload " + typeof self2.body));
        };
        self2.configure(options);
      },
      configure: function configure(options) {
        options = options || {};
        this.partSize = this.minPartSize;
        if (options.queueSize)
          this.queueSize = options.queueSize;
        if (options.partSize)
          this.partSize = options.partSize;
        if (options.leavePartsOnError)
          this.leavePartsOnError = true;
        if (options.tags) {
          if (!Array.isArray(options.tags)) {
            throw new Error("Tags must be specified as an array; " + typeof options.tags + " provided.");
          }
          this.tags = options.tags;
        }
        if (this.partSize < this.minPartSize) {
          throw new Error("partSize must be greater than " + this.minPartSize);
        }
        this.service = options.service;
        this.bindServiceObject(options.params);
        this.validateBody();
        this.adjustTotalBytes();
      },
      leavePartsOnError: false,
      queueSize: 4,
      partSize: null,
      minPartSize: 1024 * 1024 * 5,
      maxTotalParts: 1e4,
      send: function(callback) {
        var self2 = this;
        self2.failed = false;
        self2.callback = callback || function(err) {
          if (err)
            throw err;
        };
        var runFill = true;
        if (self2.sliceFn) {
          self2.fillQueue = self2.fillBuffer;
        } else if (AWS2.util.isNode()) {
          var Stream3 = AWS2.util.stream.Stream;
          if (self2.body instanceof Stream3) {
            runFill = false;
            self2.fillQueue = self2.fillStream;
            self2.partBuffers = [];
            self2.body.on("error", function(err) {
              self2.cleanup(err);
            }).on("readable", function() {
              self2.fillQueue();
            }).on("end", function() {
              self2.isDoneChunking = true;
              self2.numParts = self2.totalPartNumbers;
              self2.fillQueue.call(self2);
              if (self2.isDoneChunking && self2.totalPartNumbers >= 1 && self2.doneParts === self2.numParts) {
                self2.finishMultiPart();
              }
            });
          }
        }
        if (runFill)
          self2.fillQueue.call(self2);
      },
      abort: function() {
        var self2 = this;
        if (self2.isDoneChunking === true && self2.totalPartNumbers === 1 && self2.singlePart) {
          self2.singlePart.abort();
        } else {
          self2.cleanup(AWS2.util.error(new Error("Request aborted by user"), {
            code: "RequestAbortedError",
            retryable: false
          }));
        }
      },
      validateBody: function validateBody() {
        var self2 = this;
        self2.body = self2.service.config.params.Body;
        if (typeof self2.body === "string") {
          self2.body = AWS2.util.buffer.toBuffer(self2.body);
        } else if (!self2.body) {
          throw new Error("params.Body is required");
        }
        self2.sliceFn = AWS2.util.arraySliceFn(self2.body);
      },
      bindServiceObject: function bindServiceObject(params) {
        params = params || {};
        var self2 = this;
        if (!self2.service) {
          self2.service = new AWS2.S3({ params });
        } else {
          var service = self2.service;
          var config = AWS2.util.copy(service.config);
          config.signatureVersion = service.getSignatureVersion();
          self2.service = new service.constructor.__super__(config);
          self2.service.config.params = AWS2.util.merge(self2.service.config.params || {}, params);
          Object.defineProperty(self2.service, "_originalConfig", {
            get: function() {
              return service._originalConfig;
            },
            enumerable: false,
            configurable: true
          });
        }
      },
      adjustTotalBytes: function adjustTotalBytes() {
        var self2 = this;
        try {
          self2.totalBytes = byteLength(self2.body);
        } catch (e2) {
        }
        if (self2.totalBytes) {
          var newPartSize = Math.ceil(self2.totalBytes / self2.maxTotalParts);
          if (newPartSize > self2.partSize)
            self2.partSize = newPartSize;
        } else {
          self2.totalBytes = void 0;
        }
      },
      isDoneChunking: false,
      partPos: 0,
      totalChunkedBytes: 0,
      totalUploadedBytes: 0,
      totalBytes: void 0,
      numParts: 0,
      totalPartNumbers: 0,
      activeParts: 0,
      doneParts: 0,
      parts: null,
      completeInfo: null,
      failed: false,
      multipartReq: null,
      partBuffers: null,
      partBufferLength: 0,
      fillBuffer: function fillBuffer() {
        var self2 = this;
        var bodyLen = byteLength(self2.body);
        if (bodyLen === 0) {
          self2.isDoneChunking = true;
          self2.numParts = 1;
          self2.nextChunk(self2.body);
          return;
        }
        while (self2.activeParts < self2.queueSize && self2.partPos < bodyLen) {
          var endPos = Math.min(self2.partPos + self2.partSize, bodyLen);
          var buf = self2.sliceFn.call(self2.body, self2.partPos, endPos);
          self2.partPos += self2.partSize;
          if (byteLength(buf) < self2.partSize || self2.partPos === bodyLen) {
            self2.isDoneChunking = true;
            self2.numParts = self2.totalPartNumbers + 1;
          }
          self2.nextChunk(buf);
        }
      },
      fillStream: function fillStream() {
        var self2 = this;
        if (self2.activeParts >= self2.queueSize)
          return;
        var buf = self2.body.read(self2.partSize - self2.partBufferLength) || self2.body.read();
        if (buf) {
          self2.partBuffers.push(buf);
          self2.partBufferLength += buf.length;
          self2.totalChunkedBytes += buf.length;
        }
        if (self2.partBufferLength >= self2.partSize) {
          var pbuf = self2.partBuffers.length === 1 ? self2.partBuffers[0] : Buffer4.concat(self2.partBuffers);
          self2.partBuffers = [];
          self2.partBufferLength = 0;
          if (pbuf.length > self2.partSize) {
            var rest = pbuf.slice(self2.partSize);
            self2.partBuffers.push(rest);
            self2.partBufferLength += rest.length;
            pbuf = pbuf.slice(0, self2.partSize);
          }
          self2.nextChunk(pbuf);
        }
        if (self2.isDoneChunking && !self2.isDoneSending) {
          pbuf = self2.partBuffers.length === 1 ? self2.partBuffers[0] : Buffer4.concat(self2.partBuffers);
          self2.partBuffers = [];
          self2.partBufferLength = 0;
          self2.totalBytes = self2.totalChunkedBytes;
          self2.isDoneSending = true;
          if (self2.numParts === 0 || pbuf.length > 0) {
            self2.numParts++;
            self2.nextChunk(pbuf);
          }
        }
        self2.body.read(0);
      },
      nextChunk: function nextChunk(chunk) {
        var self2 = this;
        if (self2.failed)
          return null;
        var partNumber = ++self2.totalPartNumbers;
        if (self2.isDoneChunking && partNumber === 1) {
          var params = { Body: chunk };
          if (this.tags) {
            params.Tagging = this.getTaggingHeader();
          }
          var req = self2.service.putObject(params);
          req._managedUpload = self2;
          req.on("httpUploadProgress", self2.progress).send(self2.finishSinglePart);
          self2.singlePart = req;
          return null;
        } else if (self2.service.config.params.ContentMD5) {
          var err = AWS2.util.error(new Error("The Content-MD5 you specified is invalid for multi-part uploads."), {
            code: "InvalidDigest",
            retryable: false
          });
          self2.cleanup(err);
          return null;
        }
        if (self2.completeInfo[partNumber] && self2.completeInfo[partNumber].ETag !== null) {
          return null;
        }
        self2.activeParts++;
        if (!self2.service.config.params.UploadId) {
          if (!self2.multipartReq) {
            self2.multipartReq = self2.service.createMultipartUpload();
            self2.multipartReq.on("success", function(resp) {
              self2.service.config.params.UploadId = resp.data.UploadId;
              self2.multipartReq = null;
            });
            self2.queueChunks(chunk, partNumber);
            self2.multipartReq.on("error", function(err2) {
              self2.cleanup(err2);
            });
            self2.multipartReq.send();
          } else {
            self2.queueChunks(chunk, partNumber);
          }
        } else {
          self2.uploadPart(chunk, partNumber);
        }
      },
      getTaggingHeader: function getTaggingHeader() {
        var kvPairStrings = [];
        for (var i2 = 0; i2 < this.tags.length; i2++) {
          kvPairStrings.push(AWS2.util.uriEscape(this.tags[i2].Key) + "=" + AWS2.util.uriEscape(this.tags[i2].Value));
        }
        return kvPairStrings.join("&");
      },
      uploadPart: function uploadPart(chunk, partNumber) {
        var self2 = this;
        var partParams = {
          Body: chunk,
          ContentLength: AWS2.util.string.byteLength(chunk),
          PartNumber: partNumber
        };
        var partInfo = { ETag: null, PartNumber: partNumber };
        self2.completeInfo[partNumber] = partInfo;
        var req = self2.service.uploadPart(partParams);
        self2.parts[partNumber] = req;
        req._lastUploadedBytes = 0;
        req._managedUpload = self2;
        req.on("httpUploadProgress", self2.progress);
        req.send(function(err, data) {
          delete self2.parts[partParams.PartNumber];
          self2.activeParts--;
          if (!err && (!data || !data.ETag)) {
            var message = "No access to ETag property on response.";
            if (AWS2.util.isBrowser()) {
              message += " Check CORS configuration to expose ETag header.";
            }
            err = AWS2.util.error(new Error(message), {
              code: "ETagMissing",
              retryable: false
            });
          }
          if (err)
            return self2.cleanup(err);
          if (self2.completeInfo[partNumber] && self2.completeInfo[partNumber].ETag !== null)
            return null;
          partInfo.ETag = data.ETag;
          self2.doneParts++;
          if (self2.isDoneChunking && self2.doneParts === self2.numParts) {
            self2.finishMultiPart();
          } else {
            self2.fillQueue.call(self2);
          }
        });
      },
      queueChunks: function queueChunks(chunk, partNumber) {
        var self2 = this;
        self2.multipartReq.on("success", function() {
          self2.uploadPart(chunk, partNumber);
        });
      },
      cleanup: function cleanup(err) {
        var self2 = this;
        if (self2.failed)
          return;
        if (typeof self2.body.removeAllListeners === "function" && typeof self2.body.resume === "function") {
          self2.body.removeAllListeners("readable");
          self2.body.removeAllListeners("end");
          self2.body.resume();
        }
        if (self2.multipartReq) {
          self2.multipartReq.removeAllListeners("success");
          self2.multipartReq.removeAllListeners("error");
          self2.multipartReq.removeAllListeners("complete");
          delete self2.multipartReq;
        }
        if (self2.service.config.params.UploadId && !self2.leavePartsOnError) {
          self2.service.abortMultipartUpload().send();
        } else if (self2.leavePartsOnError) {
          self2.isDoneChunking = false;
        }
        AWS2.util.each(self2.parts, function(partNumber, part) {
          part.removeAllListeners("complete");
          part.abort();
        });
        self2.activeParts = 0;
        self2.partPos = 0;
        self2.numParts = 0;
        self2.totalPartNumbers = 0;
        self2.parts = {};
        self2.failed = true;
        self2.callback(err);
      },
      finishMultiPart: function finishMultiPart() {
        var self2 = this;
        var completeParams = { MultipartUpload: { Parts: self2.completeInfo.slice(1) } };
        self2.service.completeMultipartUpload(completeParams, function(err, data) {
          if (err) {
            return self2.cleanup(err);
          }
          if (data && typeof data.Location === "string") {
            data.Location = data.Location.replace(/%2F/g, "/");
          }
          if (Array.isArray(self2.tags)) {
            for (var i2 = 0; i2 < self2.tags.length; i2++) {
              self2.tags[i2].Value = String(self2.tags[i2].Value);
            }
            self2.service.putObjectTagging({ Tagging: { TagSet: self2.tags } }, function(e2, d) {
              if (e2) {
                self2.callback(e2);
              } else {
                self2.callback(e2, data);
              }
            });
          } else {
            self2.callback(err, data);
          }
        });
      },
      finishSinglePart: function finishSinglePart(err, data) {
        var upload = this.request._managedUpload;
        var httpReq = this.request.httpRequest;
        var endpoint = httpReq.endpoint;
        if (err)
          return upload.callback(err);
        data.Location = [endpoint.protocol, "//", endpoint.host, httpReq.path].join("");
        data.key = this.request.params.Key;
        data.Key = this.request.params.Key;
        data.Bucket = this.request.params.Bucket;
        upload.callback(err, data);
      },
      progress: function progress(info) {
        var upload = this._managedUpload;
        if (this.operation === "putObject") {
          info.part = 1;
          info.key = this.params.Key;
        } else {
          upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;
          this._lastUploadedBytes = info.loaded;
          info = {
            loaded: upload.totalUploadedBytes,
            total: upload.totalBytes,
            part: this.params.PartNumber,
            key: this.params.Key
          };
        }
        upload.emit("httpUploadProgress", [info]);
      }
    });
    AWS2.util.mixin(AWS2.S3.ManagedUpload, AWS2.SequentialExecutor);
    AWS2.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.promise = AWS2.util.promisifyMethod("send", PromiseDependency);
    };
    AWS2.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.promise;
    };
    AWS2.util.addPromises(AWS2.S3.ManagedUpload);
    module2.exports = AWS2.S3.ManagedUpload;
  }
});

// node_modules/aws-sdk/lib/services/s3.js
var require_s32 = __commonJS({
  "node_modules/aws-sdk/lib/services/s3.js"() {
    var AWS2 = require_core2();
    var v4Credentials = require_v4_credentials();
    var resolveRegionalEndpointsFlag = require_config_regional_endpoint();
    var s3util = require_s3util();
    var regionUtil = require_region_config();
    require_managed_upload();
    var operationsWith200StatusCodeError = {
      "completeMultipartUpload": true,
      "copyObject": true,
      "uploadPartCopy": true
    };
    var regionRedirectErrorCodes = [
      "AuthorizationHeaderMalformed",
      "BadRequest",
      "PermanentRedirect",
      301
    ];
    var OBJECT_LAMBDA_SERVICE = "s3-object-lambda";
    AWS2.util.update(AWS2.S3.prototype, {
      getSignatureVersion: function getSignatureVersion(request) {
        var defaultApiVersion = this.api.signatureVersion;
        var userDefinedVersion = this._originalConfig ? this._originalConfig.signatureVersion : null;
        var regionDefinedVersion = this.config.signatureVersion;
        var isPresigned = request ? request.isPresigned() : false;
        if (userDefinedVersion) {
          userDefinedVersion = userDefinedVersion === "v2" ? "s3" : userDefinedVersion;
          return userDefinedVersion;
        }
        if (isPresigned !== true) {
          defaultApiVersion = "v4";
        } else if (regionDefinedVersion) {
          defaultApiVersion = regionDefinedVersion;
        }
        return defaultApiVersion;
      },
      getSigningName: function getSigningName(req) {
        if (req && req.operation === "writeGetObjectResponse") {
          return OBJECT_LAMBDA_SERVICE;
        }
        var _super = AWS2.Service.prototype.getSigningName;
        return req && req._parsedArn && req._parsedArn.service ? req._parsedArn.service : _super.call(this);
      },
      getSignerClass: function getSignerClass(request) {
        var signatureVersion = this.getSignatureVersion(request);
        return AWS2.Signers.RequestSigner.getVersion(signatureVersion);
      },
      validateService: function validateService() {
        var msg;
        var messages = [];
        if (!this.config.region)
          this.config.region = "us-east-1";
        if (!this.config.endpoint && this.config.s3BucketEndpoint) {
          messages.push("An endpoint must be provided when configuring `s3BucketEndpoint` to true.");
        }
        if (messages.length === 1) {
          msg = messages[0];
        } else if (messages.length > 1) {
          msg = "Multiple configuration errors:\n" + messages.join("\n");
        }
        if (msg) {
          throw AWS2.util.error(new Error(), { name: "InvalidEndpoint", message: msg });
        }
      },
      shouldDisableBodySigning: function shouldDisableBodySigning(request) {
        var signerClass = this.getSignerClass();
        if (this.config.s3DisableBodySigning === true && signerClass === AWS2.Signers.V4 && request.httpRequest.endpoint.protocol === "https:") {
          return true;
        }
        return false;
      },
      setupRequestListeners: function setupRequestListeners(request) {
        var prependListener = true;
        request.addListener("validate", this.validateScheme);
        request.addListener("validate", this.validateBucketName, prependListener);
        request.addListener("validate", this.optInUsEast1RegionalEndpoint, prependListener);
        request.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_REGION);
        request.addListener("build", this.addContentType);
        request.addListener("build", this.computeContentMd5);
        request.addListener("build", this.computeSseCustomerKeyMd5);
        request.addListener("build", this.populateURI);
        request.addListener("afterBuild", this.addExpect100Continue);
        request.addListener("extractError", this.extractError);
        request.addListener("extractData", AWS2.util.hoistPayloadMember);
        request.addListener("extractData", this.extractData);
        request.addListener("extractData", this.extractErrorFrom200Response);
        request.addListener("beforePresign", this.prepareSignedUrl);
        if (this.shouldDisableBodySigning(request)) {
          request.removeListener("afterBuild", AWS2.EventListeners.Core.COMPUTE_SHA256);
          request.addListener("afterBuild", this.disableBodySigning);
        }
        if (request.operation !== "createBucket" && s3util.isArnInParam(request, "Bucket")) {
          request._parsedArn = AWS2.util.ARN.parse(request.params.Bucket);
          request.removeListener("validate", this.validateBucketName);
          request.removeListener("build", this.populateURI);
          if (request._parsedArn.service === "s3") {
            request.addListener("validate", s3util.validateS3AccessPointArn);
            request.addListener("validate", this.validateArnResourceType);
            request.addListener("validate", this.validateArnRegion);
          } else if (request._parsedArn.service === "s3-outposts") {
            request.addListener("validate", s3util.validateOutpostsAccessPointArn);
            request.addListener("validate", s3util.validateOutpostsArn);
            request.addListener("validate", s3util.validateArnRegion);
          }
          request.addListener("validate", s3util.validateArnAccount);
          request.addListener("validate", s3util.validateArnService);
          request.addListener("build", this.populateUriFromAccessPointArn);
          request.addListener("build", s3util.validatePopulateUriFromArn);
          return;
        }
        request.addListener("validate", this.validateBucketEndpoint);
        request.addListener("validate", this.correctBucketRegionFromCache);
        request.onAsync("extractError", this.requestBucketRegion);
        if (AWS2.util.isBrowser()) {
          request.onAsync("retry", this.reqRegionForNetworkingError);
        }
      },
      validateScheme: function(req) {
        var params = req.params, scheme = req.httpRequest.endpoint.protocol, sensitive = params.SSECustomerKey || params.CopySourceSSECustomerKey;
        if (sensitive && scheme !== "https:") {
          var msg = "Cannot send SSE keys over HTTP. Set 'sslEnabled'to 'true' in your configuration";
          throw AWS2.util.error(new Error(), { code: "ConfigError", message: msg });
        }
      },
      validateBucketEndpoint: function(req) {
        if (!req.params.Bucket && req.service.config.s3BucketEndpoint) {
          var msg = "Cannot send requests to root API with `s3BucketEndpoint` set.";
          throw AWS2.util.error(new Error(), { code: "ConfigError", message: msg });
        }
      },
      validateArnRegion: function validateArnRegion(req) {
        s3util.validateArnRegion(req, { allowFipsEndpoint: true });
      },
      validateArnResourceType: function validateArnResourceType(req) {
        var resource = req._parsedArn.resource;
        if (resource.indexOf("accesspoint:") !== 0 && resource.indexOf("accesspoint/") !== 0) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "ARN resource should begin with 'accesspoint/'"
          });
        }
      },
      validateBucketName: function validateBucketName(req) {
        var service = req.service;
        var signatureVersion = service.getSignatureVersion(req);
        var bucket = req.params && req.params.Bucket;
        var key = req.params && req.params.Key;
        var slashIndex = bucket && bucket.indexOf("/");
        if (bucket && slashIndex >= 0) {
          if (typeof key === "string" && slashIndex > 0) {
            req.params = AWS2.util.copy(req.params);
            var prefix = bucket.substr(slashIndex + 1) || "";
            req.params.Key = prefix + "/" + key;
            req.params.Bucket = bucket.substr(0, slashIndex);
          } else if (signatureVersion === "v4") {
            var msg = "Bucket names cannot contain forward slashes. Bucket: " + bucket;
            throw AWS2.util.error(new Error(), { code: "InvalidBucket", message: msg });
          }
        }
      },
      isValidAccelerateOperation: function isValidAccelerateOperation(operation) {
        var invalidOperations = [
          "createBucket",
          "deleteBucket",
          "listBuckets"
        ];
        return invalidOperations.indexOf(operation) === -1;
      },
      optInUsEast1RegionalEndpoint: function optInUsEast1RegionalEndpoint(req) {
        var service = req.service;
        var config = service.config;
        config.s3UsEast1RegionalEndpoint = resolveRegionalEndpointsFlag(service._originalConfig, {
          env: "AWS_S3_US_EAST_1_REGIONAL_ENDPOINT",
          sharedConfig: "s3_us_east_1_regional_endpoint",
          clientConfig: "s3UsEast1RegionalEndpoint"
        });
        if (!(service._originalConfig || {}).endpoint && req.httpRequest.region === "us-east-1" && config.s3UsEast1RegionalEndpoint === "regional" && req.httpRequest.endpoint.hostname.indexOf("s3.amazonaws.com") >= 0) {
          var insertPoint = config.endpoint.indexOf(".amazonaws.com");
          regionalEndpoint = config.endpoint.substring(0, insertPoint) + ".us-east-1" + config.endpoint.substring(insertPoint);
          req.httpRequest.updateEndpoint(regionalEndpoint);
        }
      },
      populateURI: function populateURI(req) {
        var httpRequest = req.httpRequest;
        var b = req.params.Bucket;
        var service = req.service;
        var endpoint = httpRequest.endpoint;
        if (b) {
          if (!service.pathStyleBucketName(b)) {
            if (service.config.useAccelerateEndpoint && service.isValidAccelerateOperation(req.operation)) {
              if (service.config.useDualstackEndpoint) {
                endpoint.hostname = b + ".s3-accelerate.dualstack.amazonaws.com";
              } else {
                endpoint.hostname = b + ".s3-accelerate.amazonaws.com";
              }
            } else if (!service.config.s3BucketEndpoint) {
              endpoint.hostname = b + "." + endpoint.hostname;
            }
            var port = endpoint.port;
            if (port !== 80 && port !== 443) {
              endpoint.host = endpoint.hostname + ":" + endpoint.port;
            } else {
              endpoint.host = endpoint.hostname;
            }
            httpRequest.virtualHostedBucket = b;
            service.removeVirtualHostedBucketFromPath(req);
          }
        }
      },
      removeVirtualHostedBucketFromPath: function removeVirtualHostedBucketFromPath(req) {
        var httpRequest = req.httpRequest;
        var bucket = httpRequest.virtualHostedBucket;
        if (bucket && httpRequest.path) {
          if (req.params && req.params.Key) {
            var encodedS3Key = "/" + AWS2.util.uriEscapePath(req.params.Key);
            if (httpRequest.path.indexOf(encodedS3Key) === 0 && (httpRequest.path.length === encodedS3Key.length || httpRequest.path[encodedS3Key.length] === "?")) {
              return;
            }
          }
          httpRequest.path = httpRequest.path.replace(new RegExp("/" + bucket), "");
          if (httpRequest.path[0] !== "/") {
            httpRequest.path = "/" + httpRequest.path;
          }
        }
      },
      populateUriFromAccessPointArn: function populateUriFromAccessPointArn(req) {
        var accessPointArn = req._parsedArn;
        var isOutpostArn = accessPointArn.service === "s3-outposts";
        var isObjectLambdaArn = accessPointArn.service === "s3-object-lambda";
        var outpostsSuffix = isOutpostArn ? "." + accessPointArn.outpostId : "";
        var serviceName = isOutpostArn ? "s3-outposts" : "s3-accesspoint";
        var fipsSuffix = !isOutpostArn && req.service.config.useFipsEndpoint ? "-fips" : "";
        var dualStackSuffix = !isOutpostArn && req.service.config.useDualstackEndpoint ? ".dualstack" : "";
        var endpoint = req.httpRequest.endpoint;
        var dnsSuffix = regionUtil.getEndpointSuffix(accessPointArn.region);
        var useArnRegion = req.service.config.s3UseArnRegion;
        endpoint.hostname = [
          accessPointArn.accessPoint + "-" + accessPointArn.accountId + outpostsSuffix,
          serviceName + fipsSuffix + dualStackSuffix,
          useArnRegion ? accessPointArn.region : req.service.config.region,
          dnsSuffix
        ].join(".");
        if (isObjectLambdaArn) {
          var serviceName = "s3-object-lambda";
          var accesspointName = accessPointArn.resource.split("/")[1];
          var fipsSuffix = req.service.config.useFipsEndpoint ? "-fips" : "";
          endpoint.hostname = [
            accesspointName + "-" + accessPointArn.accountId,
            serviceName + fipsSuffix,
            useArnRegion ? accessPointArn.region : req.service.config.region,
            dnsSuffix
          ].join(".");
        }
        endpoint.host = endpoint.hostname;
        var encodedArn = AWS2.util.uriEscape(req.params.Bucket);
        var path8 = req.httpRequest.path;
        req.httpRequest.path = path8.replace(new RegExp("/" + encodedArn), "");
        if (req.httpRequest.path[0] !== "/") {
          req.httpRequest.path = "/" + req.httpRequest.path;
        }
        req.httpRequest.region = accessPointArn.region;
      },
      addExpect100Continue: function addExpect100Continue(req) {
        var len = req.httpRequest.headers["Content-Length"];
        if (AWS2.util.isNode() && (len >= 1024 * 1024 || req.params.Body instanceof AWS2.util.stream.Stream)) {
          req.httpRequest.headers["Expect"] = "100-continue";
        }
      },
      addContentType: function addContentType(req) {
        var httpRequest = req.httpRequest;
        if (httpRequest.method === "GET" || httpRequest.method === "HEAD") {
          delete httpRequest.headers["Content-Type"];
          return;
        }
        if (!httpRequest.headers["Content-Type"]) {
          httpRequest.headers["Content-Type"] = "application/octet-stream";
        }
        var contentType = httpRequest.headers["Content-Type"];
        if (AWS2.util.isBrowser()) {
          if (typeof httpRequest.body === "string" && !contentType.match(/;\s*charset=/)) {
            var charset = "; charset=UTF-8";
            httpRequest.headers["Content-Type"] += charset;
          } else {
            var replaceFn = function(_, prefix, charsetName) {
              return prefix + charsetName.toUpperCase();
            };
            httpRequest.headers["Content-Type"] = contentType.replace(/(;\s*charset=)(.+)$/, replaceFn);
          }
        }
      },
      willComputeChecksums: function willComputeChecksums(req) {
        var rules = req.service.api.operations[req.operation].input.members;
        var body = req.httpRequest.body;
        var needsContentMD5 = req.service.config.computeChecksums && rules.ContentMD5 && !req.params.ContentMD5 && body && (AWS2.util.Buffer.isBuffer(req.httpRequest.body) || typeof req.httpRequest.body === "string");
        if (needsContentMD5 && req.service.shouldDisableBodySigning(req) && !req.isPresigned()) {
          return true;
        }
        if (needsContentMD5 && this.getSignatureVersion(req) === "s3" && req.isPresigned()) {
          return true;
        }
        return false;
      },
      computeContentMd5: function computeContentMd5(req) {
        if (req.service.willComputeChecksums(req)) {
          var md5 = AWS2.util.crypto.md5(req.httpRequest.body, "base64");
          req.httpRequest.headers["Content-MD5"] = md5;
        }
      },
      computeSseCustomerKeyMd5: function computeSseCustomerKeyMd5(req) {
        var keys = {
          SSECustomerKey: "x-amz-server-side-encryption-customer-key-MD5",
          CopySourceSSECustomerKey: "x-amz-copy-source-server-side-encryption-customer-key-MD5"
        };
        AWS2.util.each(keys, function(key, header) {
          if (req.params[key]) {
            var value = AWS2.util.crypto.md5(req.params[key], "base64");
            req.httpRequest.headers[header] = value;
          }
        });
      },
      pathStyleBucketName: function pathStyleBucketName(bucketName) {
        if (this.config.s3ForcePathStyle)
          return true;
        if (this.config.s3BucketEndpoint)
          return false;
        if (s3util.dnsCompatibleBucketName(bucketName)) {
          return this.config.sslEnabled && bucketName.match(/\./) ? true : false;
        } else {
          return true;
        }
      },
      extractErrorFrom200Response: function extractErrorFrom200Response(resp) {
        if (!operationsWith200StatusCodeError[resp.request.operation])
          return;
        var httpResponse = resp.httpResponse;
        if (httpResponse.body && httpResponse.body.toString().match("<Error>")) {
          resp.data = null;
          var service = this.service ? this.service : this;
          service.extractError(resp);
          throw resp.error;
        } else if (!httpResponse.body || !httpResponse.body.toString().match(/<[\w_]/)) {
          resp.data = null;
          throw AWS2.util.error(new Error(), {
            code: "InternalError",
            message: "S3 aborted request"
          });
        }
      },
      retryableError: function retryableError(error2, request) {
        if (operationsWith200StatusCodeError[request.operation] && error2.statusCode === 200) {
          return true;
        } else if (request._requestRegionForBucket && request.service.bucketRegionCache[request._requestRegionForBucket]) {
          return false;
        } else if (error2 && error2.code === "RequestTimeout") {
          return true;
        } else if (error2 && regionRedirectErrorCodes.indexOf(error2.code) != -1 && error2.region && error2.region != request.httpRequest.region) {
          request.httpRequest.region = error2.region;
          if (error2.statusCode === 301) {
            request.service.updateReqBucketRegion(request);
          }
          return true;
        } else {
          var _super = AWS2.Service.prototype.retryableError;
          return _super.call(this, error2, request);
        }
      },
      updateReqBucketRegion: function updateReqBucketRegion(request, region) {
        var httpRequest = request.httpRequest;
        if (typeof region === "string" && region.length) {
          httpRequest.region = region;
        }
        if (!httpRequest.endpoint.host.match(/s3(?!-accelerate).*\.amazonaws\.com$/)) {
          return;
        }
        var service = request.service;
        var s3Config = service.config;
        var s3BucketEndpoint = s3Config.s3BucketEndpoint;
        if (s3BucketEndpoint) {
          delete s3Config.s3BucketEndpoint;
        }
        var newConfig = AWS2.util.copy(s3Config);
        delete newConfig.endpoint;
        newConfig.region = httpRequest.region;
        httpRequest.endpoint = new AWS2.S3(newConfig).endpoint;
        service.populateURI(request);
        s3Config.s3BucketEndpoint = s3BucketEndpoint;
        httpRequest.headers.Host = httpRequest.endpoint.host;
        if (request._asm.currentState === "validate") {
          request.removeListener("build", service.populateURI);
          request.addListener("build", service.removeVirtualHostedBucketFromPath);
        }
      },
      extractData: function extractData(resp) {
        var req = resp.request;
        if (req.operation === "getBucketLocation") {
          var match = resp.httpResponse.body.toString().match(/>(.+)<\/Location/);
          delete resp.data["_"];
          if (match) {
            resp.data.LocationConstraint = match[1];
          } else {
            resp.data.LocationConstraint = "";
          }
        }
        var bucket = req.params.Bucket || null;
        if (req.operation === "deleteBucket" && typeof bucket === "string" && !resp.error) {
          req.service.clearBucketRegionCache(bucket);
        } else {
          var headers = resp.httpResponse.headers || {};
          var region = headers["x-amz-bucket-region"] || null;
          if (!region && req.operation === "createBucket" && !resp.error) {
            var createBucketConfiguration = req.params.CreateBucketConfiguration;
            if (!createBucketConfiguration) {
              region = "us-east-1";
            } else if (createBucketConfiguration.LocationConstraint === "EU") {
              region = "eu-west-1";
            } else {
              region = createBucketConfiguration.LocationConstraint;
            }
          }
          if (region) {
            if (bucket && region !== req.service.bucketRegionCache[bucket]) {
              req.service.bucketRegionCache[bucket] = region;
            }
          }
        }
        req.service.extractRequestIds(resp);
      },
      extractError: function extractError(resp) {
        var codes = {
          304: "NotModified",
          403: "Forbidden",
          400: "BadRequest",
          404: "NotFound"
        };
        var req = resp.request;
        var code = resp.httpResponse.statusCode;
        var body = resp.httpResponse.body || "";
        var headers = resp.httpResponse.headers || {};
        var region = headers["x-amz-bucket-region"] || null;
        var bucket = req.params.Bucket || null;
        var bucketRegionCache = req.service.bucketRegionCache;
        if (region && bucket && region !== bucketRegionCache[bucket]) {
          bucketRegionCache[bucket] = region;
        }
        var cachedRegion;
        if (codes[code] && body.length === 0) {
          if (bucket && !region) {
            cachedRegion = bucketRegionCache[bucket] || null;
            if (cachedRegion !== req.httpRequest.region) {
              region = cachedRegion;
            }
          }
          resp.error = AWS2.util.error(new Error(), {
            code: codes[code],
            message: null,
            region
          });
        } else {
          var data = new AWS2.XML.Parser().parse(body.toString());
          if (data.Region && !region) {
            region = data.Region;
            if (bucket && region !== bucketRegionCache[bucket]) {
              bucketRegionCache[bucket] = region;
            }
          } else if (bucket && !region && !data.Region) {
            cachedRegion = bucketRegionCache[bucket] || null;
            if (cachedRegion !== req.httpRequest.region) {
              region = cachedRegion;
            }
          }
          resp.error = AWS2.util.error(new Error(), {
            code: data.Code || code,
            message: data.Message || null,
            region
          });
        }
        req.service.extractRequestIds(resp);
      },
      requestBucketRegion: function requestBucketRegion(resp, done) {
        var error2 = resp.error;
        var req = resp.request;
        var bucket = req.params.Bucket || null;
        if (!error2 || !bucket || error2.region || req.operation === "listObjects" || AWS2.util.isNode() && req.operation === "headBucket" || error2.statusCode === 400 && req.operation !== "headObject" || regionRedirectErrorCodes.indexOf(error2.code) === -1) {
          return done();
        }
        var reqOperation = AWS2.util.isNode() ? "headBucket" : "listObjects";
        var reqParams = { Bucket: bucket };
        if (reqOperation === "listObjects")
          reqParams.MaxKeys = 0;
        var regionReq = req.service[reqOperation](reqParams);
        regionReq._requestRegionForBucket = bucket;
        regionReq.send(function() {
          var region = req.service.bucketRegionCache[bucket] || null;
          error2.region = region;
          done();
        });
      },
      reqRegionForNetworkingError: function reqRegionForNetworkingError(resp, done) {
        if (!AWS2.util.isBrowser()) {
          return done();
        }
        var error2 = resp.error;
        var request = resp.request;
        var bucket = request.params.Bucket;
        if (!error2 || error2.code !== "NetworkingError" || !bucket || request.httpRequest.region === "us-east-1") {
          return done();
        }
        var service = request.service;
        var bucketRegionCache = service.bucketRegionCache;
        var cachedRegion = bucketRegionCache[bucket] || null;
        if (cachedRegion && cachedRegion !== request.httpRequest.region) {
          service.updateReqBucketRegion(request, cachedRegion);
          done();
        } else if (!s3util.dnsCompatibleBucketName(bucket)) {
          service.updateReqBucketRegion(request, "us-east-1");
          if (bucketRegionCache[bucket] !== "us-east-1") {
            bucketRegionCache[bucket] = "us-east-1";
          }
          done();
        } else if (request.httpRequest.virtualHostedBucket) {
          var getRegionReq = service.listObjects({ Bucket: bucket, MaxKeys: 0 });
          service.updateReqBucketRegion(getRegionReq, "us-east-1");
          getRegionReq._requestRegionForBucket = bucket;
          getRegionReq.send(function() {
            var region = service.bucketRegionCache[bucket] || null;
            if (region && region !== request.httpRequest.region) {
              service.updateReqBucketRegion(request, region);
            }
            done();
          });
        } else {
          done();
        }
      },
      bucketRegionCache: {},
      clearBucketRegionCache: function(buckets) {
        var bucketRegionCache = this.bucketRegionCache;
        if (!buckets) {
          buckets = Object.keys(bucketRegionCache);
        } else if (typeof buckets === "string") {
          buckets = [buckets];
        }
        for (var i2 = 0; i2 < buckets.length; i2++) {
          delete bucketRegionCache[buckets[i2]];
        }
        return bucketRegionCache;
      },
      correctBucketRegionFromCache: function correctBucketRegionFromCache(req) {
        var bucket = req.params.Bucket || null;
        if (bucket) {
          var service = req.service;
          var requestRegion = req.httpRequest.region;
          var cachedRegion = service.bucketRegionCache[bucket];
          if (cachedRegion && cachedRegion !== requestRegion) {
            service.updateReqBucketRegion(req, cachedRegion);
          }
        }
      },
      extractRequestIds: function extractRequestIds(resp) {
        var extendedRequestId = resp.httpResponse.headers ? resp.httpResponse.headers["x-amz-id-2"] : null;
        var cfId = resp.httpResponse.headers ? resp.httpResponse.headers["x-amz-cf-id"] : null;
        resp.extendedRequestId = extendedRequestId;
        resp.cfId = cfId;
        if (resp.error) {
          resp.error.requestId = resp.requestId || null;
          resp.error.extendedRequestId = extendedRequestId;
          resp.error.cfId = cfId;
        }
      },
      getSignedUrl: function getSignedUrl(operation, params, callback) {
        params = AWS2.util.copy(params || {});
        var expires = params.Expires || 900;
        if (typeof expires !== "number") {
          throw AWS2.util.error(new Error(), { code: "InvalidParameterException", message: "The expiration must be a number, received " + typeof expires });
        }
        delete params.Expires;
        var request = this.makeRequest(operation, params);
        if (callback) {
          AWS2.util.defer(function() {
            request.presign(expires, callback);
          });
        } else {
          return request.presign(expires, callback);
        }
      },
      createPresignedPost: function createPresignedPost(params, callback) {
        if (typeof params === "function" && callback === void 0) {
          callback = params;
          params = null;
        }
        params = AWS2.util.copy(params || {});
        var boundParams = this.config.params || {};
        var bucket = params.Bucket || boundParams.Bucket, self2 = this, config = this.config, endpoint = AWS2.util.copy(this.endpoint);
        if (!config.s3BucketEndpoint) {
          endpoint.pathname = "/" + bucket;
        }
        function finalizePost() {
          return {
            url: AWS2.util.urlFormat(endpoint),
            fields: self2.preparePostFields(config.credentials, config.region, bucket, params.Fields, params.Conditions, params.Expires)
          };
        }
        if (callback) {
          config.getCredentials(function(err) {
            if (err) {
              callback(err);
            } else {
              try {
                callback(null, finalizePost());
              } catch (err2) {
                callback(err2);
              }
            }
          });
        } else {
          return finalizePost();
        }
      },
      preparePostFields: function preparePostFields(credentials, region, bucket, fields, conditions, expiresInSeconds) {
        var now = this.getSkewCorrectedDate();
        if (!credentials || !region || !bucket) {
          throw new Error("Unable to create a POST object policy without a bucket, region, and credentials");
        }
        fields = AWS2.util.copy(fields || {});
        conditions = (conditions || []).slice(0);
        expiresInSeconds = expiresInSeconds || 3600;
        var signingDate = AWS2.util.date.iso8601(now).replace(/[:\-]|\.\d{3}/g, "");
        var shortDate = signingDate.substr(0, 8);
        var scope = v4Credentials.createScope(shortDate, region, "s3");
        var credential = credentials.accessKeyId + "/" + scope;
        fields["bucket"] = bucket;
        fields["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256";
        fields["X-Amz-Credential"] = credential;
        fields["X-Amz-Date"] = signingDate;
        if (credentials.sessionToken) {
          fields["X-Amz-Security-Token"] = credentials.sessionToken;
        }
        for (var field in fields) {
          if (fields.hasOwnProperty(field)) {
            var condition = {};
            condition[field] = fields[field];
            conditions.push(condition);
          }
        }
        fields.Policy = this.preparePostPolicy(new Date(now.valueOf() + expiresInSeconds * 1e3), conditions);
        fields["X-Amz-Signature"] = AWS2.util.crypto.hmac(v4Credentials.getSigningKey(credentials, shortDate, region, "s3", true), fields.Policy, "hex");
        return fields;
      },
      preparePostPolicy: function preparePostPolicy(expiration, conditions) {
        return AWS2.util.base64.encode(JSON.stringify({
          expiration: AWS2.util.date.iso8601(expiration),
          conditions
        }));
      },
      prepareSignedUrl: function prepareSignedUrl(request) {
        request.addListener("validate", request.service.noPresignedContentLength);
        request.removeListener("build", request.service.addContentType);
        if (!request.params.Body) {
          request.removeListener("build", request.service.computeContentMd5);
        } else {
          request.addListener("afterBuild", AWS2.EventListeners.Core.COMPUTE_SHA256);
        }
      },
      disableBodySigning: function disableBodySigning(request) {
        var headers = request.httpRequest.headers;
        if (!Object.prototype.hasOwnProperty.call(headers, "presigned-expires")) {
          headers["X-Amz-Content-Sha256"] = "UNSIGNED-PAYLOAD";
        }
      },
      noPresignedContentLength: function noPresignedContentLength(request) {
        if (request.params.ContentLength !== void 0) {
          throw AWS2.util.error(new Error(), {
            code: "UnexpectedParameter",
            message: "ContentLength is not supported in pre-signed URLs."
          });
        }
      },
      createBucket: function createBucket(params, callback) {
        if (typeof params === "function" || !params) {
          callback = callback || params;
          params = {};
        }
        var hostname = this.endpoint.hostname;
        var copiedParams = AWS2.util.copy(params);
        if (hostname !== this.api.globalEndpoint && !params.CreateBucketConfiguration) {
          copiedParams.CreateBucketConfiguration = { LocationConstraint: this.config.region };
        }
        return this.makeRequest("createBucket", copiedParams, callback);
      },
      writeGetObjectResponse: function writeGetObjectResponse(params, callback) {
        var request = this.makeRequest("writeGetObjectResponse", AWS2.util.copy(params), callback);
        var hostname = this.endpoint.hostname;
        if (hostname.indexOf(this.config.region) !== -1) {
          hostname = hostname.replace("s3.", OBJECT_LAMBDA_SERVICE + ".");
        } else {
          hostname = hostname.replace("s3.", OBJECT_LAMBDA_SERVICE + "." + this.config.region + ".");
        }
        request.httpRequest.endpoint = new AWS2.Endpoint(hostname, this.config);
        return request;
      },
      upload: function upload(params, options, callback) {
        if (typeof options === "function" && callback === void 0) {
          callback = options;
          options = null;
        }
        options = options || {};
        options = AWS2.util.merge(options || {}, { service: this, params });
        var uploader = new AWS2.S3.ManagedUpload(options);
        if (typeof callback === "function")
          uploader.send(callback);
        return uploader;
      }
    });
    AWS2.S3.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.getSignedUrlPromise = AWS2.util.promisifyMethod("getSignedUrl", PromiseDependency);
    };
    AWS2.S3.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.getSignedUrlPromise;
    };
    AWS2.util.addPromises(AWS2.S3);
  }
});

// node_modules/aws-sdk/apis/s3-2006-03-01.min.json
var require_s3_2006_03_01_min = __commonJS({
  "node_modules/aws-sdk/apis/s3-2006-03-01.min.json"(exports, module2) {
    module2.exports = {
      version: "2.0",
      metadata: {
        apiVersion: "2006-03-01",
        checksumFormat: "md5",
        endpointPrefix: "s3",
        globalEndpoint: "s3.amazonaws.com",
        protocol: "rest-xml",
        serviceAbbreviation: "Amazon S3",
        serviceFullName: "Amazon Simple Storage Service",
        serviceId: "S3",
        signatureVersion: "s3",
        uid: "s3-2006-03-01"
      },
      operations: {
        AbortMultipartUpload: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}/{Key+}",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "UploadId"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              UploadId: {
                location: "querystring",
                locationName: "uploadId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          }
        },
        CompleteMultipartUpload: {
          http: {
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "UploadId"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              MultipartUpload: {
                locationName: "CompleteMultipartUpload",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  Parts: {
                    locationName: "Part",
                    type: "list",
                    member: {
                      type: "structure",
                      members: {
                        ETag: {},
                        ChecksumCRC32: {},
                        ChecksumCRC32C: {},
                        ChecksumSHA1: {},
                        ChecksumSHA256: {},
                        PartNumber: {
                          type: "integer"
                        }
                      }
                    },
                    flattened: true
                  }
                }
              },
              UploadId: {
                location: "querystring",
                locationName: "uploadId"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              }
            },
            payload: "MultipartUpload"
          },
          output: {
            type: "structure",
            members: {
              Location: {},
              Bucket: {},
              Key: {},
              Expiration: {
                location: "header",
                locationName: "x-amz-expiration"
              },
              ETag: {},
              ChecksumCRC32: {},
              ChecksumCRC32C: {},
              ChecksumSHA1: {},
              ChecksumSHA256: {},
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          }
        },
        CopyObject: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "CopySource",
              "Key"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              CacheControl: {
                location: "header",
                locationName: "Cache-Control"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-checksum-algorithm"
              },
              ContentDisposition: {
                location: "header",
                locationName: "Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "Content-Language"
              },
              ContentType: {
                location: "header",
                locationName: "Content-Type"
              },
              CopySource: {
                location: "header",
                locationName: "x-amz-copy-source"
              },
              CopySourceIfMatch: {
                location: "header",
                locationName: "x-amz-copy-source-if-match"
              },
              CopySourceIfModifiedSince: {
                location: "header",
                locationName: "x-amz-copy-source-if-modified-since",
                type: "timestamp"
              },
              CopySourceIfNoneMatch: {
                location: "header",
                locationName: "x-amz-copy-source-if-none-match"
              },
              CopySourceIfUnmodifiedSince: {
                location: "header",
                locationName: "x-amz-copy-source-if-unmodified-since",
                type: "timestamp"
              },
              Expires: {
                location: "header",
                locationName: "Expires",
                type: "timestamp"
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              MetadataDirective: {
                location: "header",
                locationName: "x-amz-metadata-directive"
              },
              TaggingDirective: {
                location: "header",
                locationName: "x-amz-tagging-directive"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-storage-class"
              },
              WebsiteRedirectLocation: {
                location: "header",
                locationName: "x-amz-website-redirect-location"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              CopySourceSSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-algorithm"
              },
              CopySourceSSECustomerKey: {
                shape: "S1k",
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-key"
              },
              CopySourceSSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              Tagging: {
                location: "header",
                locationName: "x-amz-tagging"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-object-lock-mode"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-object-lock-retain-until-date"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-object-lock-legal-hold"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ExpectedSourceBucketOwner: {
                location: "header",
                locationName: "x-amz-source-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              CopyObjectResult: {
                type: "structure",
                members: {
                  ETag: {},
                  LastModified: {
                    type: "timestamp"
                  },
                  ChecksumCRC32: {},
                  ChecksumCRC32C: {},
                  ChecksumSHA1: {},
                  ChecksumSHA256: {}
                }
              },
              Expiration: {
                location: "header",
                locationName: "x-amz-expiration"
              },
              CopySourceVersionId: {
                location: "header",
                locationName: "x-amz-copy-source-version-id"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            },
            payload: "CopyObjectResult"
          },
          alias: "PutObjectCopy"
        },
        CreateBucket: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              CreateBucketConfiguration: {
                locationName: "CreateBucketConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  LocationConstraint: {}
                }
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWrite: {
                location: "header",
                locationName: "x-amz-grant-write"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              ObjectLockEnabledForBucket: {
                location: "header",
                locationName: "x-amz-bucket-object-lock-enabled",
                type: "boolean"
              },
              ObjectOwnership: {
                location: "header",
                locationName: "x-amz-object-ownership"
              }
            },
            payload: "CreateBucketConfiguration"
          },
          output: {
            type: "structure",
            members: {
              Location: {
                location: "header",
                locationName: "Location"
              }
            }
          },
          alias: "PutBucket"
        },
        CreateMultipartUpload: {
          http: {
            requestUri: "/{Bucket}/{Key+}?uploads"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              CacheControl: {
                location: "header",
                locationName: "Cache-Control"
              },
              ContentDisposition: {
                location: "header",
                locationName: "Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "Content-Language"
              },
              ContentType: {
                location: "header",
                locationName: "Content-Type"
              },
              Expires: {
                location: "header",
                locationName: "Expires",
                type: "timestamp"
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-storage-class"
              },
              WebsiteRedirectLocation: {
                location: "header",
                locationName: "x-amz-website-redirect-location"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              Tagging: {
                location: "header",
                locationName: "x-amz-tagging"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-object-lock-mode"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-object-lock-retain-until-date"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-object-lock-legal-hold"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-checksum-algorithm"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              AbortDate: {
                location: "header",
                locationName: "x-amz-abort-date",
                type: "timestamp"
              },
              AbortRuleId: {
                location: "header",
                locationName: "x-amz-abort-rule-id"
              },
              Bucket: {
                locationName: "Bucket"
              },
              Key: {},
              UploadId: {},
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-checksum-algorithm"
              }
            }
          },
          alias: "InitiateMultipartUpload"
        },
        DeleteBucket: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteBucketAnalyticsConfiguration: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?analytics",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteBucketCors: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?cors",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteBucketEncryption: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?encryption",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteBucketIntelligentTieringConfiguration: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?intelligent-tiering",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              }
            }
          }
        },
        DeleteBucketInventoryConfiguration: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?inventory",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteBucketLifecycle: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?lifecycle",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteBucketMetricsConfiguration: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?metrics",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteBucketOwnershipControls: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?ownershipControls",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteBucketPolicy: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?policy",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteBucketReplication: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?replication",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteBucketTagging: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?tagging",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteBucketWebsite: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?website",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        DeleteObject: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}/{Key+}",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              MFA: {
                location: "header",
                locationName: "x-amz-mfa"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              BypassGovernanceRetention: {
                location: "header",
                locationName: "x-amz-bypass-governance-retention",
                type: "boolean"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              DeleteMarker: {
                location: "header",
                locationName: "x-amz-delete-marker",
                type: "boolean"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          }
        },
        DeleteObjectTagging: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}/{Key+}?tagging",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              }
            }
          }
        },
        DeleteObjects: {
          http: {
            requestUri: "/{Bucket}?delete"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Delete"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Delete: {
                locationName: "Delete",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                required: [
                  "Objects"
                ],
                members: {
                  Objects: {
                    locationName: "Object",
                    type: "list",
                    member: {
                      type: "structure",
                      required: [
                        "Key"
                      ],
                      members: {
                        Key: {},
                        VersionId: {}
                      }
                    },
                    flattened: true
                  },
                  Quiet: {
                    type: "boolean"
                  }
                }
              },
              MFA: {
                location: "header",
                locationName: "x-amz-mfa"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              BypassGovernanceRetention: {
                location: "header",
                locationName: "x-amz-bypass-governance-retention",
                type: "boolean"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              }
            },
            payload: "Delete"
          },
          output: {
            type: "structure",
            members: {
              Deleted: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    Key: {},
                    VersionId: {},
                    DeleteMarker: {
                      type: "boolean"
                    },
                    DeleteMarkerVersionId: {}
                  }
                },
                flattened: true
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              Errors: {
                locationName: "Error",
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    Key: {},
                    VersionId: {},
                    Code: {},
                    Message: {}
                  }
                },
                flattened: true
              }
            }
          },
          alias: "DeleteMultipleObjects",
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        DeletePublicAccessBlock: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?publicAccessBlock",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        GetBucketAccelerateConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?accelerate"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Status: {}
            }
          }
        },
        GetBucketAcl: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?acl"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Owner: {
                shape: "S3d"
              },
              Grants: {
                shape: "S3g",
                locationName: "AccessControlList"
              }
            }
          }
        },
        GetBucketAnalyticsConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?analytics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              AnalyticsConfiguration: {
                shape: "S3p"
              }
            },
            payload: "AnalyticsConfiguration"
          }
        },
        GetBucketCors: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?cors"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              CORSRules: {
                shape: "S44",
                locationName: "CORSRule"
              }
            }
          }
        },
        GetBucketEncryption: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?encryption"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              ServerSideEncryptionConfiguration: {
                shape: "S4h"
              }
            },
            payload: "ServerSideEncryptionConfiguration"
          }
        },
        GetBucketIntelligentTieringConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?intelligent-tiering"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IntelligentTieringConfiguration: {
                shape: "S4n"
              }
            },
            payload: "IntelligentTieringConfiguration"
          }
        },
        GetBucketInventoryConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?inventory"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              InventoryConfiguration: {
                shape: "S4x"
              }
            },
            payload: "InventoryConfiguration"
          }
        },
        GetBucketLifecycle: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?lifecycle"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Rules: {
                shape: "S5d",
                locationName: "Rule"
              }
            }
          },
          deprecated: true
        },
        GetBucketLifecycleConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?lifecycle"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Rules: {
                shape: "S5t",
                locationName: "Rule"
              }
            }
          }
        },
        GetBucketLocation: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?location"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              LocationConstraint: {}
            }
          }
        },
        GetBucketLogging: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?logging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              LoggingEnabled: {
                shape: "S65"
              }
            }
          }
        },
        GetBucketMetricsConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?metrics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              MetricsConfiguration: {
                shape: "S6d"
              }
            },
            payload: "MetricsConfiguration"
          }
        },
        GetBucketNotification: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?notification"
          },
          input: {
            shape: "S6h"
          },
          output: {
            shape: "S6i"
          },
          deprecated: true
        },
        GetBucketNotificationConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?notification"
          },
          input: {
            shape: "S6h"
          },
          output: {
            shape: "S6t"
          }
        },
        GetBucketOwnershipControls: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?ownershipControls"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              OwnershipControls: {
                shape: "S7a"
              }
            },
            payload: "OwnershipControls"
          }
        },
        GetBucketPolicy: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?policy"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Policy: {}
            },
            payload: "Policy"
          }
        },
        GetBucketPolicyStatus: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?policyStatus"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              PolicyStatus: {
                type: "structure",
                members: {
                  IsPublic: {
                    locationName: "IsPublic",
                    type: "boolean"
                  }
                }
              }
            },
            payload: "PolicyStatus"
          }
        },
        GetBucketReplication: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?replication"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              ReplicationConfiguration: {
                shape: "S7m"
              }
            },
            payload: "ReplicationConfiguration"
          }
        },
        GetBucketRequestPayment: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?requestPayment"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Payer: {}
            }
          }
        },
        GetBucketTagging: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?tagging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            required: [
              "TagSet"
            ],
            members: {
              TagSet: {
                shape: "S3v"
              }
            }
          }
        },
        GetBucketVersioning: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?versioning"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Status: {},
              MFADelete: {
                locationName: "MfaDelete"
              }
            }
          }
        },
        GetBucketWebsite: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?website"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              RedirectAllRequestsTo: {
                shape: "S8p"
              },
              IndexDocument: {
                shape: "S8s"
              },
              ErrorDocument: {
                shape: "S8u"
              },
              RoutingRules: {
                shape: "S8v"
              }
            }
          }
        },
        GetObject: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              IfMatch: {
                location: "header",
                locationName: "If-Match"
              },
              IfModifiedSince: {
                location: "header",
                locationName: "If-Modified-Since",
                type: "timestamp"
              },
              IfNoneMatch: {
                location: "header",
                locationName: "If-None-Match"
              },
              IfUnmodifiedSince: {
                location: "header",
                locationName: "If-Unmodified-Since",
                type: "timestamp"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              Range: {
                location: "header",
                locationName: "Range"
              },
              ResponseCacheControl: {
                location: "querystring",
                locationName: "response-cache-control"
              },
              ResponseContentDisposition: {
                location: "querystring",
                locationName: "response-content-disposition"
              },
              ResponseContentEncoding: {
                location: "querystring",
                locationName: "response-content-encoding"
              },
              ResponseContentLanguage: {
                location: "querystring",
                locationName: "response-content-language"
              },
              ResponseContentType: {
                location: "querystring",
                locationName: "response-content-type"
              },
              ResponseExpires: {
                location: "querystring",
                locationName: "response-expires",
                type: "timestamp",
                timestampFormat: "rfc822"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              PartNumber: {
                location: "querystring",
                locationName: "partNumber",
                type: "integer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ChecksumMode: {
                location: "header",
                locationName: "x-amz-checksum-mode"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Body: {
                streaming: true,
                type: "blob"
              },
              DeleteMarker: {
                location: "header",
                locationName: "x-amz-delete-marker",
                type: "boolean"
              },
              AcceptRanges: {
                location: "header",
                locationName: "accept-ranges"
              },
              Expiration: {
                location: "header",
                locationName: "x-amz-expiration"
              },
              Restore: {
                location: "header",
                locationName: "x-amz-restore"
              },
              LastModified: {
                location: "header",
                locationName: "Last-Modified",
                type: "timestamp"
              },
              ContentLength: {
                location: "header",
                locationName: "Content-Length",
                type: "long"
              },
              ETag: {
                location: "header",
                locationName: "ETag"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              MissingMeta: {
                location: "header",
                locationName: "x-amz-missing-meta",
                type: "integer"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              CacheControl: {
                location: "header",
                locationName: "Cache-Control"
              },
              ContentDisposition: {
                location: "header",
                locationName: "Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "Content-Language"
              },
              ContentRange: {
                location: "header",
                locationName: "Content-Range"
              },
              ContentType: {
                location: "header",
                locationName: "Content-Type"
              },
              Expires: {
                location: "header",
                locationName: "Expires",
                type: "timestamp"
              },
              WebsiteRedirectLocation: {
                location: "header",
                locationName: "x-amz-website-redirect-location"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-storage-class"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              ReplicationStatus: {
                location: "header",
                locationName: "x-amz-replication-status"
              },
              PartsCount: {
                location: "header",
                locationName: "x-amz-mp-parts-count",
                type: "integer"
              },
              TagCount: {
                location: "header",
                locationName: "x-amz-tagging-count",
                type: "integer"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-object-lock-mode"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-object-lock-retain-until-date"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-object-lock-legal-hold"
              }
            },
            payload: "Body"
          },
          httpChecksum: {
            requestValidationModeMember: "ChecksumMode",
            responseAlgorithms: [
              "CRC32",
              "CRC32C",
              "SHA256",
              "SHA1"
            ]
          }
        },
        GetObjectAcl: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?acl"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Owner: {
                shape: "S3d"
              },
              Grants: {
                shape: "S3g",
                locationName: "AccessControlList"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          }
        },
        GetObjectAttributes: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?attributes"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "ObjectAttributes"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              MaxParts: {
                location: "header",
                locationName: "x-amz-max-parts",
                type: "integer"
              },
              PartNumberMarker: {
                location: "header",
                locationName: "x-amz-part-number-marker",
                type: "integer"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ObjectAttributes: {
                location: "header",
                locationName: "x-amz-object-attributes",
                type: "list",
                member: {}
              }
            }
          },
          output: {
            type: "structure",
            members: {
              DeleteMarker: {
                location: "header",
                locationName: "x-amz-delete-marker",
                type: "boolean"
              },
              LastModified: {
                location: "header",
                locationName: "Last-Modified",
                type: "timestamp"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              ETag: {},
              Checksum: {
                type: "structure",
                members: {
                  ChecksumCRC32: {},
                  ChecksumCRC32C: {},
                  ChecksumSHA1: {},
                  ChecksumSHA256: {}
                }
              },
              ObjectParts: {
                type: "structure",
                members: {
                  TotalPartsCount: {
                    locationName: "PartsCount",
                    type: "integer"
                  },
                  PartNumberMarker: {
                    type: "integer"
                  },
                  NextPartNumberMarker: {
                    type: "integer"
                  },
                  MaxParts: {
                    type: "integer"
                  },
                  IsTruncated: {
                    type: "boolean"
                  },
                  Parts: {
                    locationName: "Part",
                    type: "list",
                    member: {
                      type: "structure",
                      members: {
                        PartNumber: {
                          type: "integer"
                        },
                        Size: {
                          type: "integer"
                        },
                        ChecksumCRC32: {},
                        ChecksumCRC32C: {},
                        ChecksumSHA1: {},
                        ChecksumSHA256: {}
                      }
                    },
                    flattened: true
                  }
                }
              },
              StorageClass: {},
              ObjectSize: {
                type: "long"
              }
            }
          }
        },
        GetObjectLegalHold: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?legal-hold"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              LegalHold: {
                shape: "Sa9"
              }
            },
            payload: "LegalHold"
          }
        },
        GetObjectLockConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?object-lock"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              ObjectLockConfiguration: {
                shape: "Sac"
              }
            },
            payload: "ObjectLockConfiguration"
          }
        },
        GetObjectRetention: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?retention"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Retention: {
                shape: "Sak"
              }
            },
            payload: "Retention"
          }
        },
        GetObjectTagging: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?tagging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              }
            }
          },
          output: {
            type: "structure",
            required: [
              "TagSet"
            ],
            members: {
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              TagSet: {
                shape: "S3v"
              }
            }
          }
        },
        GetObjectTorrent: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?torrent"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Body: {
                streaming: true,
                type: "blob"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            },
            payload: "Body"
          }
        },
        GetPublicAccessBlock: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?publicAccessBlock"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              PublicAccessBlockConfiguration: {
                shape: "Sar"
              }
            },
            payload: "PublicAccessBlockConfiguration"
          }
        },
        HeadBucket: {
          http: {
            method: "HEAD",
            requestUri: "/{Bucket}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          }
        },
        HeadObject: {
          http: {
            method: "HEAD",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              IfMatch: {
                location: "header",
                locationName: "If-Match"
              },
              IfModifiedSince: {
                location: "header",
                locationName: "If-Modified-Since",
                type: "timestamp"
              },
              IfNoneMatch: {
                location: "header",
                locationName: "If-None-Match"
              },
              IfUnmodifiedSince: {
                location: "header",
                locationName: "If-Unmodified-Since",
                type: "timestamp"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              Range: {
                location: "header",
                locationName: "Range"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              PartNumber: {
                location: "querystring",
                locationName: "partNumber",
                type: "integer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ChecksumMode: {
                location: "header",
                locationName: "x-amz-checksum-mode"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              DeleteMarker: {
                location: "header",
                locationName: "x-amz-delete-marker",
                type: "boolean"
              },
              AcceptRanges: {
                location: "header",
                locationName: "accept-ranges"
              },
              Expiration: {
                location: "header",
                locationName: "x-amz-expiration"
              },
              Restore: {
                location: "header",
                locationName: "x-amz-restore"
              },
              ArchiveStatus: {
                location: "header",
                locationName: "x-amz-archive-status"
              },
              LastModified: {
                location: "header",
                locationName: "Last-Modified",
                type: "timestamp"
              },
              ContentLength: {
                location: "header",
                locationName: "Content-Length",
                type: "long"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              ETag: {
                location: "header",
                locationName: "ETag"
              },
              MissingMeta: {
                location: "header",
                locationName: "x-amz-missing-meta",
                type: "integer"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              CacheControl: {
                location: "header",
                locationName: "Cache-Control"
              },
              ContentDisposition: {
                location: "header",
                locationName: "Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "Content-Language"
              },
              ContentType: {
                location: "header",
                locationName: "Content-Type"
              },
              Expires: {
                location: "header",
                locationName: "Expires",
                type: "timestamp"
              },
              WebsiteRedirectLocation: {
                location: "header",
                locationName: "x-amz-website-redirect-location"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-storage-class"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              ReplicationStatus: {
                location: "header",
                locationName: "x-amz-replication-status"
              },
              PartsCount: {
                location: "header",
                locationName: "x-amz-mp-parts-count",
                type: "integer"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-object-lock-mode"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-object-lock-retain-until-date"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-object-lock-legal-hold"
              }
            }
          }
        },
        ListBucketAnalyticsConfigurations: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?analytics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContinuationToken: {
                location: "querystring",
                locationName: "continuation-token"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              ContinuationToken: {},
              NextContinuationToken: {},
              AnalyticsConfigurationList: {
                locationName: "AnalyticsConfiguration",
                type: "list",
                member: {
                  shape: "S3p"
                },
                flattened: true
              }
            }
          }
        },
        ListBucketIntelligentTieringConfigurations: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?intelligent-tiering"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContinuationToken: {
                location: "querystring",
                locationName: "continuation-token"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              ContinuationToken: {},
              NextContinuationToken: {},
              IntelligentTieringConfigurationList: {
                locationName: "IntelligentTieringConfiguration",
                type: "list",
                member: {
                  shape: "S4n"
                },
                flattened: true
              }
            }
          }
        },
        ListBucketInventoryConfigurations: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?inventory"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContinuationToken: {
                location: "querystring",
                locationName: "continuation-token"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              ContinuationToken: {},
              InventoryConfigurationList: {
                locationName: "InventoryConfiguration",
                type: "list",
                member: {
                  shape: "S4x"
                },
                flattened: true
              },
              IsTruncated: {
                type: "boolean"
              },
              NextContinuationToken: {}
            }
          }
        },
        ListBucketMetricsConfigurations: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?metrics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContinuationToken: {
                location: "querystring",
                locationName: "continuation-token"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              ContinuationToken: {},
              NextContinuationToken: {},
              MetricsConfigurationList: {
                locationName: "MetricsConfiguration",
                type: "list",
                member: {
                  shape: "S6d"
                },
                flattened: true
              }
            }
          }
        },
        ListBuckets: {
          http: {
            method: "GET"
          },
          output: {
            type: "structure",
            members: {
              Buckets: {
                type: "list",
                member: {
                  locationName: "Bucket",
                  type: "structure",
                  members: {
                    Name: {},
                    CreationDate: {
                      type: "timestamp"
                    }
                  }
                }
              },
              Owner: {
                shape: "S3d"
              }
            }
          },
          alias: "GetService"
        },
        ListMultipartUploads: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?uploads"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Delimiter: {
                location: "querystring",
                locationName: "delimiter"
              },
              EncodingType: {
                location: "querystring",
                locationName: "encoding-type"
              },
              KeyMarker: {
                location: "querystring",
                locationName: "key-marker"
              },
              MaxUploads: {
                location: "querystring",
                locationName: "max-uploads",
                type: "integer"
              },
              Prefix: {
                location: "querystring",
                locationName: "prefix"
              },
              UploadIdMarker: {
                location: "querystring",
                locationName: "upload-id-marker"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Bucket: {},
              KeyMarker: {},
              UploadIdMarker: {},
              NextKeyMarker: {},
              Prefix: {},
              Delimiter: {},
              NextUploadIdMarker: {},
              MaxUploads: {
                type: "integer"
              },
              IsTruncated: {
                type: "boolean"
              },
              Uploads: {
                locationName: "Upload",
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    UploadId: {},
                    Key: {},
                    Initiated: {
                      type: "timestamp"
                    },
                    StorageClass: {},
                    Owner: {
                      shape: "S3d"
                    },
                    Initiator: {
                      shape: "Sbr"
                    },
                    ChecksumAlgorithm: {}
                  }
                },
                flattened: true
              },
              CommonPrefixes: {
                shape: "Sbs"
              },
              EncodingType: {}
            }
          }
        },
        ListObjectVersions: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?versions"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Delimiter: {
                location: "querystring",
                locationName: "delimiter"
              },
              EncodingType: {
                location: "querystring",
                locationName: "encoding-type"
              },
              KeyMarker: {
                location: "querystring",
                locationName: "key-marker"
              },
              MaxKeys: {
                location: "querystring",
                locationName: "max-keys",
                type: "integer"
              },
              Prefix: {
                location: "querystring",
                locationName: "prefix"
              },
              VersionIdMarker: {
                location: "querystring",
                locationName: "version-id-marker"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              KeyMarker: {},
              VersionIdMarker: {},
              NextKeyMarker: {},
              NextVersionIdMarker: {},
              Versions: {
                locationName: "Version",
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    ETag: {},
                    ChecksumAlgorithm: {
                      shape: "Sc1"
                    },
                    Size: {
                      type: "integer"
                    },
                    StorageClass: {},
                    Key: {},
                    VersionId: {},
                    IsLatest: {
                      type: "boolean"
                    },
                    LastModified: {
                      type: "timestamp"
                    },
                    Owner: {
                      shape: "S3d"
                    }
                  }
                },
                flattened: true
              },
              DeleteMarkers: {
                locationName: "DeleteMarker",
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    Owner: {
                      shape: "S3d"
                    },
                    Key: {},
                    VersionId: {},
                    IsLatest: {
                      type: "boolean"
                    },
                    LastModified: {
                      type: "timestamp"
                    }
                  }
                },
                flattened: true
              },
              Name: {},
              Prefix: {},
              Delimiter: {},
              MaxKeys: {
                type: "integer"
              },
              CommonPrefixes: {
                shape: "Sbs"
              },
              EncodingType: {}
            }
          },
          alias: "GetBucketObjectVersions"
        },
        ListObjects: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Delimiter: {
                location: "querystring",
                locationName: "delimiter"
              },
              EncodingType: {
                location: "querystring",
                locationName: "encoding-type"
              },
              Marker: {
                location: "querystring",
                locationName: "marker"
              },
              MaxKeys: {
                location: "querystring",
                locationName: "max-keys",
                type: "integer"
              },
              Prefix: {
                location: "querystring",
                locationName: "prefix"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              Marker: {},
              NextMarker: {},
              Contents: {
                shape: "Sca"
              },
              Name: {},
              Prefix: {},
              Delimiter: {},
              MaxKeys: {
                type: "integer"
              },
              CommonPrefixes: {
                shape: "Sbs"
              },
              EncodingType: {}
            }
          },
          alias: "GetBucket"
        },
        ListObjectsV2: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?list-type=2"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Delimiter: {
                location: "querystring",
                locationName: "delimiter"
              },
              EncodingType: {
                location: "querystring",
                locationName: "encoding-type"
              },
              MaxKeys: {
                location: "querystring",
                locationName: "max-keys",
                type: "integer"
              },
              Prefix: {
                location: "querystring",
                locationName: "prefix"
              },
              ContinuationToken: {
                location: "querystring",
                locationName: "continuation-token"
              },
              FetchOwner: {
                location: "querystring",
                locationName: "fetch-owner",
                type: "boolean"
              },
              StartAfter: {
                location: "querystring",
                locationName: "start-after"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              Contents: {
                shape: "Sca"
              },
              Name: {},
              Prefix: {},
              Delimiter: {},
              MaxKeys: {
                type: "integer"
              },
              CommonPrefixes: {
                shape: "Sbs"
              },
              EncodingType: {},
              KeyCount: {
                type: "integer"
              },
              ContinuationToken: {},
              NextContinuationToken: {},
              StartAfter: {}
            }
          }
        },
        ListParts: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "UploadId"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              MaxParts: {
                location: "querystring",
                locationName: "max-parts",
                type: "integer"
              },
              PartNumberMarker: {
                location: "querystring",
                locationName: "part-number-marker",
                type: "integer"
              },
              UploadId: {
                location: "querystring",
                locationName: "uploadId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              AbortDate: {
                location: "header",
                locationName: "x-amz-abort-date",
                type: "timestamp"
              },
              AbortRuleId: {
                location: "header",
                locationName: "x-amz-abort-rule-id"
              },
              Bucket: {},
              Key: {},
              UploadId: {},
              PartNumberMarker: {
                type: "integer"
              },
              NextPartNumberMarker: {
                type: "integer"
              },
              MaxParts: {
                type: "integer"
              },
              IsTruncated: {
                type: "boolean"
              },
              Parts: {
                locationName: "Part",
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    PartNumber: {
                      type: "integer"
                    },
                    LastModified: {
                      type: "timestamp"
                    },
                    ETag: {},
                    Size: {
                      type: "integer"
                    },
                    ChecksumCRC32: {},
                    ChecksumCRC32C: {},
                    ChecksumSHA1: {},
                    ChecksumSHA256: {}
                  }
                },
                flattened: true
              },
              Initiator: {
                shape: "Sbr"
              },
              Owner: {
                shape: "S3d"
              },
              StorageClass: {},
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              ChecksumAlgorithm: {}
            }
          }
        },
        PutBucketAccelerateConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?accelerate"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "AccelerateConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              AccelerateConfiguration: {
                locationName: "AccelerateConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  Status: {}
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              }
            },
            payload: "AccelerateConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false
          }
        },
        PutBucketAcl: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?acl"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              AccessControlPolicy: {
                shape: "Scp",
                locationName: "AccessControlPolicy",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWrite: {
                location: "header",
                locationName: "x-amz-grant-write"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "AccessControlPolicy"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketAnalyticsConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?analytics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id",
              "AnalyticsConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              AnalyticsConfiguration: {
                shape: "S3p",
                locationName: "AnalyticsConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "AnalyticsConfiguration"
          }
        },
        PutBucketCors: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?cors"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "CORSConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              CORSConfiguration: {
                locationName: "CORSConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                required: [
                  "CORSRules"
                ],
                members: {
                  CORSRules: {
                    shape: "S44",
                    locationName: "CORSRule"
                  }
                }
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "CORSConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketEncryption: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?encryption"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "ServerSideEncryptionConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ServerSideEncryptionConfiguration: {
                shape: "S4h",
                locationName: "ServerSideEncryptionConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "ServerSideEncryptionConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketIntelligentTieringConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?intelligent-tiering"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id",
              "IntelligentTieringConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              IntelligentTieringConfiguration: {
                shape: "S4n",
                locationName: "IntelligentTieringConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              }
            },
            payload: "IntelligentTieringConfiguration"
          }
        },
        PutBucketInventoryConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?inventory"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id",
              "InventoryConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              InventoryConfiguration: {
                shape: "S4x",
                locationName: "InventoryConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "InventoryConfiguration"
          }
        },
        PutBucketLifecycle: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?lifecycle"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              LifecycleConfiguration: {
                locationName: "LifecycleConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                required: [
                  "Rules"
                ],
                members: {
                  Rules: {
                    shape: "S5d",
                    locationName: "Rule"
                  }
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "LifecycleConfiguration"
          },
          deprecated: true,
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketLifecycleConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?lifecycle"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              LifecycleConfiguration: {
                locationName: "LifecycleConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                required: [
                  "Rules"
                ],
                members: {
                  Rules: {
                    shape: "S5t",
                    locationName: "Rule"
                  }
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "LifecycleConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketLogging: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?logging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "BucketLoggingStatus"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              BucketLoggingStatus: {
                locationName: "BucketLoggingStatus",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  LoggingEnabled: {
                    shape: "S65"
                  }
                }
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "BucketLoggingStatus"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketMetricsConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?metrics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id",
              "MetricsConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              MetricsConfiguration: {
                shape: "S6d",
                locationName: "MetricsConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "MetricsConfiguration"
          }
        },
        PutBucketNotification: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?notification"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "NotificationConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              NotificationConfiguration: {
                shape: "S6i",
                locationName: "NotificationConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "NotificationConfiguration"
          },
          deprecated: true,
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketNotificationConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?notification"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "NotificationConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              NotificationConfiguration: {
                shape: "S6t",
                locationName: "NotificationConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              SkipDestinationValidation: {
                location: "header",
                locationName: "x-amz-skip-destination-validation",
                type: "boolean"
              }
            },
            payload: "NotificationConfiguration"
          }
        },
        PutBucketOwnershipControls: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?ownershipControls"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "OwnershipControls"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              OwnershipControls: {
                shape: "S7a",
                locationName: "OwnershipControls",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              }
            },
            payload: "OwnershipControls"
          },
          httpChecksum: {
            requestChecksumRequired: true
          }
        },
        PutBucketPolicy: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?policy"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Policy"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ConfirmRemoveSelfBucketAccess: {
                location: "header",
                locationName: "x-amz-confirm-remove-self-bucket-access",
                type: "boolean"
              },
              Policy: {},
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "Policy"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketReplication: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?replication"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "ReplicationConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ReplicationConfiguration: {
                shape: "S7m",
                locationName: "ReplicationConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              Token: {
                location: "header",
                locationName: "x-amz-bucket-object-lock-token"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "ReplicationConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketRequestPayment: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?requestPayment"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "RequestPaymentConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              RequestPaymentConfiguration: {
                locationName: "RequestPaymentConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                required: [
                  "Payer"
                ],
                members: {
                  Payer: {}
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "RequestPaymentConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketTagging: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?tagging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Tagging"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              Tagging: {
                shape: "Sdf",
                locationName: "Tagging",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "Tagging"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketVersioning: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?versioning"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "VersioningConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              MFA: {
                location: "header",
                locationName: "x-amz-mfa"
              },
              VersioningConfiguration: {
                locationName: "VersioningConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  MFADelete: {
                    locationName: "MfaDelete"
                  },
                  Status: {}
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "VersioningConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutBucketWebsite: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?website"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "WebsiteConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              WebsiteConfiguration: {
                locationName: "WebsiteConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  ErrorDocument: {
                    shape: "S8u"
                  },
                  IndexDocument: {
                    shape: "S8s"
                  },
                  RedirectAllRequestsTo: {
                    shape: "S8p"
                  },
                  RoutingRules: {
                    shape: "S8v"
                  }
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "WebsiteConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutObject: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              Body: {
                streaming: true,
                type: "blob"
              },
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              CacheControl: {
                location: "header",
                locationName: "Cache-Control"
              },
              ContentDisposition: {
                location: "header",
                locationName: "Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "Content-Language"
              },
              ContentLength: {
                location: "header",
                locationName: "Content-Length",
                type: "long"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ContentType: {
                location: "header",
                locationName: "Content-Type"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              Expires: {
                location: "header",
                locationName: "Expires",
                type: "timestamp"
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-storage-class"
              },
              WebsiteRedirectLocation: {
                location: "header",
                locationName: "x-amz-website-redirect-location"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              Tagging: {
                location: "header",
                locationName: "x-amz-tagging"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-object-lock-mode"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-object-lock-retain-until-date"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-object-lock-legal-hold"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "Body"
          },
          output: {
            type: "structure",
            members: {
              Expiration: {
                location: "header",
                locationName: "x-amz-expiration"
              },
              ETag: {
                location: "header",
                locationName: "ETag"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false
          }
        },
        PutObjectAcl: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}?acl"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              AccessControlPolicy: {
                shape: "Scp",
                locationName: "AccessControlPolicy",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWrite: {
                location: "header",
                locationName: "x-amz-grant-write"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "AccessControlPolicy"
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutObjectLegalHold: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}?legal-hold"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              LegalHold: {
                shape: "Sa9",
                locationName: "LegalHold",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "LegalHold"
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutObjectLockConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?object-lock"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ObjectLockConfiguration: {
                shape: "Sac",
                locationName: "ObjectLockConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              Token: {
                location: "header",
                locationName: "x-amz-bucket-object-lock-token"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "ObjectLockConfiguration"
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutObjectRetention: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}?retention"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              Retention: {
                shape: "Sak",
                locationName: "Retention",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              BypassGovernanceRetention: {
                location: "header",
                locationName: "x-amz-bypass-governance-retention",
                type: "boolean"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "Retention"
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutObjectTagging: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}?tagging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "Tagging"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              Tagging: {
                shape: "Sdf",
                locationName: "Tagging",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              }
            },
            payload: "Tagging"
          },
          output: {
            type: "structure",
            members: {
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutPublicAccessBlock: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?publicAccessBlock"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "PublicAccessBlockConfiguration"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              PublicAccessBlockConfiguration: {
                shape: "Sar",
                locationName: "PublicAccessBlockConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "PublicAccessBlockConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        RestoreObject: {
          http: {
            requestUri: "/{Bucket}/{Key+}?restore"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              RestoreRequest: {
                locationName: "RestoreRequest",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  Days: {
                    type: "integer"
                  },
                  GlacierJobParameters: {
                    type: "structure",
                    required: [
                      "Tier"
                    ],
                    members: {
                      Tier: {}
                    }
                  },
                  Type: {},
                  Tier: {},
                  Description: {},
                  SelectParameters: {
                    type: "structure",
                    required: [
                      "InputSerialization",
                      "ExpressionType",
                      "Expression",
                      "OutputSerialization"
                    ],
                    members: {
                      InputSerialization: {
                        shape: "Se5"
                      },
                      ExpressionType: {},
                      Expression: {},
                      OutputSerialization: {
                        shape: "Sek"
                      }
                    }
                  },
                  OutputLocation: {
                    type: "structure",
                    members: {
                      S3: {
                        type: "structure",
                        required: [
                          "BucketName",
                          "Prefix"
                        ],
                        members: {
                          BucketName: {},
                          Prefix: {},
                          Encryption: {
                            type: "structure",
                            required: [
                              "EncryptionType"
                            ],
                            members: {
                              EncryptionType: {},
                              KMSKeyId: {
                                shape: "Sr"
                              },
                              KMSContext: {}
                            }
                          },
                          CannedACL: {},
                          AccessControlList: {
                            shape: "S3g"
                          },
                          Tagging: {
                            shape: "Sdf"
                          },
                          UserMetadata: {
                            type: "list",
                            member: {
                              locationName: "MetadataEntry",
                              type: "structure",
                              members: {
                                Name: {},
                                Value: {}
                              }
                            }
                          },
                          StorageClass: {}
                        }
                      }
                    }
                  }
                }
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "RestoreRequest"
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              RestoreOutputPath: {
                location: "header",
                locationName: "x-amz-restore-output-path"
              }
            }
          },
          alias: "PostObjectRestore",
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false
          }
        },
        SelectObjectContent: {
          http: {
            requestUri: "/{Bucket}/{Key+}?select&select-type=2"
          },
          input: {
            locationName: "SelectObjectContentRequest",
            xmlNamespace: {
              uri: "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "Expression",
              "ExpressionType",
              "InputSerialization",
              "OutputSerialization"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              Expression: {},
              ExpressionType: {},
              RequestProgress: {
                type: "structure",
                members: {
                  Enabled: {
                    type: "boolean"
                  }
                }
              },
              InputSerialization: {
                shape: "Se5"
              },
              OutputSerialization: {
                shape: "Sek"
              },
              ScanRange: {
                type: "structure",
                members: {
                  Start: {
                    type: "long"
                  },
                  End: {
                    type: "long"
                  }
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Payload: {
                type: "structure",
                members: {
                  Records: {
                    type: "structure",
                    members: {
                      Payload: {
                        eventpayload: true,
                        type: "blob"
                      }
                    },
                    event: true
                  },
                  Stats: {
                    type: "structure",
                    members: {
                      Details: {
                        eventpayload: true,
                        type: "structure",
                        members: {
                          BytesScanned: {
                            type: "long"
                          },
                          BytesProcessed: {
                            type: "long"
                          },
                          BytesReturned: {
                            type: "long"
                          }
                        }
                      }
                    },
                    event: true
                  },
                  Progress: {
                    type: "structure",
                    members: {
                      Details: {
                        eventpayload: true,
                        type: "structure",
                        members: {
                          BytesScanned: {
                            type: "long"
                          },
                          BytesProcessed: {
                            type: "long"
                          },
                          BytesReturned: {
                            type: "long"
                          }
                        }
                      }
                    },
                    event: true
                  },
                  Cont: {
                    type: "structure",
                    members: {},
                    event: true
                  },
                  End: {
                    type: "structure",
                    members: {},
                    event: true
                  }
                },
                eventstream: true
              }
            },
            payload: "Payload"
          }
        },
        UploadPart: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "PartNumber",
              "UploadId"
            ],
            members: {
              Body: {
                streaming: true,
                type: "blob"
              },
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              ContentLength: {
                location: "header",
                locationName: "Content-Length",
                type: "long"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              PartNumber: {
                location: "querystring",
                locationName: "partNumber",
                type: "integer"
              },
              UploadId: {
                location: "querystring",
                locationName: "uploadId"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "Body"
          },
          output: {
            type: "structure",
            members: {
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              ETag: {
                location: "header",
                locationName: "ETag"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false
          }
        },
        UploadPartCopy: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "CopySource",
              "Key",
              "PartNumber",
              "UploadId"
            ],
            members: {
              Bucket: {
                location: "uri",
                locationName: "Bucket"
              },
              CopySource: {
                location: "header",
                locationName: "x-amz-copy-source"
              },
              CopySourceIfMatch: {
                location: "header",
                locationName: "x-amz-copy-source-if-match"
              },
              CopySourceIfModifiedSince: {
                location: "header",
                locationName: "x-amz-copy-source-if-modified-since",
                type: "timestamp"
              },
              CopySourceIfNoneMatch: {
                location: "header",
                locationName: "x-amz-copy-source-if-none-match"
              },
              CopySourceIfUnmodifiedSince: {
                location: "header",
                locationName: "x-amz-copy-source-if-unmodified-since",
                type: "timestamp"
              },
              CopySourceRange: {
                location: "header",
                locationName: "x-amz-copy-source-range"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              PartNumber: {
                location: "querystring",
                locationName: "partNumber",
                type: "integer"
              },
              UploadId: {
                location: "querystring",
                locationName: "uploadId"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              CopySourceSSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-algorithm"
              },
              CopySourceSSECustomerKey: {
                shape: "S1k",
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-key"
              },
              CopySourceSSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ExpectedSourceBucketOwner: {
                location: "header",
                locationName: "x-amz-source-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              CopySourceVersionId: {
                location: "header",
                locationName: "x-amz-copy-source-version-id"
              },
              CopyPartResult: {
                type: "structure",
                members: {
                  ETag: {},
                  LastModified: {
                    type: "timestamp"
                  },
                  ChecksumCRC32: {},
                  ChecksumCRC32C: {},
                  ChecksumSHA1: {},
                  ChecksumSHA256: {}
                }
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            },
            payload: "CopyPartResult"
          }
        },
        WriteGetObjectResponse: {
          http: {
            requestUri: "/WriteGetObjectResponse"
          },
          input: {
            type: "structure",
            required: [
              "RequestRoute",
              "RequestToken"
            ],
            members: {
              RequestRoute: {
                hostLabel: true,
                location: "header",
                locationName: "x-amz-request-route"
              },
              RequestToken: {
                location: "header",
                locationName: "x-amz-request-token"
              },
              Body: {
                streaming: true,
                type: "blob"
              },
              StatusCode: {
                location: "header",
                locationName: "x-amz-fwd-status",
                type: "integer"
              },
              ErrorCode: {
                location: "header",
                locationName: "x-amz-fwd-error-code"
              },
              ErrorMessage: {
                location: "header",
                locationName: "x-amz-fwd-error-message"
              },
              AcceptRanges: {
                location: "header",
                locationName: "x-amz-fwd-header-accept-ranges"
              },
              CacheControl: {
                location: "header",
                locationName: "x-amz-fwd-header-Cache-Control"
              },
              ContentDisposition: {
                location: "header",
                locationName: "x-amz-fwd-header-Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "x-amz-fwd-header-Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "x-amz-fwd-header-Content-Language"
              },
              ContentLength: {
                location: "header",
                locationName: "Content-Length",
                type: "long"
              },
              ContentRange: {
                location: "header",
                locationName: "x-amz-fwd-header-Content-Range"
              },
              ContentType: {
                location: "header",
                locationName: "x-amz-fwd-header-Content-Type"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-checksum-sha256"
              },
              DeleteMarker: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-delete-marker",
                type: "boolean"
              },
              ETag: {
                location: "header",
                locationName: "x-amz-fwd-header-ETag"
              },
              Expires: {
                location: "header",
                locationName: "x-amz-fwd-header-Expires",
                type: "timestamp"
              },
              Expiration: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-expiration"
              },
              LastModified: {
                location: "header",
                locationName: "x-amz-fwd-header-Last-Modified",
                type: "timestamp"
              },
              MissingMeta: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-missing-meta",
                type: "integer"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-object-lock-mode"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-object-lock-legal-hold"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-object-lock-retain-until-date"
              },
              PartsCount: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-mp-parts-count",
                type: "integer"
              },
              ReplicationStatus: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-replication-status"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-request-charged"
              },
              Restore: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-restore"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-server-side-encryption"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-storage-class"
              },
              TagCount: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-tagging-count",
                type: "integer"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-version-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              }
            },
            payload: "Body"
          },
          authtype: "v4-unsigned-body",
          endpoint: {
            hostPrefix: "{RequestRoute}."
          }
        }
      },
      shapes: {
        Sk: {
          type: "blob",
          sensitive: true
        },
        Sr: {
          type: "string",
          sensitive: true
        },
        S1b: {
          type: "map",
          key: {},
          value: {}
        },
        S1i: {
          type: "string",
          sensitive: true
        },
        S1k: {
          type: "blob",
          sensitive: true
        },
        S1o: {
          type: "timestamp",
          timestampFormat: "iso8601"
        },
        S3d: {
          type: "structure",
          members: {
            DisplayName: {},
            ID: {}
          }
        },
        S3g: {
          type: "list",
          member: {
            locationName: "Grant",
            type: "structure",
            members: {
              Grantee: {
                shape: "S3i"
              },
              Permission: {}
            }
          }
        },
        S3i: {
          type: "structure",
          required: [
            "Type"
          ],
          members: {
            DisplayName: {},
            EmailAddress: {},
            ID: {},
            Type: {
              locationName: "xsi:type",
              xmlAttribute: true
            },
            URI: {}
          },
          xmlNamespace: {
            prefix: "xsi",
            uri: "http://www.w3.org/2001/XMLSchema-instance"
          }
        },
        S3p: {
          type: "structure",
          required: [
            "Id",
            "StorageClassAnalysis"
          ],
          members: {
            Id: {},
            Filter: {
              type: "structure",
              members: {
                Prefix: {},
                Tag: {
                  shape: "S3s"
                },
                And: {
                  type: "structure",
                  members: {
                    Prefix: {},
                    Tags: {
                      shape: "S3v",
                      flattened: true,
                      locationName: "Tag"
                    }
                  }
                }
              }
            },
            StorageClassAnalysis: {
              type: "structure",
              members: {
                DataExport: {
                  type: "structure",
                  required: [
                    "OutputSchemaVersion",
                    "Destination"
                  ],
                  members: {
                    OutputSchemaVersion: {},
                    Destination: {
                      type: "structure",
                      required: [
                        "S3BucketDestination"
                      ],
                      members: {
                        S3BucketDestination: {
                          type: "structure",
                          required: [
                            "Format",
                            "Bucket"
                          ],
                          members: {
                            Format: {},
                            BucketAccountId: {},
                            Bucket: {},
                            Prefix: {}
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        S3s: {
          type: "structure",
          required: [
            "Key",
            "Value"
          ],
          members: {
            Key: {},
            Value: {}
          }
        },
        S3v: {
          type: "list",
          member: {
            shape: "S3s",
            locationName: "Tag"
          }
        },
        S44: {
          type: "list",
          member: {
            type: "structure",
            required: [
              "AllowedMethods",
              "AllowedOrigins"
            ],
            members: {
              ID: {},
              AllowedHeaders: {
                locationName: "AllowedHeader",
                type: "list",
                member: {},
                flattened: true
              },
              AllowedMethods: {
                locationName: "AllowedMethod",
                type: "list",
                member: {},
                flattened: true
              },
              AllowedOrigins: {
                locationName: "AllowedOrigin",
                type: "list",
                member: {},
                flattened: true
              },
              ExposeHeaders: {
                locationName: "ExposeHeader",
                type: "list",
                member: {},
                flattened: true
              },
              MaxAgeSeconds: {
                type: "integer"
              }
            }
          },
          flattened: true
        },
        S4h: {
          type: "structure",
          required: [
            "Rules"
          ],
          members: {
            Rules: {
              locationName: "Rule",
              type: "list",
              member: {
                type: "structure",
                members: {
                  ApplyServerSideEncryptionByDefault: {
                    type: "structure",
                    required: [
                      "SSEAlgorithm"
                    ],
                    members: {
                      SSEAlgorithm: {},
                      KMSMasterKeyID: {
                        shape: "Sr"
                      }
                    }
                  },
                  BucketKeyEnabled: {
                    type: "boolean"
                  }
                }
              },
              flattened: true
            }
          }
        },
        S4n: {
          type: "structure",
          required: [
            "Id",
            "Status",
            "Tierings"
          ],
          members: {
            Id: {},
            Filter: {
              type: "structure",
              members: {
                Prefix: {},
                Tag: {
                  shape: "S3s"
                },
                And: {
                  type: "structure",
                  members: {
                    Prefix: {},
                    Tags: {
                      shape: "S3v",
                      flattened: true,
                      locationName: "Tag"
                    }
                  }
                }
              }
            },
            Status: {},
            Tierings: {
              locationName: "Tiering",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "Days",
                  "AccessTier"
                ],
                members: {
                  Days: {
                    type: "integer"
                  },
                  AccessTier: {}
                }
              },
              flattened: true
            }
          }
        },
        S4x: {
          type: "structure",
          required: [
            "Destination",
            "IsEnabled",
            "Id",
            "IncludedObjectVersions",
            "Schedule"
          ],
          members: {
            Destination: {
              type: "structure",
              required: [
                "S3BucketDestination"
              ],
              members: {
                S3BucketDestination: {
                  type: "structure",
                  required: [
                    "Bucket",
                    "Format"
                  ],
                  members: {
                    AccountId: {},
                    Bucket: {},
                    Format: {},
                    Prefix: {},
                    Encryption: {
                      type: "structure",
                      members: {
                        SSES3: {
                          locationName: "SSE-S3",
                          type: "structure",
                          members: {}
                        },
                        SSEKMS: {
                          locationName: "SSE-KMS",
                          type: "structure",
                          required: [
                            "KeyId"
                          ],
                          members: {
                            KeyId: {
                              shape: "Sr"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            IsEnabled: {
              type: "boolean"
            },
            Filter: {
              type: "structure",
              required: [
                "Prefix"
              ],
              members: {
                Prefix: {}
              }
            },
            Id: {},
            IncludedObjectVersions: {},
            OptionalFields: {
              type: "list",
              member: {
                locationName: "Field"
              }
            },
            Schedule: {
              type: "structure",
              required: [
                "Frequency"
              ],
              members: {
                Frequency: {}
              }
            }
          }
        },
        S5d: {
          type: "list",
          member: {
            type: "structure",
            required: [
              "Prefix",
              "Status"
            ],
            members: {
              Expiration: {
                shape: "S5f"
              },
              ID: {},
              Prefix: {},
              Status: {},
              Transition: {
                shape: "S5k"
              },
              NoncurrentVersionTransition: {
                shape: "S5m"
              },
              NoncurrentVersionExpiration: {
                shape: "S5o"
              },
              AbortIncompleteMultipartUpload: {
                shape: "S5p"
              }
            }
          },
          flattened: true
        },
        S5f: {
          type: "structure",
          members: {
            Date: {
              shape: "S5g"
            },
            Days: {
              type: "integer"
            },
            ExpiredObjectDeleteMarker: {
              type: "boolean"
            }
          }
        },
        S5g: {
          type: "timestamp",
          timestampFormat: "iso8601"
        },
        S5k: {
          type: "structure",
          members: {
            Date: {
              shape: "S5g"
            },
            Days: {
              type: "integer"
            },
            StorageClass: {}
          }
        },
        S5m: {
          type: "structure",
          members: {
            NoncurrentDays: {
              type: "integer"
            },
            StorageClass: {},
            NewerNoncurrentVersions: {
              type: "integer"
            }
          }
        },
        S5o: {
          type: "structure",
          members: {
            NoncurrentDays: {
              type: "integer"
            },
            NewerNoncurrentVersions: {
              type: "integer"
            }
          }
        },
        S5p: {
          type: "structure",
          members: {
            DaysAfterInitiation: {
              type: "integer"
            }
          }
        },
        S5t: {
          type: "list",
          member: {
            type: "structure",
            required: [
              "Status"
            ],
            members: {
              Expiration: {
                shape: "S5f"
              },
              ID: {},
              Prefix: {
                deprecated: true
              },
              Filter: {
                type: "structure",
                members: {
                  Prefix: {},
                  Tag: {
                    shape: "S3s"
                  },
                  ObjectSizeGreaterThan: {
                    type: "long"
                  },
                  ObjectSizeLessThan: {
                    type: "long"
                  },
                  And: {
                    type: "structure",
                    members: {
                      Prefix: {},
                      Tags: {
                        shape: "S3v",
                        flattened: true,
                        locationName: "Tag"
                      },
                      ObjectSizeGreaterThan: {
                        type: "long"
                      },
                      ObjectSizeLessThan: {
                        type: "long"
                      }
                    }
                  }
                }
              },
              Status: {},
              Transitions: {
                locationName: "Transition",
                type: "list",
                member: {
                  shape: "S5k"
                },
                flattened: true
              },
              NoncurrentVersionTransitions: {
                locationName: "NoncurrentVersionTransition",
                type: "list",
                member: {
                  shape: "S5m"
                },
                flattened: true
              },
              NoncurrentVersionExpiration: {
                shape: "S5o"
              },
              AbortIncompleteMultipartUpload: {
                shape: "S5p"
              }
            }
          },
          flattened: true
        },
        S65: {
          type: "structure",
          required: [
            "TargetBucket",
            "TargetPrefix"
          ],
          members: {
            TargetBucket: {},
            TargetGrants: {
              type: "list",
              member: {
                locationName: "Grant",
                type: "structure",
                members: {
                  Grantee: {
                    shape: "S3i"
                  },
                  Permission: {}
                }
              }
            },
            TargetPrefix: {}
          }
        },
        S6d: {
          type: "structure",
          required: [
            "Id"
          ],
          members: {
            Id: {},
            Filter: {
              type: "structure",
              members: {
                Prefix: {},
                Tag: {
                  shape: "S3s"
                },
                AccessPointArn: {},
                And: {
                  type: "structure",
                  members: {
                    Prefix: {},
                    Tags: {
                      shape: "S3v",
                      flattened: true,
                      locationName: "Tag"
                    },
                    AccessPointArn: {}
                  }
                }
              }
            }
          }
        },
        S6h: {
          type: "structure",
          required: [
            "Bucket"
          ],
          members: {
            Bucket: {
              location: "uri",
              locationName: "Bucket"
            },
            ExpectedBucketOwner: {
              location: "header",
              locationName: "x-amz-expected-bucket-owner"
            }
          }
        },
        S6i: {
          type: "structure",
          members: {
            TopicConfiguration: {
              type: "structure",
              members: {
                Id: {},
                Events: {
                  shape: "S6l",
                  locationName: "Event"
                },
                Event: {
                  deprecated: true
                },
                Topic: {}
              }
            },
            QueueConfiguration: {
              type: "structure",
              members: {
                Id: {},
                Event: {
                  deprecated: true
                },
                Events: {
                  shape: "S6l",
                  locationName: "Event"
                },
                Queue: {}
              }
            },
            CloudFunctionConfiguration: {
              type: "structure",
              members: {
                Id: {},
                Event: {
                  deprecated: true
                },
                Events: {
                  shape: "S6l",
                  locationName: "Event"
                },
                CloudFunction: {},
                InvocationRole: {}
              }
            }
          }
        },
        S6l: {
          type: "list",
          member: {},
          flattened: true
        },
        S6t: {
          type: "structure",
          members: {
            TopicConfigurations: {
              locationName: "TopicConfiguration",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "TopicArn",
                  "Events"
                ],
                members: {
                  Id: {},
                  TopicArn: {
                    locationName: "Topic"
                  },
                  Events: {
                    shape: "S6l",
                    locationName: "Event"
                  },
                  Filter: {
                    shape: "S6w"
                  }
                }
              },
              flattened: true
            },
            QueueConfigurations: {
              locationName: "QueueConfiguration",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "QueueArn",
                  "Events"
                ],
                members: {
                  Id: {},
                  QueueArn: {
                    locationName: "Queue"
                  },
                  Events: {
                    shape: "S6l",
                    locationName: "Event"
                  },
                  Filter: {
                    shape: "S6w"
                  }
                }
              },
              flattened: true
            },
            LambdaFunctionConfigurations: {
              locationName: "CloudFunctionConfiguration",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "LambdaFunctionArn",
                  "Events"
                ],
                members: {
                  Id: {},
                  LambdaFunctionArn: {
                    locationName: "CloudFunction"
                  },
                  Events: {
                    shape: "S6l",
                    locationName: "Event"
                  },
                  Filter: {
                    shape: "S6w"
                  }
                }
              },
              flattened: true
            },
            EventBridgeConfiguration: {
              type: "structure",
              members: {}
            }
          }
        },
        S6w: {
          type: "structure",
          members: {
            Key: {
              locationName: "S3Key",
              type: "structure",
              members: {
                FilterRules: {
                  locationName: "FilterRule",
                  type: "list",
                  member: {
                    type: "structure",
                    members: {
                      Name: {},
                      Value: {}
                    }
                  },
                  flattened: true
                }
              }
            }
          }
        },
        S7a: {
          type: "structure",
          required: [
            "Rules"
          ],
          members: {
            Rules: {
              locationName: "Rule",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "ObjectOwnership"
                ],
                members: {
                  ObjectOwnership: {}
                }
              },
              flattened: true
            }
          }
        },
        S7m: {
          type: "structure",
          required: [
            "Role",
            "Rules"
          ],
          members: {
            Role: {},
            Rules: {
              locationName: "Rule",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "Status",
                  "Destination"
                ],
                members: {
                  ID: {},
                  Priority: {
                    type: "integer"
                  },
                  Prefix: {
                    deprecated: true
                  },
                  Filter: {
                    type: "structure",
                    members: {
                      Prefix: {},
                      Tag: {
                        shape: "S3s"
                      },
                      And: {
                        type: "structure",
                        members: {
                          Prefix: {},
                          Tags: {
                            shape: "S3v",
                            flattened: true,
                            locationName: "Tag"
                          }
                        }
                      }
                    }
                  },
                  Status: {},
                  SourceSelectionCriteria: {
                    type: "structure",
                    members: {
                      SseKmsEncryptedObjects: {
                        type: "structure",
                        required: [
                          "Status"
                        ],
                        members: {
                          Status: {}
                        }
                      },
                      ReplicaModifications: {
                        type: "structure",
                        required: [
                          "Status"
                        ],
                        members: {
                          Status: {}
                        }
                      }
                    }
                  },
                  ExistingObjectReplication: {
                    type: "structure",
                    required: [
                      "Status"
                    ],
                    members: {
                      Status: {}
                    }
                  },
                  Destination: {
                    type: "structure",
                    required: [
                      "Bucket"
                    ],
                    members: {
                      Bucket: {},
                      Account: {},
                      StorageClass: {},
                      AccessControlTranslation: {
                        type: "structure",
                        required: [
                          "Owner"
                        ],
                        members: {
                          Owner: {}
                        }
                      },
                      EncryptionConfiguration: {
                        type: "structure",
                        members: {
                          ReplicaKmsKeyID: {}
                        }
                      },
                      ReplicationTime: {
                        type: "structure",
                        required: [
                          "Status",
                          "Time"
                        ],
                        members: {
                          Status: {},
                          Time: {
                            shape: "S88"
                          }
                        }
                      },
                      Metrics: {
                        type: "structure",
                        required: [
                          "Status"
                        ],
                        members: {
                          Status: {},
                          EventThreshold: {
                            shape: "S88"
                          }
                        }
                      }
                    }
                  },
                  DeleteMarkerReplication: {
                    type: "structure",
                    members: {
                      Status: {}
                    }
                  }
                }
              },
              flattened: true
            }
          }
        },
        S88: {
          type: "structure",
          members: {
            Minutes: {
              type: "integer"
            }
          }
        },
        S8p: {
          type: "structure",
          required: [
            "HostName"
          ],
          members: {
            HostName: {},
            Protocol: {}
          }
        },
        S8s: {
          type: "structure",
          required: [
            "Suffix"
          ],
          members: {
            Suffix: {}
          }
        },
        S8u: {
          type: "structure",
          required: [
            "Key"
          ],
          members: {
            Key: {}
          }
        },
        S8v: {
          type: "list",
          member: {
            locationName: "RoutingRule",
            type: "structure",
            required: [
              "Redirect"
            ],
            members: {
              Condition: {
                type: "structure",
                members: {
                  HttpErrorCodeReturnedEquals: {},
                  KeyPrefixEquals: {}
                }
              },
              Redirect: {
                type: "structure",
                members: {
                  HostName: {},
                  HttpRedirectCode: {},
                  Protocol: {},
                  ReplaceKeyPrefixWith: {},
                  ReplaceKeyWith: {}
                }
              }
            }
          }
        },
        Sa9: {
          type: "structure",
          members: {
            Status: {}
          }
        },
        Sac: {
          type: "structure",
          members: {
            ObjectLockEnabled: {},
            Rule: {
              type: "structure",
              members: {
                DefaultRetention: {
                  type: "structure",
                  members: {
                    Mode: {},
                    Days: {
                      type: "integer"
                    },
                    Years: {
                      type: "integer"
                    }
                  }
                }
              }
            }
          }
        },
        Sak: {
          type: "structure",
          members: {
            Mode: {},
            RetainUntilDate: {
              shape: "S5g"
            }
          }
        },
        Sar: {
          type: "structure",
          members: {
            BlockPublicAcls: {
              locationName: "BlockPublicAcls",
              type: "boolean"
            },
            IgnorePublicAcls: {
              locationName: "IgnorePublicAcls",
              type: "boolean"
            },
            BlockPublicPolicy: {
              locationName: "BlockPublicPolicy",
              type: "boolean"
            },
            RestrictPublicBuckets: {
              locationName: "RestrictPublicBuckets",
              type: "boolean"
            }
          }
        },
        Sbr: {
          type: "structure",
          members: {
            ID: {},
            DisplayName: {}
          }
        },
        Sbs: {
          type: "list",
          member: {
            type: "structure",
            members: {
              Prefix: {}
            }
          },
          flattened: true
        },
        Sc1: {
          type: "list",
          member: {},
          flattened: true
        },
        Sca: {
          type: "list",
          member: {
            type: "structure",
            members: {
              Key: {},
              LastModified: {
                type: "timestamp"
              },
              ETag: {},
              ChecksumAlgorithm: {
                shape: "Sc1"
              },
              Size: {
                type: "integer"
              },
              StorageClass: {},
              Owner: {
                shape: "S3d"
              }
            }
          },
          flattened: true
        },
        Scp: {
          type: "structure",
          members: {
            Grants: {
              shape: "S3g",
              locationName: "AccessControlList"
            },
            Owner: {
              shape: "S3d"
            }
          }
        },
        Sdf: {
          type: "structure",
          required: [
            "TagSet"
          ],
          members: {
            TagSet: {
              shape: "S3v"
            }
          }
        },
        Se5: {
          type: "structure",
          members: {
            CSV: {
              type: "structure",
              members: {
                FileHeaderInfo: {},
                Comments: {},
                QuoteEscapeCharacter: {},
                RecordDelimiter: {},
                FieldDelimiter: {},
                QuoteCharacter: {},
                AllowQuotedRecordDelimiter: {
                  type: "boolean"
                }
              }
            },
            CompressionType: {},
            JSON: {
              type: "structure",
              members: {
                Type: {}
              }
            },
            Parquet: {
              type: "structure",
              members: {}
            }
          }
        },
        Sek: {
          type: "structure",
          members: {
            CSV: {
              type: "structure",
              members: {
                QuoteFields: {},
                QuoteEscapeCharacter: {},
                RecordDelimiter: {},
                FieldDelimiter: {},
                QuoteCharacter: {}
              }
            },
            JSON: {
              type: "structure",
              members: {
                RecordDelimiter: {}
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/aws-sdk/apis/s3-2006-03-01.paginators.json
var require_s3_2006_03_01_paginators = __commonJS({
  "node_modules/aws-sdk/apis/s3-2006-03-01.paginators.json"(exports, module2) {
    module2.exports = {
      pagination: {
        ListBuckets: {
          result_key: "Buckets"
        },
        ListMultipartUploads: {
          input_token: [
            "KeyMarker",
            "UploadIdMarker"
          ],
          limit_key: "MaxUploads",
          more_results: "IsTruncated",
          output_token: [
            "NextKeyMarker",
            "NextUploadIdMarker"
          ],
          result_key: [
            "Uploads",
            "CommonPrefixes"
          ]
        },
        ListObjectVersions: {
          input_token: [
            "KeyMarker",
            "VersionIdMarker"
          ],
          limit_key: "MaxKeys",
          more_results: "IsTruncated",
          output_token: [
            "NextKeyMarker",
            "NextVersionIdMarker"
          ],
          result_key: [
            "Versions",
            "DeleteMarkers",
            "CommonPrefixes"
          ]
        },
        ListObjects: {
          input_token: "Marker",
          limit_key: "MaxKeys",
          more_results: "IsTruncated",
          output_token: "NextMarker || Contents[-1].Key",
          result_key: [
            "Contents",
            "CommonPrefixes"
          ]
        },
        ListObjectsV2: {
          input_token: "ContinuationToken",
          limit_key: "MaxKeys",
          output_token: "NextContinuationToken",
          result_key: [
            "Contents",
            "CommonPrefixes"
          ]
        },
        ListParts: {
          input_token: "PartNumberMarker",
          limit_key: "MaxParts",
          more_results: "IsTruncated",
          output_token: "NextPartNumberMarker",
          result_key: "Parts"
        }
      }
    };
  }
});

// node_modules/aws-sdk/apis/s3-2006-03-01.waiters2.json
var require_s3_2006_03_01_waiters2 = __commonJS({
  "node_modules/aws-sdk/apis/s3-2006-03-01.waiters2.json"(exports, module2) {
    module2.exports = {
      version: 2,
      waiters: {
        BucketExists: {
          delay: 5,
          operation: "HeadBucket",
          maxAttempts: 20,
          acceptors: [
            {
              expected: 200,
              matcher: "status",
              state: "success"
            },
            {
              expected: 301,
              matcher: "status",
              state: "success"
            },
            {
              expected: 403,
              matcher: "status",
              state: "success"
            },
            {
              expected: 404,
              matcher: "status",
              state: "retry"
            }
          ]
        },
        BucketNotExists: {
          delay: 5,
          operation: "HeadBucket",
          maxAttempts: 20,
          acceptors: [
            {
              expected: 404,
              matcher: "status",
              state: "success"
            }
          ]
        },
        ObjectExists: {
          delay: 5,
          operation: "HeadObject",
          maxAttempts: 20,
          acceptors: [
            {
              expected: 200,
              matcher: "status",
              state: "success"
            },
            {
              expected: 404,
              matcher: "status",
              state: "retry"
            }
          ]
        },
        ObjectNotExists: {
          delay: 5,
          operation: "HeadObject",
          maxAttempts: 20,
          acceptors: [
            {
              expected: 404,
              matcher: "status",
              state: "success"
            }
          ]
        }
      }
    };
  }
});

// node_modules/aws-sdk/clients/s3.js
var require_s33 = __commonJS({
  "node_modules/aws-sdk/clients/s3.js"(exports, module2) {
    require_node_loader();
    var AWS2 = require_core2();
    var Service = AWS2.Service;
    var apiLoader = AWS2.apiLoader;
    apiLoader.services["s3"] = {};
    AWS2.S3 = Service.defineService("s3", ["2006-03-01"]);
    require_s32();
    Object.defineProperty(apiLoader.services["s3"], "2006-03-01", {
      get: function get() {
        var model = require_s3_2006_03_01_min();
        model.paginators = require_s3_2006_03_01_paginators().pagination;
        model.waiters = require_s3_2006_03_01_waiters2().waiters;
        return model;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = AWS2.S3;
  }
});

// node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS({
  "node_modules/@actions/exec/lib/toolrunner.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var os = __importStar(require("os"));
    var events = __importStar(require("events"));
    var child = __importStar(require("child_process"));
    var path8 = __importStar(require("path"));
    var io5 = __importStar(require_io());
    var ioUtil = __importStar(require_io_util());
    var IS_WINDOWS = process.platform === "win32";
    var ToolRunner = class extends events.EventEmitter {
      constructor(toolPath, args, options) {
        super();
        if (!toolPath) {
          throw new Error("Parameter 'toolPath' cannot be null or empty.");
        }
        this.toolPath = toolPath;
        this.args = args || [];
        this.options = options || {};
      }
      _debug(message) {
        if (this.options.listeners && this.options.listeners.debug) {
          this.options.listeners.debug(message);
        }
      }
      _getCommandString(options, noPrefix) {
        const toolPath = this._getSpawnFileName();
        const args = this._getSpawnArgs(options);
        let cmd = noPrefix ? "" : "[command]";
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            cmd += toolPath;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else if (options.windowsVerbatimArguments) {
            cmd += `"${toolPath}"`;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else {
            cmd += this._windowsQuoteCmdArg(toolPath);
            for (const a of args) {
              cmd += ` ${this._windowsQuoteCmdArg(a)}`;
            }
          }
        } else {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        }
        return cmd;
      }
      _processLineBuffer(data, strBuffer, onLine) {
        try {
          let s2 = strBuffer + data.toString();
          let n = s2.indexOf(os.EOL);
          while (n > -1) {
            const line = s2.substring(0, n);
            onLine(line);
            s2 = s2.substring(n + os.EOL.length);
            n = s2.indexOf(os.EOL);
          }
          strBuffer = s2;
        } catch (err) {
          this._debug(`error processing line. Failed with error ${err}`);
        }
      }
      _getSpawnFileName() {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            return process.env["COMSPEC"] || "cmd.exe";
          }
        }
        return this.toolPath;
      }
      _getSpawnArgs(options) {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
            for (const a of this.args) {
              argline += " ";
              argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
            }
            argline += '"';
            return [argline];
          }
        }
        return this.args;
      }
      _endsWith(str, end) {
        return str.endsWith(end);
      }
      _isCmdFile() {
        const upperToolPath = this.toolPath.toUpperCase();
        return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
      }
      _windowsQuoteCmdArg(arg) {
        if (!this._isCmdFile()) {
          return this._uvQuoteCmdArg(arg);
        }
        if (!arg) {
          return '""';
        }
        const cmdSpecialChars = [
          " ",
          "	",
          "&",
          "(",
          ")",
          "[",
          "]",
          "{",
          "}",
          "^",
          "=",
          ";",
          "!",
          "'",
          "+",
          ",",
          "`",
          "~",
          "|",
          "<",
          ">",
          '"'
        ];
        let needsQuotes = false;
        for (const char of arg) {
          if (cmdSpecialChars.some((x2) => x2 === char)) {
            needsQuotes = true;
            break;
          }
        }
        if (!needsQuotes) {
          return arg;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i2 = arg.length; i2 > 0; i2--) {
          reverse += arg[i2 - 1];
          if (quoteHit && arg[i2 - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i2 - 1] === '"') {
            quoteHit = true;
            reverse += '"';
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _uvQuoteCmdArg(arg) {
        if (!arg) {
          return '""';
        }
        if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
          return arg;
        }
        if (!arg.includes('"') && !arg.includes("\\")) {
          return `"${arg}"`;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i2 = arg.length; i2 > 0; i2--) {
          reverse += arg[i2 - 1];
          if (quoteHit && arg[i2 - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i2 - 1] === '"') {
            quoteHit = true;
            reverse += "\\";
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _cloneExecOptions(options) {
        options = options || {};
        const result = {
          cwd: options.cwd || process.cwd(),
          env: options.env || process.env,
          silent: options.silent || false,
          windowsVerbatimArguments: options.windowsVerbatimArguments || false,
          failOnStdErr: options.failOnStdErr || false,
          ignoreReturnCode: options.ignoreReturnCode || false,
          delay: options.delay || 1e4
        };
        result.outStream = options.outStream || process.stdout;
        result.errStream = options.errStream || process.stderr;
        return result;
      }
      _getSpawnOptions(options, toolPath) {
        options = options || {};
        const result = {};
        result.cwd = options.cwd;
        result.env = options.env;
        result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
        if (options.windowsVerbatimArguments) {
          result.argv0 = `"${toolPath}"`;
        }
        return result;
      }
      exec() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
            this.toolPath = path8.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
          }
          this.toolPath = yield io5.which(this.toolPath, true);
          return new Promise((resolve2, reject) => {
            this._debug(`exec tool: ${this.toolPath}`);
            this._debug("arguments:");
            for (const arg of this.args) {
              this._debug(`   ${arg}`);
            }
            const optionsNonNull = this._cloneExecOptions(this.options);
            if (!optionsNonNull.silent && optionsNonNull.outStream) {
              optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
            }
            const state = new ExecState(optionsNonNull, this.toolPath);
            state.on("debug", (message) => {
              this._debug(message);
            });
            const fileName = this._getSpawnFileName();
            const cp2 = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
            const stdbuffer = "";
            if (cp2.stdout) {
              cp2.stdout.on("data", (data) => {
                if (this.options.listeners && this.options.listeners.stdout) {
                  this.options.listeners.stdout(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                  optionsNonNull.outStream.write(data);
                }
                this._processLineBuffer(data, stdbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.stdline) {
                    this.options.listeners.stdline(line);
                  }
                });
              });
            }
            const errbuffer = "";
            if (cp2.stderr) {
              cp2.stderr.on("data", (data) => {
                state.processStderr = true;
                if (this.options.listeners && this.options.listeners.stderr) {
                  this.options.listeners.stderr(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                  const s2 = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                  s2.write(data);
                }
                this._processLineBuffer(data, errbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.errline) {
                    this.options.listeners.errline(line);
                  }
                });
              });
            }
            cp2.on("error", (err) => {
              state.processError = err.message;
              state.processExited = true;
              state.processClosed = true;
              state.CheckComplete();
            });
            cp2.on("exit", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            cp2.on("close", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              state.processClosed = true;
              this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            state.on("done", (error2, exitCode) => {
              if (stdbuffer.length > 0) {
                this.emit("stdline", stdbuffer);
              }
              if (errbuffer.length > 0) {
                this.emit("errline", errbuffer);
              }
              cp2.removeAllListeners();
              if (error2) {
                reject(error2);
              } else {
                resolve2(exitCode);
              }
            });
            if (this.options.input) {
              if (!cp2.stdin) {
                throw new Error("child process missing stdin");
              }
              cp2.stdin.end(this.options.input);
            }
          });
        });
      }
    };
    exports.ToolRunner = ToolRunner;
    function argStringToArray(argString) {
      const args = [];
      let inQuotes = false;
      let escaped = false;
      let arg = "";
      function append(c) {
        if (escaped && c !== '"') {
          arg += "\\";
        }
        arg += c;
        escaped = false;
      }
      for (let i2 = 0; i2 < argString.length; i2++) {
        const c = argString.charAt(i2);
        if (c === '"') {
          if (!escaped) {
            inQuotes = !inQuotes;
          } else {
            append(c);
          }
          continue;
        }
        if (c === "\\" && escaped) {
          append(c);
          continue;
        }
        if (c === "\\" && inQuotes) {
          escaped = true;
          continue;
        }
        if (c === " " && !inQuotes) {
          if (arg.length > 0) {
            args.push(arg);
            arg = "";
          }
          continue;
        }
        append(c);
      }
      if (arg.length > 0) {
        args.push(arg.trim());
      }
      return args;
    }
    exports.argStringToArray = argStringToArray;
    var ExecState = class extends events.EventEmitter {
      constructor(options, toolPath) {
        super();
        this.processClosed = false;
        this.processError = "";
        this.processExitCode = 0;
        this.processExited = false;
        this.processStderr = false;
        this.delay = 1e4;
        this.done = false;
        this.timeout = null;
        if (!toolPath) {
          throw new Error("toolPath must not be empty");
        }
        this.options = options;
        this.toolPath = toolPath;
        if (options.delay) {
          this.delay = options.delay;
        }
      }
      CheckComplete() {
        if (this.done) {
          return;
        }
        if (this.processClosed) {
          this._setResult();
        } else if (this.processExited) {
          this.timeout = setTimeout(ExecState.HandleTimeout, this.delay, this);
        }
      }
      _debug(message) {
        this.emit("debug", message);
      }
      _setResult() {
        let error2;
        if (this.processExited) {
          if (this.processError) {
            error2 = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
          } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
            error2 = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
          } else if (this.processStderr && this.options.failOnStdErr) {
            error2 = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
          }
        }
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.done = true;
        this.emit("done", error2, this.processExitCode);
      }
      static HandleTimeout(state) {
        if (state.done) {
          return;
        }
        if (!state.processClosed && state.processExited) {
          const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
          state._debug(message);
        }
        state._setResult();
      }
    };
  }
});

// node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS({
  "node_modules/@actions/exec/lib/exec.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var tr = __importStar(require_toolrunner());
    function exec4(commandLine, args, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const commandArgs = tr.argStringToArray(commandLine);
        if (commandArgs.length === 0) {
          throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
        }
        const toolPath = commandArgs[0];
        args = commandArgs.slice(1).concat(args || []);
        const runner = new tr.ToolRunner(toolPath, args, options);
        return runner.exec();
      });
    }
    exports.exec = exec4;
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self2 = this;
      var timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i2 = 0; i2 < this._errors.length; i2++) {
        var error2 = this._errors[i2];
        var message = error2.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error2;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i2 = 0; i2 < opts.retries; i2++) {
        timeouts.push(this.createTimeout(i2, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i2, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i2 = 0; i2 < methods.length; i2++) {
        var method = methods[i2];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/async-retry/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/async-retry/lib/index.js"(exports, module2) {
    var retrier = require_retry2();
    function retry2(fn, opts) {
      function run2(resolve2, reject) {
        var options = opts || {};
        if (!("randomize" in options)) {
          options.randomize = true;
        }
        var op = retrier.operation(options);
        function bail(err) {
          reject(err || new Error("Aborted"));
        }
        function onError(err, num) {
          if (err.bail) {
            bail(err);
            return;
          }
          if (!op.retry(err)) {
            reject(op.mainError());
          } else if (options.onRetry) {
            options.onRetry(err, num);
          }
        }
        function runAttempt(num) {
          var val;
          try {
            val = fn(bail, num);
          } catch (err) {
            onError(err, num);
            return;
          }
          Promise.resolve(val).then(resolve2).catch(function catchIt(err) {
            onError(err, num);
          });
        }
        op.attempt(runAttempt);
      }
      return new Promise(run2);
    }
    module2.exports = retry2;
  }
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "node_modules/pngjs/lib/chunkstream.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var Stream3 = require("stream");
    var ChunkStream = module2.exports = function() {
      Stream3.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream3);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(function() {
        this._process();
        if (this._paused && this._reads && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this));
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      let dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = Buffer.from(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read) {
      this._reads.shift();
      let smallerBuf = this._buffers[0];
      if (smallerBuf.length > read.length) {
        this._buffered -= read.length;
        this._buffers[0] = smallerBuf.slice(read.length);
        read.func.call(this, smallerBuf.slice(0, read.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read) {
      this._reads.shift();
      let pos = 0;
      let count = 0;
      let data = Buffer.alloc(read.length);
      while (pos < read.length) {
        let buf = this._buffers[count++];
        let len = Math.min(buf.length, read.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read.length;
      read.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          let read = this._reads[0];
          if (read.allowLess) {
            this._processReadAllowingLess(read);
          } else if (this._buffered >= read.length) {
            this._processRead(read);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS({
  "node_modules/pngjs/lib/interlace.js"(exports) {
    "use strict";
    var imagePasses = [
      {
        x: [0],
        y: [0]
      },
      {
        x: [4],
        y: [0]
      },
      {
        x: [0, 4],
        y: [4]
      },
      {
        x: [2, 6],
        y: [0, 4]
      },
      {
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports.getImagePasses = function(width, height) {
      let images = [];
      let xLeftOver = width % 8;
      let yLeftOver = height % 8;
      let xRepeats = (width - xLeftOver) / 8;
      let yRepeats = (height - yLeftOver) / 8;
      for (let i2 = 0; i2 < imagePasses.length; i2++) {
        let pass = imagePasses[i2];
        let passWidth = xRepeats * pass.x.length;
        let passHeight = yRepeats * pass.y.length;
        for (let j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (let j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i2 });
        }
      }
      return images;
    };
    exports.getInterlaceIterator = function(width) {
      return function(x2, y, pass) {
        let outerXLeftOver = x2 % imagePasses[pass].x.length;
        let outerX = (x2 - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        let outerYLeftOver = y % imagePasses[pass].y.length;
        let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "node_modules/pngjs/lib/paeth-predictor.js"(exports, module2) {
    "use strict";
    module2.exports = function paethPredictor(left, above, upLeft) {
      let paeth = left + above - upLeft;
      let pLeft = Math.abs(paeth - left);
      let pAbove = Math.abs(paeth - above);
      let pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "node_modules/pngjs/lib/filter-parse.js"(exports, module2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      let byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module2.exports = function(bitmapInfo, dependencies) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let interlace = bitmapInfo.interlace;
      let bpp = bitmapInfo.bpp;
      let depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        let passes = interlaceUtils.getImagePasses(width, height);
        for (let i2 = 0; i2 < passes.length; i2++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i2].width, bpp, depth),
            height: passes[i2].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f1Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
        unfilteredLine[x2] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      let lastLine = this._lastLine;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f2Up = lastLine ? lastLine[x2] : 0;
        unfilteredLine[x2] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f3Up = lastLine ? lastLine[x2] : 0;
        let f3Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
        let f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x2] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f4Up = lastLine ? lastLine[x2] : 0;
        let f4Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
        let f4UpLeft = x2 > xBiggerThan && lastLine ? lastLine[x2 - xComparison] : 0;
        let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x2] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      let filter = rawData[0];
      let unfilteredLine;
      let currentImage = this._images[this._imageIndex];
      let byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = Buffer.alloc(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "node_modules/pngjs/lib/filter-parse-async.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module2.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      let buffers = [];
      let that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
  }
});

// node_modules/pngjs/lib/constants.js
var require_constants = __commonJS({
  "node_modules/pngjs/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS({
  "node_modules/pngjs/lib/crc.js"(exports, module2) {
    "use strict";
    var crcTable = [];
    (function() {
      for (let i2 = 0; i2 < 256; i2++) {
        let currentCrc = i2;
        for (let j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i2] = currentCrc;
      }
    })();
    var CrcCalculator = module2.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (let i2 = 0; i2 < data.length; i2++) {
        this._crc = crcTable[(this._crc ^ data[i2]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      let crc = -1;
      for (let i2 = 0; i2 < buf.length; i2++) {
        crc = crcTable[(crc ^ buf[i2]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// node_modules/pngjs/lib/parser.js
var require_parser3 = __commonJS({
  "node_modules/pngjs/lib/parser.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    var CrcCalculator = require_crc();
    var Parser = module2.exports = function(options, dependencies) {
      this._options = options;
      options.checkCRC = options.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      let signature = constants.PNG_SIGNATURE;
      for (let i2 = 0; i2 < signature.length; i2++) {
        if (data[i2] !== signature[i2]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      let length = data.readUInt32BE(0);
      let type = data.readUInt32BE(4);
      let name = "";
      for (let i2 = 4; i2 < 8; i2++) {
        name += String.fromCharCode(data[i2]);
      }
      let ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(Buffer.from(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      let fileCrc = data.readInt32BE(0);
      let calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      let width = data.readUInt32BE(0);
      let height = data.readUInt32BE(4);
      let depth = data[8];
      let colorType = data[9];
      let compr = data[10];
      let filter = data[11];
      let interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      let entries = Math.floor(data.length / 3);
      for (let i2 = 0; i2 < entries; i2++) {
        this._palette.push([data[i2 * 3], data[i2 * 3 + 1], data[i2 * 3 + 2], 255]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (let i2 = 0; i2 < data.length; i2++) {
          this._palette[i2][3] = data[i2];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([
          data.readUInt16BE(0),
          data.readUInt16BE(2),
          data.readUInt16BE(4)
        ]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      let leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "node_modules/pngjs/lib/bitmapper.js"(exports) {
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMapper = [
      function() {
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      function() {
      },
      function(pxData, pixelData, pxPos, maxBit) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      let leftOver = [];
      let i2 = 0;
      function split() {
        if (i2 === data.length) {
          throw new Error("Ran out of data");
        }
        let byte = data[i2];
        i2++;
        let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i2];
            i2++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          let returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i2 !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x2 = 0; x2 < imageWidth; x2++) {
          let pxPos = getPxPos(x2, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x2 = 0; x2 < imageWidth; x2++) {
          let pixelData = bits.get(bpp);
          let pxPos = getPxPos(x2, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports.dataToBitMap = function(data, bitmapInfo) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let depth = bitmapInfo.depth;
      let bpp = bitmapInfo.bpp;
      let interlace = bitmapInfo.interlace;
      let bits;
      if (depth !== 8) {
        bits = bitRetriever(data, depth);
      }
      let pxData;
      if (depth <= 8) {
        pxData = Buffer.alloc(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      let maxBit = Math.pow(2, depth) - 1;
      let rawPos = 0;
      let images;
      let getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        let nonInterlacedPxPos = 0;
        getPxPos = function() {
          let returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        } else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "node_modules/pngjs/lib/format-normaliser.js"(exports, module2) {
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          let color = palette[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (let i2 = 0; i2 < 4; i2++) {
            outdata[pxPos + i2] = color[i2];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          let makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (let i2 = 0; i2 < 4; i2++) {
              outdata[pxPos + i2] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      let maxOutSample = 255;
      let maxInSample = Math.pow(2, depth) - 1;
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          for (let i2 = 0; i2 < 4; i2++) {
            outdata[pxPos + i2] = Math.floor(indata[pxPos + i2] * maxOutSample / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    module2.exports = function(indata, imageData) {
      let depth = imageData.depth;
      let width = imageData.width;
      let height = imageData.height;
      let colorType = imageData.colorType;
      let transColor = imageData.transColor;
      let palette = imageData.palette;
      let outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8) {
          if (depth === 16) {
            outdata = Buffer.alloc(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS({
  "node_modules/pngjs/lib/parser-async.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var zlib2 = require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser = require_parser3();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module2.exports = function(options) {
      ChunkStream.call(this);
      this._parser = new Parser(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options;
      this.writable = true;
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib2.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          let imageSize = rowSize * this._bitmapInfo.height;
          let chunkSize = Math.max(imageSize, zlib2.Z_MIN_CHUNK);
          this._inflate = zlib2.createInflate({ chunkSize });
          let leftToInflate = imageSize;
          let emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err) {
            if (!leftToInflate) {
              return;
            }
            emitError(err);
          });
          this._filter.on("complete", this._complete.bind(this));
          let filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk) {
            if (!leftToInflate) {
              return;
            }
            if (chunk.length > leftToInflate) {
              chunk = chunk.slice(0, leftToInflate);
            }
            leftToInflate -= chunk.length;
            filterWrite(chunk);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      let normalisedBitmapData;
      try {
        let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "node_modules/pngjs/lib/bitpacker.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    module2.exports = function(dataIn, width, height, options) {
      let outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
      if (options.colorType === options.inputColorType) {
        let bigEndian = function() {
          let buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] !== 256;
        }();
        if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      let maxValue = 255;
      let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
      if (inBpp === 4 && !options.inputHasAlpha) {
        inBpp = 3;
      }
      let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
      if (options.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      let outData = Buffer.alloc(width * height * outBpp);
      let inIndex = 0;
      let outIndex = 0;
      let bgColor = options.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        let red;
        let green;
        let blue;
        let alpha = maxValue;
        switch (options.inputColorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error("input color type:" + options.inputColorType + " is not supported at present");
        }
        if (options.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
            green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
            blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
          }
        }
        return { red, green, blue, alpha };
      }
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          let rgba = getRGBA(data, inIndex);
          switch (options.colorType) {
            case constants.COLORTYPE_COLOR_ALPHA:
            case constants.COLORTYPE_COLOR:
              if (options.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants.COLORTYPE_ALPHA:
            case constants.COLORTYPE_GRAYSCALE: {
              let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            }
            default:
              throw new Error("unrecognised color Type " + options.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "node_modules/pngjs/lib/filter-pack.js"(exports, module2) {
    "use strict";
    var paethPredictor = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        rawData[rawPos + x2] = pxData[pxPos + x2];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let i2 = pxPos; i2 < length; i2++) {
        sum += Math.abs(pxData[i2]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let val = pxData[pxPos + x2] - left;
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let val = pxData[pxPos + x2] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let val = pxData[pxPos + x2] - up;
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let x2 = pxPos; x2 < length; x2++) {
        let up = pxPos > 0 ? pxData[x2 - byteWidth] : 0;
        let val = pxData[x2] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let val = pxData[pxPos + x2] - (left + up >> 1);
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let val = pxData[pxPos + x2] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let upleft = pxPos > 0 && x2 >= bpp ? pxData[pxPos + x2 - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x2] - paethPredictor(left, up, upleft);
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let upleft = pxPos > 0 && x2 >= bpp ? pxData[pxPos + x2 - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x2] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module2.exports = function(pxData, width, height, options, bpp) {
      let filterTypes;
      if (!("filterType" in options) || options.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options.filterType === "number") {
        filterTypes = [options.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options.bitDepth === 16) {
        bpp *= 2;
      }
      let byteWidth = width * bpp;
      let rawPos = 0;
      let pxPos = 0;
      let rawData = Buffer.alloc((byteWidth + 1) * height);
      let sel = filterTypes[0];
      for (let y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          let min = Infinity;
          for (let i2 = 0; i2 < filterTypes.length; i2++) {
            let sum = filterSums[filterTypes[i2]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i2];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS({
  "node_modules/pngjs/lib/packer.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib2 = require("zlib");
    var Packer = module2.exports = function(options) {
      this._options = options;
      options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
      options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
      options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
      options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
      options.deflateFactory = options.deflateFactory || zlib2.createDeflate;
      options.bitDepth = options.bitDepth || 8;
      options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
      options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.colorType) === -1) {
        throw new Error("option color type:" + options.colorType + " is not supported at present");
      }
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.inputColorType) === -1) {
        throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.bitDepth !== 8 && options.bitDepth !== 16) {
        throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      let packedData = bitPacker(data, width, height, this._options);
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      let filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      let len = data ? data.length : 0;
      let buf = Buffer.alloc(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      let buf = Buffer.alloc(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      let buf = Buffer.alloc(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
  }
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS({
  "node_modules/pngjs/lib/packer-async.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var Stream3 = require("stream");
    var constants = require_constants();
    var Packer = require_packer();
    var PackerAsync = module2.exports = function(opt) {
      Stream3.call(this);
      let options = opt || {};
      this._packer = new Packer(options);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util.inherits(PackerAsync, Stream3);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      let filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this));
      this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this));
      this._deflate.end(filteredData);
    };
  }
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "node_modules/pngjs/lib/sync-inflate.js"(exports, module2) {
    "use strict";
    var assert = require("assert").ok;
    var zlib2 = require("zlib");
    var util = require("util");
    var kMaxLength = require("buffer").kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib2.Z_MIN_CHUNK) {
        opts.chunkSize = zlib2.Z_MIN_CHUNK;
      }
      zlib2.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib2.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk && chunk.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error2;
      this.on("error", function(err) {
        error2 = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error2;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util.inherits(Inflate, zlib2.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib2.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module2.exports = exports = inflateSync;
    exports.Inflate = Inflate;
    exports.createInflate = createInflate;
    exports.inflateSync = inflateSync;
  }
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "node_modules/pngjs/lib/sync-reader.js"(exports, module2) {
    "use strict";
    var SyncReader = module2.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        let read = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
          this._reads.shift();
          let buf = this._buffer;
          this._buffer = buf.slice(read.length);
          read.func.call(this, buf.slice(0, read.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        return new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        return new Error("unrecognised content at end of stream");
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "node_modules/pngjs/lib/filter-parse-sync.js"(exports) {
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports.process = function(inBuffer, bitmapInfo) {
      let outBuffers = [];
      let reader = new SyncReader(inBuffer);
      let filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "node_modules/pngjs/lib/parser-sync.js"(exports, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser = require_parser3();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module2.exports = function(buffer, options) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let err;
      function handleError2(_err_) {
        err = _err_;
      }
      let metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      let gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      let inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      let reader = new SyncReader(buffer);
      let parser = new Parser(options, {
        read: reader.read.bind(reader),
        error: handleError2,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      let inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      let inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib2.inflateSync(inflateData);
      } else {
        let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        let imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, {
          chunkSize: imageSize,
          maxLength: imageSize
        });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      let unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      let normalisedBitmapData = formatNormaliser(bitmapData, metaData);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "node_modules/pngjs/lib/packer-sync.js"(exports, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var constants = require_constants();
    var Packer = require_packer();
    module2.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let options = opt || {};
      let packer = new Packer(options);
      let chunks = [];
      chunks.push(Buffer.from(constants.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
      let compressedData = zlib2.deflateSync(filteredData, packer.getDeflateOptions());
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS({
  "node_modules/pngjs/lib/png-sync.js"(exports) {
    "use strict";
    var parse2 = require_parser_sync();
    var pack = require_packer_sync();
    exports.read = function(buffer, options) {
      return parse2(buffer, options || {});
    };
    exports.write = function(png, options) {
      return pack(png, options);
    };
  }
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS({
  "node_modules/pngjs/lib/png.js"(exports) {
    "use strict";
    var util = require("util");
    var Stream3 = require("stream");
    var Parser = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG6 = exports.PNG = function(options) {
      Stream3.call(this);
      options = options || {};
      this.width = options.width | 0;
      this.height = options.height | 0;
      this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
      if (options.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on("parsed", function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this));
      this._packer = new Packer(options);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util.inherits(PNG6, Stream3);
    PNG6.sync = PNGSync;
    PNG6.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
      return this;
    };
    PNG6.prototype.parse = function(data, callback) {
      if (callback) {
        let onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG6.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG6.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG6.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG6.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG6.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG6.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (let y = 0; y < height; y++) {
        src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
      }
    };
    PNG6.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG6.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG6.adjustGamma = function(src) {
      if (src.gamma) {
        for (let y = 0; y < src.height; y++) {
          for (let x2 = 0; x2 < src.width; x2++) {
            let idx = src.width * y + x2 << 2;
            for (let i2 = 0; i2 < 3; i2++) {
              let sample = src.data[idx + i2] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              src.data[idx + i2] = Math.round(sample * 255);
            }
          }
        }
        src.gamma = 0;
      }
    };
    PNG6.prototype.adjustGamma = function() {
      PNG6.adjustGamma(this);
    };
  }
});

// node_modules/pixelmatch/index.js
var require_pixelmatch = __commonJS({
  "node_modules/pixelmatch/index.js"(exports, module2) {
    "use strict";
    module2.exports = pixelmatch2;
    var defaultOptions = {
      threshold: 0.1,
      includeAA: false,
      alpha: 0.1,
      aaColor: [255, 255, 0],
      diffColor: [255, 0, 0],
      diffColorAlt: null,
      diffMask: false
    };
    function pixelmatch2(img1, img2, output, width, height, options) {
      if (!isPixelData(img1) || !isPixelData(img2) || output && !isPixelData(output))
        throw new Error("Image data: Uint8Array, Uint8ClampedArray or Buffer expected.");
      if (img1.length !== img2.length || output && output.length !== img1.length)
        throw new Error("Image sizes do not match.");
      if (img1.length !== width * height * 4)
        throw new Error("Image data size does not match width/height.");
      options = Object.assign({}, defaultOptions, options);
      const len = width * height;
      const a32 = new Uint32Array(img1.buffer, img1.byteOffset, len);
      const b32 = new Uint32Array(img2.buffer, img2.byteOffset, len);
      let identical = true;
      for (let i2 = 0; i2 < len; i2++) {
        if (a32[i2] !== b32[i2]) {
          identical = false;
          break;
        }
      }
      if (identical) {
        if (output && !options.diffMask) {
          for (let i2 = 0; i2 < len; i2++)
            drawGrayPixel(img1, 4 * i2, options.alpha, output);
        }
        return 0;
      }
      const maxDelta = 35215 * options.threshold * options.threshold;
      let diff = 0;
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          const pos = (y * width + x2) * 4;
          const delta = colorDelta(img1, img2, pos, pos);
          if (Math.abs(delta) > maxDelta) {
            if (!options.includeAA && (antialiased(img1, x2, y, width, height, img2) || antialiased(img2, x2, y, width, height, img1))) {
              if (output && !options.diffMask)
                drawPixel(output, pos, ...options.aaColor);
            } else {
              if (output) {
                drawPixel(output, pos, ...delta < 0 && options.diffColorAlt || options.diffColor);
              }
              diff++;
            }
          } else if (output) {
            if (!options.diffMask)
              drawGrayPixel(img1, pos, options.alpha, output);
          }
        }
      }
      return diff;
    }
    function isPixelData(arr) {
      return ArrayBuffer.isView(arr) && arr.constructor.BYTES_PER_ELEMENT === 1;
    }
    function antialiased(img, x1, y1, width, height, img2) {
      const x0 = Math.max(x1 - 1, 0);
      const y0 = Math.max(y1 - 1, 0);
      const x2 = Math.min(x1 + 1, width - 1);
      const y2 = Math.min(y1 + 1, height - 1);
      const pos = (y1 * width + x1) * 4;
      let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;
      let min = 0;
      let max = 0;
      let minX, minY, maxX, maxY;
      for (let x3 = x0; x3 <= x2; x3++) {
        for (let y = y0; y <= y2; y++) {
          if (x3 === x1 && y === y1)
            continue;
          const delta = colorDelta(img, img, pos, (y * width + x3) * 4, true);
          if (delta === 0) {
            zeroes++;
            if (zeroes > 2)
              return false;
          } else if (delta < min) {
            min = delta;
            minX = x3;
            minY = y;
          } else if (delta > max) {
            max = delta;
            maxX = x3;
            maxY = y;
          }
        }
      }
      if (min === 0 || max === 0)
        return false;
      return hasManySiblings(img, minX, minY, width, height) && hasManySiblings(img2, minX, minY, width, height) || hasManySiblings(img, maxX, maxY, width, height) && hasManySiblings(img2, maxX, maxY, width, height);
    }
    function hasManySiblings(img, x1, y1, width, height) {
      const x0 = Math.max(x1 - 1, 0);
      const y0 = Math.max(y1 - 1, 0);
      const x2 = Math.min(x1 + 1, width - 1);
      const y2 = Math.min(y1 + 1, height - 1);
      const pos = (y1 * width + x1) * 4;
      let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;
      for (let x3 = x0; x3 <= x2; x3++) {
        for (let y = y0; y <= y2; y++) {
          if (x3 === x1 && y === y1)
            continue;
          const pos2 = (y * width + x3) * 4;
          if (img[pos] === img[pos2] && img[pos + 1] === img[pos2 + 1] && img[pos + 2] === img[pos2 + 2] && img[pos + 3] === img[pos2 + 3])
            zeroes++;
          if (zeroes > 2)
            return true;
        }
      }
      return false;
    }
    function colorDelta(img1, img2, k, m2, yOnly) {
      let r1 = img1[k + 0];
      let g1 = img1[k + 1];
      let b1 = img1[k + 2];
      let a1 = img1[k + 3];
      let r2 = img2[m2 + 0];
      let g2 = img2[m2 + 1];
      let b2 = img2[m2 + 2];
      let a2 = img2[m2 + 3];
      if (a1 === a2 && r1 === r2 && g1 === g2 && b1 === b2)
        return 0;
      if (a1 < 255) {
        a1 /= 255;
        r1 = blend(r1, a1);
        g1 = blend(g1, a1);
        b1 = blend(b1, a1);
      }
      if (a2 < 255) {
        a2 /= 255;
        r2 = blend(r2, a2);
        g2 = blend(g2, a2);
        b2 = blend(b2, a2);
      }
      const y1 = rgb2y(r1, g1, b1);
      const y2 = rgb2y(r2, g2, b2);
      const y = y1 - y2;
      if (yOnly)
        return y;
      const i2 = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2);
      const q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);
      const delta = 0.5053 * y * y + 0.299 * i2 * i2 + 0.1957 * q * q;
      return y1 > y2 ? -delta : delta;
    }
    function rgb2y(r2, g, b) {
      return r2 * 0.29889531 + g * 0.58662247 + b * 0.11448223;
    }
    function rgb2i(r2, g, b) {
      return r2 * 0.59597799 - g * 0.2741761 - b * 0.32180189;
    }
    function rgb2q(r2, g, b) {
      return r2 * 0.21147017 - g * 0.52261711 + b * 0.31114694;
    }
    function blend(c, a) {
      return 255 + (c - 255) * a;
    }
    function drawPixel(output, pos, r2, g, b) {
      output[pos + 0] = r2;
      output[pos + 1] = g;
      output[pos + 2] = b;
      output[pos + 3] = 255;
    }
    function drawGrayPixel(img, i2, alpha, output) {
      const r2 = img[i2 + 0];
      const g = img[i2 + 1];
      const b = img[i2 + 2];
      const val = blend(rgb2y(r2, g, b), alpha * img[i2 + 3] / 255);
      drawPixel(output, i2, val, val, val);
    }
  }
});

// node_modules/@actions/http-client/auth.js
var require_auth = __commonJS({
  "node_modules/@actions/http-client/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        options.headers["Authorization"] = "Basic " + Buffer.from(this.username + ":" + this.password).toString("base64");
      }
      canHandleAuthentication(response) {
        return false;
      }
      handleAuthentication(httpClient, requestInfo, objs) {
        return null;
      }
    };
    exports.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token2) {
        this.token = token2;
      }
      prepareRequest(options) {
        options.headers["Authorization"] = "Bearer " + this.token;
      }
      canHandleAuthentication(response) {
        return false;
      }
      handleAuthentication(httpClient, requestInfo, objs) {
        return null;
      }
    };
    exports.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token2) {
        this.token = token2;
      }
      prepareRequest(options) {
        options.headers["Authorization"] = "Basic " + Buffer.from("PAT:" + this.token).toString("base64");
      }
      canHandleAuthentication(response) {
        return false;
      }
      handleAuthentication(httpClient, requestInfo, objs) {
        return null;
      }
    };
    exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// node_modules/@actions/artifact/lib/internal/config-variables.js
var require_config_variables = __commonJS({
  "node_modules/@actions/artifact/lib/internal/config-variables.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getUploadFileConcurrency() {
      return 2;
    }
    exports.getUploadFileConcurrency = getUploadFileConcurrency;
    function getUploadChunkSize() {
      return 8 * 1024 * 1024;
    }
    exports.getUploadChunkSize = getUploadChunkSize;
    function getRetryLimit() {
      return 5;
    }
    exports.getRetryLimit = getRetryLimit;
    function getRetryMultiplier() {
      return 1.5;
    }
    exports.getRetryMultiplier = getRetryMultiplier;
    function getInitialRetryIntervalInMilliseconds() {
      return 3e3;
    }
    exports.getInitialRetryIntervalInMilliseconds = getInitialRetryIntervalInMilliseconds;
    function getDownloadFileConcurrency() {
      return 2;
    }
    exports.getDownloadFileConcurrency = getDownloadFileConcurrency;
    function getRuntimeToken() {
      const token2 = process.env["ACTIONS_RUNTIME_TOKEN"];
      if (!token2) {
        throw new Error("Unable to get ACTIONS_RUNTIME_TOKEN env variable");
      }
      return token2;
    }
    exports.getRuntimeToken = getRuntimeToken;
    function getRuntimeUrl() {
      const runtimeUrl = process.env["ACTIONS_RUNTIME_URL"];
      if (!runtimeUrl) {
        throw new Error("Unable to get ACTIONS_RUNTIME_URL env variable");
      }
      return runtimeUrl;
    }
    exports.getRuntimeUrl = getRuntimeUrl;
    function getWorkFlowRunId() {
      const workFlowRunId = process.env["GITHUB_RUN_ID"];
      if (!workFlowRunId) {
        throw new Error("Unable to get GITHUB_RUN_ID env variable");
      }
      return workFlowRunId;
    }
    exports.getWorkFlowRunId = getWorkFlowRunId;
    function getWorkSpaceDirectory() {
      const workspaceDirectory = process.env["GITHUB_WORKSPACE"];
      if (!workspaceDirectory) {
        throw new Error("Unable to get GITHUB_WORKSPACE env variable");
      }
      return workspaceDirectory;
    }
    exports.getWorkSpaceDirectory = getWorkSpaceDirectory;
    function getRetentionDays() {
      return process.env["GITHUB_RETENTION_DAYS"];
    }
    exports.getRetentionDays = getRetentionDays;
  }
});

// node_modules/@actions/artifact/lib/internal/utils.js
var require_utils5 = __commonJS({
  "node_modules/@actions/artifact/lib/internal/utils.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core();
    var fs_1 = require("fs");
    var http_client_1 = require_http_client();
    var auth_1 = require_auth();
    var config_variables_1 = require_config_variables();
    function getExponentialRetryTimeInMilliseconds(retryCount) {
      if (retryCount < 0) {
        throw new Error("RetryCount should not be negative");
      } else if (retryCount === 0) {
        return config_variables_1.getInitialRetryIntervalInMilliseconds();
      }
      const minTime = config_variables_1.getInitialRetryIntervalInMilliseconds() * config_variables_1.getRetryMultiplier() * retryCount;
      const maxTime = minTime * config_variables_1.getRetryMultiplier();
      return Math.random() * (maxTime - minTime) + minTime;
    }
    exports.getExponentialRetryTimeInMilliseconds = getExponentialRetryTimeInMilliseconds;
    function parseEnvNumber(key) {
      const value = Number(process.env[key]);
      if (Number.isNaN(value) || value < 0) {
        return void 0;
      }
      return value;
    }
    exports.parseEnvNumber = parseEnvNumber;
    function getApiVersion() {
      return "6.0-preview";
    }
    exports.getApiVersion = getApiVersion;
    function isSuccessStatusCode(statusCode) {
      if (!statusCode) {
        return false;
      }
      return statusCode >= 200 && statusCode < 300;
    }
    exports.isSuccessStatusCode = isSuccessStatusCode;
    function isForbiddenStatusCode(statusCode) {
      if (!statusCode) {
        return false;
      }
      return statusCode === http_client_1.HttpCodes.Forbidden;
    }
    exports.isForbiddenStatusCode = isForbiddenStatusCode;
    function isRetryableStatusCode(statusCode) {
      if (!statusCode) {
        return false;
      }
      const retryableStatusCodes = [
        http_client_1.HttpCodes.BadGateway,
        http_client_1.HttpCodes.ServiceUnavailable,
        http_client_1.HttpCodes.GatewayTimeout,
        http_client_1.HttpCodes.TooManyRequests,
        413
      ];
      return retryableStatusCodes.includes(statusCode);
    }
    exports.isRetryableStatusCode = isRetryableStatusCode;
    function isThrottledStatusCode(statusCode) {
      if (!statusCode) {
        return false;
      }
      return statusCode === http_client_1.HttpCodes.TooManyRequests;
    }
    exports.isThrottledStatusCode = isThrottledStatusCode;
    function tryGetRetryAfterValueTimeInMilliseconds(headers) {
      if (headers["retry-after"]) {
        const retryTime = Number(headers["retry-after"]);
        if (!isNaN(retryTime)) {
          core_1.info(`Retry-After header is present with a value of ${retryTime}`);
          return retryTime * 1e3;
        }
        core_1.info(`Returned retry-after header value: ${retryTime} is non-numeric and cannot be used`);
        return void 0;
      }
      core_1.info(`No retry-after header was found. Dumping all headers for diagnostic purposes`);
      console.log(headers);
      return void 0;
    }
    exports.tryGetRetryAfterValueTimeInMilliseconds = tryGetRetryAfterValueTimeInMilliseconds;
    function getContentRange(start, end, total) {
      return `bytes ${start}-${end}/${total}`;
    }
    exports.getContentRange = getContentRange;
    function getDownloadHeaders(contentType, isKeepAlive, acceptGzip) {
      const requestOptions = {};
      if (contentType) {
        requestOptions["Content-Type"] = contentType;
      }
      if (isKeepAlive) {
        requestOptions["Connection"] = "Keep-Alive";
        requestOptions["Keep-Alive"] = "10";
      }
      if (acceptGzip) {
        requestOptions["Accept-Encoding"] = "gzip";
        requestOptions["Accept"] = `application/octet-stream;api-version=${getApiVersion()}`;
      } else {
        requestOptions["Accept"] = `application/json;api-version=${getApiVersion()}`;
      }
      return requestOptions;
    }
    exports.getDownloadHeaders = getDownloadHeaders;
    function getUploadHeaders(contentType, isKeepAlive, isGzip, uncompressedLength, contentLength, contentRange) {
      const requestOptions = {};
      requestOptions["Accept"] = `application/json;api-version=${getApiVersion()}`;
      if (contentType) {
        requestOptions["Content-Type"] = contentType;
      }
      if (isKeepAlive) {
        requestOptions["Connection"] = "Keep-Alive";
        requestOptions["Keep-Alive"] = "10";
      }
      if (isGzip) {
        requestOptions["Content-Encoding"] = "gzip";
        requestOptions["x-tfs-filelength"] = uncompressedLength;
      }
      if (contentLength) {
        requestOptions["Content-Length"] = contentLength;
      }
      if (contentRange) {
        requestOptions["Content-Range"] = contentRange;
      }
      return requestOptions;
    }
    exports.getUploadHeaders = getUploadHeaders;
    function createHttpClient(userAgent) {
      return new http_client_1.HttpClient(userAgent, [
        new auth_1.BearerCredentialHandler(config_variables_1.getRuntimeToken())
      ]);
    }
    exports.createHttpClient = createHttpClient;
    function getArtifactUrl() {
      const artifactUrl = `${config_variables_1.getRuntimeUrl()}_apis/pipelines/workflows/${config_variables_1.getWorkFlowRunId()}/artifacts?api-version=${getApiVersion()}`;
      core_1.debug(`Artifact Url: ${artifactUrl}`);
      return artifactUrl;
    }
    exports.getArtifactUrl = getArtifactUrl;
    function displayHttpDiagnostics(response) {
      core_1.info(`##### Begin Diagnostic HTTP information #####
Status Code: ${response.message.statusCode}
Status Message: ${response.message.statusMessage}
Header Information: ${JSON.stringify(response.message.headers, void 0, 2)}
###### End Diagnostic HTTP information ######`);
    }
    exports.displayHttpDiagnostics = displayHttpDiagnostics;
    var invalidArtifactFilePathCharacters = ['"', ":", "<", ">", "|", "*", "?"];
    var invalidArtifactNameCharacters = [
      ...invalidArtifactFilePathCharacters,
      "\\",
      "/"
    ];
    function checkArtifactName(name) {
      if (!name) {
        throw new Error(`Artifact name: ${name}, is incorrectly provided`);
      }
      for (const invalidChar of invalidArtifactNameCharacters) {
        if (name.includes(invalidChar)) {
          throw new Error(`Artifact name is not valid: ${name}. Contains character: "${invalidChar}". Invalid artifact name characters include: ${invalidArtifactNameCharacters.toString()}.`);
        }
      }
    }
    exports.checkArtifactName = checkArtifactName;
    function checkArtifactFilePath(path8) {
      if (!path8) {
        throw new Error(`Artifact path: ${path8}, is incorrectly provided`);
      }
      for (const invalidChar of invalidArtifactFilePathCharacters) {
        if (path8.includes(invalidChar)) {
          throw new Error(`Artifact path is not valid: ${path8}. Contains character: "${invalidChar}". Invalid characters include: ${invalidArtifactFilePathCharacters.toString()}.`);
        }
      }
    }
    exports.checkArtifactFilePath = checkArtifactFilePath;
    function createDirectoriesForArtifact(directories) {
      return __awaiter(this, void 0, void 0, function* () {
        for (const directory of directories) {
          yield fs_1.promises.mkdir(directory, {
            recursive: true
          });
        }
      });
    }
    exports.createDirectoriesForArtifact = createDirectoriesForArtifact;
    function createEmptyFilesForArtifact(emptyFilesToCreate) {
      return __awaiter(this, void 0, void 0, function* () {
        for (const filePath of emptyFilesToCreate) {
          yield (yield fs_1.promises.open(filePath, "w")).close();
        }
      });
    }
    exports.createEmptyFilesForArtifact = createEmptyFilesForArtifact;
    function getProperRetention(retentionInput, retentionSetting) {
      if (retentionInput < 0) {
        throw new Error("Invalid retention, minimum value is 1.");
      }
      let retention = retentionInput;
      if (retentionSetting) {
        const maxRetention = parseInt(retentionSetting);
        if (!isNaN(maxRetention) && maxRetention < retention) {
          core_1.warning(`Retention days is greater than the max value allowed by the repository setting, reduce retention to ${maxRetention} days`);
          retention = maxRetention;
        }
      }
      return retention;
    }
    exports.getProperRetention = getProperRetention;
  }
});

// node_modules/@actions/artifact/lib/internal/upload-specification.js
var require_upload_specification = __commonJS({
  "node_modules/@actions/artifact/lib/internal/upload-specification.js"(exports) {
    "use strict";
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs8 = __importStar(require("fs"));
    var core_1 = require_core();
    var path_1 = require("path");
    var utils_1 = require_utils5();
    function getUploadSpecification(artifactName, rootDirectory, artifactFiles) {
      utils_1.checkArtifactName(artifactName);
      const specifications = [];
      if (!fs8.existsSync(rootDirectory)) {
        throw new Error(`Provided rootDirectory ${rootDirectory} does not exist`);
      }
      if (!fs8.lstatSync(rootDirectory).isDirectory()) {
        throw new Error(`Provided rootDirectory ${rootDirectory} is not a valid directory`);
      }
      rootDirectory = path_1.normalize(rootDirectory);
      rootDirectory = path_1.resolve(rootDirectory);
      for (let file of artifactFiles) {
        if (!fs8.existsSync(file)) {
          throw new Error(`File ${file} does not exist`);
        }
        if (!fs8.lstatSync(file).isDirectory()) {
          file = path_1.normalize(file);
          file = path_1.resolve(file);
          if (!file.startsWith(rootDirectory)) {
            throw new Error(`The rootDirectory: ${rootDirectory} is not a parent directory of the file: ${file}`);
          }
          const uploadPath = file.replace(rootDirectory, "");
          utils_1.checkArtifactFilePath(uploadPath);
          specifications.push({
            absoluteFilePath: file,
            uploadFilePath: path_1.join(artifactName, uploadPath)
          });
        } else {
          core_1.debug(`Removing ${file} from rawSearchResults because it is a directory`);
        }
      }
      return specifications;
    }
    exports.getUploadSpecification = getUploadSpecification;
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs8 = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m2 = splitRootRe.exec(p);
        pos = m2[0].length;
        current = m2[0];
        base = m2[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs8.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat2 = fs8.lstatSync(base);
          if (!stat2.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs8.statSync(base);
            linkTarget = fs8.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m2 = splitRootRe.exec(p);
        pos = m2[0].length;
        current = m2[0];
        base = m2[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs8.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs8.lstat(base, gotStat);
      }
      function gotStat(err, stat2) {
        if (err)
          return cb(err);
        if (!stat2.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs8.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs8.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "node_modules/fs.realpath/index.js"(exports, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs8 = require("fs");
    var origRealpath = fs8.realpath;
    var origRealpathSync = fs8.realpathSync;
    var version2 = process.version;
    var ok = /^v[0-5]\./.test(version2);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs8.realpath = realpath;
      fs8.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs8.realpath = origRealpath;
      fs8.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e2) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports, module2) {
    "use strict";
    function posix(path8) {
      return path8.charAt(0) === "/";
    }
    function win32(path8) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path8);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/glob/common.js
var require_common = __commonJS({
  "node_modules/glob/common.js"(exports) {
    exports.alphasort = alphasort;
    exports.alphasorti = alphasorti;
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var path8 = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasorti(a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    }
    function alphasort(a, b) {
      return a.localeCompare(b);
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && pattern.indexOf("/") === -1) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path8.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path8.resolve(self2.cwd, "/");
      self2.root = path8.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i2 = 0, l = self2.matches.length; i2 < l; i2++) {
        var matches = self2.matches[i2];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i2];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m2 = Object.keys(matches);
          if (nou)
            all.push.apply(all, m2);
          else
            m2.forEach(function(m3) {
              all[m3] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(self2.nocase ? alphasorti : alphasort);
      if (self2.mark) {
        for (var i2 = 0; i2 < all.length; i2++) {
          all[i2] = self2._mark(all[i2]);
        }
        if (self2.nodir) {
          all = all.filter(function(e2) {
            var notDir = !/\/$/.test(e2);
            var c = self2.cache[e2] || self2.cache[makeAbs(self2, e2)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m3) {
          return !isIgnored(self2, m3);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m2 = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m2 += "/";
        else if (!isDir && slash)
          m2 = m2.slice(0, -1);
        if (m2 !== p) {
          var mabs = makeAbs(self2, m2);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m2;
    }
    function makeAbs(self2, f3) {
      var abs = f3;
      if (f3.charAt(0) === "/") {
        abs = path8.join(self2.root, f3);
      } else if (isAbsolute(f3) || f3 === "") {
        abs = f3;
      } else if (self2.changedCwd) {
        abs = path8.resolve(self2.cwd, f3);
      } else {
        abs = path8.resolve(f3);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path9) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path9) || !!(item.gmatcher && item.gmatcher.match(path9));
      });
    }
    function childrenIgnored(self2, path9) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path9));
      });
    }
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/glob/sync.js"(exports, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var fs8 = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob2().Glob;
    var util = require("util");
    var path8 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i2 = 0; i2 < n; i2++) {
        this._process(this.minimatch.set[i2], i2, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) !== "." || dotOk) {
          var m2;
          if (negate && !prefix) {
            m2 = !e2.match(pn);
          } else {
            m2 = e2.match(pn);
          }
          if (m2)
            matchedEntries.push(e2);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < len; i2++) {
          var e2 = matchedEntries[i2];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e2 = prefix + "/" + e2;
            else
              e2 = prefix + e2;
          }
          if (e2.charAt(0) === "/" && !this.nomount) {
            e2 = path8.join(this.root, e2);
          }
          this._emitMatch(index, e2);
        }
        return;
      }
      remain.shift();
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = matchedEntries[i2];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e2];
        else
          newPattern = [e2];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e2) {
      if (isIgnored(this, e2))
        return;
      var abs = this._makeAbs(e2);
      if (this.mark)
        e2 = this._mark(e2);
      if (this.absolute) {
        e2 = abs;
      }
      if (this.matches[index][e2])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e2] = true;
      if (this.stat)
        this._stat(e2);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat2;
      try {
        lstat = fs8.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, fs8.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e2 = entries[i2];
          if (abs === "/")
            e2 = abs + e2;
          else
            e2 = abs + "/" + e2;
          this.cache[e2] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f3, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f3);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            throw error2;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f3)] = false;
          break;
        default:
          this.cache[this._makeAbs(f3)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i2], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path8.join(this.root, prefix);
        } else {
          prefix = path8.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f3) {
      var abs = this._makeAbs(f3);
      var needDir = f3.slice(-1) === "/";
      if (f3.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat2 = this.statCache[abs];
      if (!stat2) {
        var lstat;
        try {
          lstat = fs8.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat2 = fs8.statSync(abs);
          } catch (er) {
            stat2 = lstat;
          }
        } else {
          stat2 = lstat;
        }
      }
      this.statCache[abs] = stat2;
      var c = true;
      if (stat2)
        c = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f3) {
      return common.makeAbs(this, f3);
    };
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i2 = 0; i2 < len; i2++) {
            cbs[i2].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i2 = 0; i2 < length; i2++)
        array[i2] = args[i2];
      return array;
    }
  }
});

// node_modules/glob/glob.js
var require_glob2 = __commonJS({
  "node_modules/glob/glob.js"(exports, module2) {
    module2.exports = glob6;
    var fs8 = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path8 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob6(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob6.sync = globSync;
    var GlobSync = glob6.GlobSync = globSync.GlobSync;
    glob6.glob = glob6;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i2 = keys.length;
      while (i2--) {
        origin[keys[i2]] = add[keys[i2]];
      }
      return origin;
    }
    glob6.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob6.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i2 = 0; i2 < n; i2++) {
        this._process(this.minimatch.set[i2], i2, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i2 = 0; i2 < this.matches.length; i2++)
        this._realpathSet(i2, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i2) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f3) {
      return common.makeAbs(this, f3);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i2 = 0; i2 < eq.length; i2++) {
            var e2 = eq[i2];
            this._emitMatch(e2[0], e2[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i2 = 0; i2 < pq.length; i2++) {
            var p = pq[i2];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) !== "." || dotOk) {
          var m2;
          if (negate && !prefix) {
            m2 = !e2.match(pn);
          } else {
            m2 = e2.match(pn);
          }
          if (m2)
            matchedEntries.push(e2);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < len; i2++) {
          var e2 = matchedEntries[i2];
          if (prefix) {
            if (prefix !== "/")
              e2 = prefix + "/" + e2;
            else
              e2 = prefix + e2;
          }
          if (e2.charAt(0) === "/" && !this.nomount) {
            e2 = path8.join(this.root, e2);
          }
          this._emitMatch(index, e2);
        }
        return cb();
      }
      remain.shift();
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = matchedEntries[i2];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e2 = prefix + "/" + e2;
          else
            e2 = prefix + e2;
        }
        this._process([e2].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e2) {
      if (this.aborted)
        return;
      if (isIgnored(this, e2))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e2]);
        return;
      }
      var abs = isAbsolute(e2) ? e2 : this._makeAbs(e2);
      if (this.mark)
        e2 = this._mark(e2);
      if (this.absolute)
        e2 = abs;
      if (this.matches[index][e2])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e2] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e2, st);
      this.emit("match", e2);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        fs8.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      fs8.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e2 = entries[i2];
          if (abs === "/")
            e2 = abs + e2;
          else
            e2 = abs + "/" + e2;
          this.cache[e2] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f3, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f3);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            this.emit("error", error2);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f3)] = false;
          break;
        default:
          this.cache[this._makeAbs(f3)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i2], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path8.join(this.root, prefix);
        } else {
          prefix = path8.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f3, cb) {
      var abs = this._makeAbs(f3);
      var needDir = f3.slice(-1) === "/";
      if (f3.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat2 = this.statCache[abs];
      if (stat2 !== void 0) {
        if (stat2 === false)
          return cb(null, stat2);
        else {
          var type = stat2.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat2);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        fs8.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return fs8.stat(abs, function(er2, stat3) {
            if (er2)
              self2._stat2(f3, abs, null, lstat, cb);
            else
              self2._stat2(f3, abs, er2, stat3, cb);
          });
        } else {
          self2._stat2(f3, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f3, abs, er, stat2, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f3.slice(-1) === "/";
      this.statCache[abs] = stat2;
      if (abs.slice(-1) === "/" && stat2 && !stat2.isDirectory())
        return cb(null, false, stat2);
      var c = true;
      if (stat2)
        c = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat2);
    };
  }
});

// node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/rimraf/rimraf.js"(exports, module2) {
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
    var assert = require("assert");
    var path8 = require("path");
    var fs8 = require("fs");
    var glob6 = void 0;
    try {
      glob6 = require_glob2();
    } catch (_err) {
    }
    var _0666 = parseInt("666", 8);
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    function defaults(options) {
      var methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach(function(m2) {
        options[m2] = options[m2] || fs8[m2];
        m2 = m2 + "Sync";
        options[m2] = options[m2] || fs8[m2];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob6 === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    }
    function rimraf(p, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      var busyTries = 0;
      var errState = null;
      var n = 0;
      if (options.disableGlob || !glob6.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, function(er, stat2) {
        if (!er)
          return afterGlob(null, [p]);
        glob6(p, options.glob, afterGlob);
      });
      function next(er) {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      }
      function afterGlob(er, results) {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach(function(p2) {
          rimraf_(p2, options, function CB(er2) {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                var time = busyTries * 100;
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, time);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          });
        });
      }
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, function(er, st) {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, function(er2) {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      if (er)
        assert(er instanceof Error);
      options.chmod(p, _0666, function(er2) {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, function(er3, stats) {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    }
    function fixWinEPERMSync(p, options, er) {
      assert(p);
      assert(options);
      if (er)
        assert(er instanceof Error);
      try {
        options.chmodSync(p, _0666);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      try {
        var stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      assert(typeof cb === "function");
      options.rmdir(p, function(er) {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, function(er, files) {
        if (er)
          return cb(er);
        var n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        var errState;
        files.forEach(function(f3) {
          rimraf(path8.join(p, f3), options, function(er2) {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    }
    function rimrafSync(p, options) {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      var results;
      if (options.disableGlob || !glob6.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob6.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (var i2 = 0; i2 < results.length; i2++) {
        var p = results[i2];
        try {
          var st = options.lstatSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p, options, null);
          else
            options.unlinkSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p, options, er);
        }
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach(function(f3) {
        rimrafSync(path8.join(p, f3), options);
      });
      var retries = isWindows ? 100 : 1;
      var i2 = 0;
      do {
        var threw = true;
        try {
          var ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i2 < retries && threw)
            continue;
        }
      } while (true);
    }
  }
});

// node_modules/tmp/lib/tmp.js
var require_tmp = __commonJS({
  "node_modules/tmp/lib/tmp.js"(exports, module2) {
    var fs8 = require("fs");
    var os = require("os");
    var path8 = require("path");
    var crypto = require("crypto");
    var _c = fs8.constants && os.constants ? { fs: fs8.constants, os: os.constants } : process.binding("constants");
    var rimraf = require_rimraf();
    var RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    var TEMPLATE_PATTERN = /XXXXXX/;
    var DEFAULT_TRIES = 3;
    var CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR);
    var EBADF = _c.EBADF || _c.os.errno.EBADF;
    var ENOENT = _c.ENOENT || _c.os.errno.ENOENT;
    var DIR_MODE = 448;
    var FILE_MODE = 384;
    var EXIT = "exit";
    var SIGINT = "SIGINT";
    var _removeObjects = [];
    var _gracefulCleanup = false;
    function _randomChars(howMany) {
      var value = [], rnd = null;
      try {
        rnd = crypto.randomBytes(howMany);
      } catch (e2) {
        rnd = crypto.pseudoRandomBytes(howMany);
      }
      for (var i2 = 0; i2 < howMany; i2++) {
        value.push(RANDOM_CHARS[rnd[i2] % RANDOM_CHARS.length]);
      }
      return value.join("");
    }
    function _isUndefined(obj) {
      return typeof obj === "undefined";
    }
    function _parseArguments(options, callback) {
      if (typeof options === "function") {
        return [{}, options];
      }
      if (_isUndefined(options)) {
        return [{}, callback];
      }
      return [options, callback];
    }
    function _generateTmpName(opts) {
      const tmpDir = _getTmpDir();
      if (isBlank(opts.dir) && isBlank(tmpDir)) {
        throw new Error("No tmp dir specified");
      }
      if (!isBlank(opts.name)) {
        return path8.join(opts.dir || tmpDir, opts.name);
      }
      if (opts.template) {
        var template2 = opts.template;
        if (path8.basename(template2) === template2)
          template2 = path8.join(opts.dir || tmpDir, template2);
        return template2.replace(TEMPLATE_PATTERN, _randomChars(6));
      }
      const name = [
        isBlank(opts.prefix) ? "tmp-" : opts.prefix,
        process.pid,
        _randomChars(12),
        opts.postfix ? opts.postfix : ""
      ].join("");
      return path8.join(opts.dir || tmpDir, name);
    }
    function tmpName(options, callback) {
      var args = _parseArguments(options, callback), opts = args[0], cb = args[1], tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;
      if (isNaN(tries) || tries < 0)
        return cb(new Error("Invalid tries"));
      if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
        return cb(new Error("Invalid template provided"));
      (function _getUniqueName() {
        try {
          const name = _generateTmpName(opts);
          fs8.stat(name, function(err) {
            if (!err) {
              if (tries-- > 0)
                return _getUniqueName();
              return cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
            }
            cb(null, name);
          });
        } catch (err) {
          cb(err);
        }
      })();
    }
    function tmpNameSync(options) {
      var args = _parseArguments(options), opts = args[0], tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;
      if (isNaN(tries) || tries < 0)
        throw new Error("Invalid tries");
      if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
        throw new Error("Invalid template provided");
      do {
        const name = _generateTmpName(opts);
        try {
          fs8.statSync(name);
        } catch (e2) {
          return name;
        }
      } while (tries-- > 0);
      throw new Error("Could not get a unique tmp filename, max tries reached");
    }
    function file(options, callback) {
      var args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err)
          return cb(err);
        fs8.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err2, fd) {
          if (err2)
            return cb(err2);
          if (opts.discardDescriptor) {
            return fs8.close(fd, function _discardCallback(err3) {
              if (err3) {
                try {
                  fs8.unlinkSync(name);
                } catch (e2) {
                  if (!isENOENT(e2)) {
                    err3 = e2;
                  }
                }
                return cb(err3);
              }
              cb(null, name, void 0, _prepareTmpFileRemoveCallback(name, -1, opts));
            });
          }
          if (opts.detachDescriptor) {
            return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));
          }
          cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));
        });
      });
    }
    function fileSync(options) {
      var args = _parseArguments(options), opts = args[0];
      const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
      const name = tmpNameSync(opts);
      var fd = fs8.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
      if (opts.discardDescriptor) {
        fs8.closeSync(fd);
        fd = void 0;
      }
      return {
        name,
        fd,
        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)
      };
    }
    function dir(options, callback) {
      var args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err)
          return cb(err);
        fs8.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err2) {
          if (err2)
            return cb(err2);
          cb(null, name, _prepareTmpDirRemoveCallback(name, opts));
        });
      });
    }
    function dirSync(options) {
      var args = _parseArguments(options), opts = args[0];
      const name = tmpNameSync(opts);
      fs8.mkdirSync(name, opts.mode || DIR_MODE);
      return {
        name,
        removeCallback: _prepareTmpDirRemoveCallback(name, opts)
      };
    }
    function _removeFileAsync(fdPath, next) {
      const _handler = function(err) {
        if (err && !isENOENT(err)) {
          return next(err);
        }
        next();
      };
      if (0 <= fdPath[0])
        fs8.close(fdPath[0], function(err) {
          fs8.unlink(fdPath[1], _handler);
        });
      else
        fs8.unlink(fdPath[1], _handler);
    }
    function _removeFileSync(fdPath) {
      try {
        if (0 <= fdPath[0])
          fs8.closeSync(fdPath[0]);
      } catch (e2) {
        if (!isEBADF(e2) && !isENOENT(e2))
          throw e2;
      } finally {
        try {
          fs8.unlinkSync(fdPath[1]);
        } catch (e2) {
          if (!isENOENT(e2))
            throw e2;
        }
      }
    }
    function _prepareTmpFileRemoveCallback(name, fd, opts) {
      const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name]);
      const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], removeCallbackSync);
      if (!opts.keep)
        _removeObjects.unshift(removeCallbackSync);
      return removeCallback;
    }
    function _rimrafRemoveDirWrapper(dirPath, next) {
      rimraf(dirPath, next);
    }
    function _rimrafRemoveDirSyncWrapper(dirPath, next) {
      try {
        return next(null, rimraf.sync(dirPath));
      } catch (err) {
        return next(err);
      }
    }
    function _prepareTmpDirRemoveCallback(name, opts) {
      const removeFunction = opts.unsafeCleanup ? _rimrafRemoveDirWrapper : fs8.rmdir.bind(fs8);
      const removeFunctionSync = opts.unsafeCleanup ? _rimrafRemoveDirSyncWrapper : fs8.rmdirSync.bind(fs8);
      const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name);
      const removeCallback = _prepareRemoveCallback(removeFunction, name, removeCallbackSync);
      if (!opts.keep)
        _removeObjects.unshift(removeCallbackSync);
      return removeCallback;
    }
    function _prepareRemoveCallback(removeFunction, arg, cleanupCallbackSync) {
      var called = false;
      return function _cleanupCallback(next) {
        next = next || function() {
        };
        if (!called) {
          const toRemove = cleanupCallbackSync || _cleanupCallback;
          const index = _removeObjects.indexOf(toRemove);
          if (index >= 0)
            _removeObjects.splice(index, 1);
          called = true;
          if (removeFunction.length === 1) {
            try {
              removeFunction(arg);
              return next(null);
            } catch (err) {
              return next(err);
            }
          } else
            return removeFunction(arg, next);
        } else
          return next(new Error("cleanup callback has already been called"));
      };
    }
    function _garbageCollector() {
      if (!_gracefulCleanup)
        return;
      while (_removeObjects.length) {
        try {
          _removeObjects[0]();
        } catch (e2) {
        }
      }
    }
    function isEBADF(error2) {
      return isExpectedError(error2, -EBADF, "EBADF");
    }
    function isENOENT(error2) {
      return isExpectedError(error2, -ENOENT, "ENOENT");
    }
    function isExpectedError(error2, code, errno) {
      return error2.code === code || error2.code === errno;
    }
    function isBlank(s2) {
      return s2 === null || s2 === void 0 || !s2.trim();
    }
    function setGracefulCleanup() {
      _gracefulCleanup = true;
    }
    function _getTmpDir() {
      return os.tmpdir();
    }
    function _is_legacy_listener(listener) {
      return (listener.name === "_exit" || listener.name === "_uncaughtExceptionThrown") && listener.toString().indexOf("_garbageCollector();") > -1;
    }
    function _safely_install_sigint_listener() {
      const listeners = process.listeners(SIGINT);
      const existingListeners = [];
      for (let i2 = 0, length = listeners.length; i2 < length; i2++) {
        const lstnr = listeners[i2];
        if (lstnr.name === "_tmp$sigint_listener") {
          existingListeners.push(lstnr);
          process.removeListener(SIGINT, lstnr);
        }
      }
      process.on(SIGINT, function _tmp$sigint_listener(doExit) {
        for (let i2 = 0, length = existingListeners.length; i2 < length; i2++) {
          try {
            existingListeners[i2](false);
          } catch (err) {
          }
        }
        try {
          _garbageCollector();
        } finally {
          if (!!doExit) {
            process.exit(0);
          }
        }
      });
    }
    function _safely_install_exit_listener() {
      const listeners = process.listeners(EXIT);
      const existingListeners = [];
      for (let i2 = 0, length = listeners.length; i2 < length; i2++) {
        const lstnr = listeners[i2];
        if (lstnr.name === "_tmp$safe_listener" || _is_legacy_listener(lstnr)) {
          if (lstnr.name !== "_uncaughtExceptionThrown") {
            existingListeners.push(lstnr);
          }
          process.removeListener(EXIT, lstnr);
        }
      }
      process.addListener(EXIT, function _tmp$safe_listener(data) {
        for (let i2 = 0, length = existingListeners.length; i2 < length; i2++) {
          try {
            existingListeners[i2](data);
          } catch (err) {
          }
        }
        _garbageCollector();
      });
    }
    _safely_install_exit_listener();
    _safely_install_sigint_listener();
    Object.defineProperty(module2.exports, "tmpdir", {
      enumerable: true,
      configurable: false,
      get: function() {
        return _getTmpDir();
      }
    });
    module2.exports.dir = dir;
    module2.exports.dirSync = dirSync;
    module2.exports.file = file;
    module2.exports.fileSync = fileSync;
    module2.exports.tmpName = tmpName;
    module2.exports.tmpNameSync = tmpNameSync;
    module2.exports.setGracefulCleanup = setGracefulCleanup;
  }
});

// node_modules/tmp-promise/index.js
var require_tmp_promise = __commonJS({
  "node_modules/tmp-promise/index.js"(exports, module2) {
    var { promisify: promisify2 } = require("util");
    var tmp = require_tmp();
    module2.exports.fileSync = tmp.fileSync;
    var fileWithOptions = promisify2((options, cb) => tmp.file(options, (err, path8, fd, cleanup) => err ? cb(err) : cb(void 0, { path: path8, fd, cleanup: promisify2(cleanup) })));
    module2.exports.file = async (options) => fileWithOptions(options);
    module2.exports.withFile = async function withFile(fn, options) {
      const { path: path8, fd, cleanup } = await module2.exports.file(options);
      try {
        return await fn({ path: path8, fd });
      } finally {
        await cleanup();
      }
    };
    module2.exports.dirSync = tmp.dirSync;
    var dirWithOptions = promisify2((options, cb) => tmp.dir(options, (err, path8, cleanup) => err ? cb(err) : cb(void 0, { path: path8, cleanup: promisify2(cleanup) })));
    module2.exports.dir = async (options) => dirWithOptions(options);
    module2.exports.withDir = async function withDir(fn, options) {
      const { path: path8, cleanup } = await module2.exports.dir(options);
      try {
        return await fn({ path: path8 });
      } finally {
        await cleanup();
      }
    };
    module2.exports.tmpNameSync = tmp.tmpNameSync;
    module2.exports.tmpName = promisify2(tmp.tmpName);
    module2.exports.tmpdir = tmp.tmpdir;
    module2.exports.setGracefulCleanup = tmp.setGracefulCleanup;
  }
});

// node_modules/@actions/artifact/lib/internal/status-reporter.js
var require_status_reporter = __commonJS({
  "node_modules/@actions/artifact/lib/internal/status-reporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core();
    var StatusReporter = class {
      constructor(displayFrequencyInMilliseconds) {
        this.totalNumberOfFilesToProcess = 0;
        this.processedCount = 0;
        this.largeFiles = /* @__PURE__ */ new Map();
        this.totalFileStatus = void 0;
        this.largeFileStatus = void 0;
        this.displayFrequencyInMilliseconds = displayFrequencyInMilliseconds;
      }
      setTotalNumberOfFilesToProcess(fileTotal) {
        this.totalNumberOfFilesToProcess = fileTotal;
      }
      start() {
        this.totalFileStatus = setInterval(() => {
          const percentage = this.formatPercentage(this.processedCount, this.totalNumberOfFilesToProcess);
          core_1.info(`Total file count: ${this.totalNumberOfFilesToProcess} ---- Processed file #${this.processedCount} (${percentage.slice(0, percentage.indexOf(".") + 2)}%)`);
        }, this.displayFrequencyInMilliseconds);
        this.largeFileStatus = setInterval(() => {
          for (const value of Array.from(this.largeFiles.values())) {
            core_1.info(value);
          }
          this.largeFiles.clear();
        }, 1e3);
      }
      updateLargeFileStatus(fileName, numerator, denominator) {
        const percentage = this.formatPercentage(numerator, denominator);
        const displayInformation = `Uploading ${fileName} (${percentage.slice(0, percentage.indexOf(".") + 2)}%)`;
        this.largeFiles.set(fileName, displayInformation);
      }
      stop() {
        if (this.totalFileStatus) {
          clearInterval(this.totalFileStatus);
        }
        if (this.largeFileStatus) {
          clearInterval(this.largeFileStatus);
        }
      }
      incrementProcessedCount() {
        this.processedCount++;
      }
      formatPercentage(numerator, denominator) {
        return (numerator / denominator * 100).toFixed(4).toString();
      }
    };
    exports.StatusReporter = StatusReporter;
  }
});

// node_modules/@actions/artifact/lib/internal/http-manager.js
var require_http_manager = __commonJS({
  "node_modules/@actions/artifact/lib/internal/http-manager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils5();
    var HttpManager = class {
      constructor(clientCount, userAgent) {
        if (clientCount < 1) {
          throw new Error("There must be at least one client");
        }
        this.userAgent = userAgent;
        this.clients = new Array(clientCount).fill(utils_1.createHttpClient(userAgent));
      }
      getClient(index) {
        return this.clients[index];
      }
      disposeAndReplaceClient(index) {
        this.clients[index].dispose();
        this.clients[index] = utils_1.createHttpClient(this.userAgent);
      }
      disposeAndReplaceAllClients() {
        for (const [index] of this.clients.entries()) {
          this.disposeAndReplaceClient(index);
        }
      }
    };
    exports.HttpManager = HttpManager;
  }
});

// node_modules/@actions/artifact/lib/internal/upload-gzip.js
var require_upload_gzip = __commonJS({
  "node_modules/@actions/artifact/lib/internal/upload-gzip.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m2 = o[Symbol.asyncIterator], i2;
      return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n) {
        i2[n] = o[n] && function(v) {
          return new Promise(function(resolve2, reject) {
            v = o[n](v), settle(resolve2, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve2, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve2({ value: v2, done: d });
        }, reject);
      }
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs8 = __importStar(require("fs"));
    var zlib2 = __importStar(require("zlib"));
    var util_1 = require("util");
    var stat2 = util_1.promisify(fs8.stat);
    function createGZipFileOnDisk(originalFilePath, tempFilePath) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve2, reject) => {
          const inputStream = fs8.createReadStream(originalFilePath);
          const gzip = zlib2.createGzip();
          const outputStream = fs8.createWriteStream(tempFilePath);
          inputStream.pipe(gzip).pipe(outputStream);
          outputStream.on("finish", () => __awaiter(this, void 0, void 0, function* () {
            const size = (yield stat2(tempFilePath)).size;
            resolve2(size);
          }));
          outputStream.on("error", (error2) => {
            console.log(error2);
            reject;
          });
        });
      });
    }
    exports.createGZipFileOnDisk = createGZipFileOnDisk;
    function createGZipFileInBuffer(originalFilePath) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve2) => __awaiter(this, void 0, void 0, function* () {
          var e_1, _a;
          const inputStream = fs8.createReadStream(originalFilePath);
          const gzip = zlib2.createGzip();
          inputStream.pipe(gzip);
          const chunks = [];
          try {
            for (var gzip_1 = __asyncValues(gzip), gzip_1_1; gzip_1_1 = yield gzip_1.next(), !gzip_1_1.done; ) {
              const chunk = gzip_1_1.value;
              chunks.push(chunk);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (gzip_1_1 && !gzip_1_1.done && (_a = gzip_1.return))
                yield _a.call(gzip_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          resolve2(Buffer.concat(chunks));
        }));
      });
    }
    exports.createGZipFileInBuffer = createGZipFileInBuffer;
  }
});

// node_modules/@actions/artifact/lib/internal/upload-http-client.js
var require_upload_http_client = __commonJS({
  "node_modules/@actions/artifact/lib/internal/upload-http-client.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs8 = __importStar(require("fs"));
    var core10 = __importStar(require_core());
    var tmp = __importStar(require_tmp_promise());
    var stream = __importStar(require("stream"));
    var utils_1 = require_utils5();
    var config_variables_1 = require_config_variables();
    var util_1 = require("util");
    var url_1 = require("url");
    var perf_hooks_1 = require("perf_hooks");
    var status_reporter_1 = require_status_reporter();
    var http_manager_1 = require_http_manager();
    var upload_gzip_1 = require_upload_gzip();
    var stat2 = util_1.promisify(fs8.stat);
    var UploadHttpClient = class {
      constructor() {
        this.uploadHttpManager = new http_manager_1.HttpManager(config_variables_1.getUploadFileConcurrency(), "@actions/artifact-upload");
        this.statusReporter = new status_reporter_1.StatusReporter(1e4);
      }
      createArtifactInFileContainer(artifactName, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const parameters = {
            Type: "actions_storage",
            Name: artifactName
          };
          if (options && options.retentionDays) {
            const maxRetentionStr = config_variables_1.getRetentionDays();
            parameters.RetentionDays = utils_1.getProperRetention(options.retentionDays, maxRetentionStr);
          }
          const data = JSON.stringify(parameters, null, 2);
          const artifactUrl = utils_1.getArtifactUrl();
          const client = this.uploadHttpManager.getClient(0);
          const headers = utils_1.getUploadHeaders("application/json", false);
          const rawResponse = yield client.post(artifactUrl, data, headers);
          const body = yield rawResponse.readBody();
          if (utils_1.isSuccessStatusCode(rawResponse.message.statusCode) && body) {
            return JSON.parse(body);
          } else if (utils_1.isForbiddenStatusCode(rawResponse.message.statusCode)) {
            throw new Error(`Artifact storage quota has been hit. Unable to upload any new artifacts`);
          } else {
            utils_1.displayHttpDiagnostics(rawResponse);
            throw new Error(`Unable to create a container for the artifact ${artifactName} at ${artifactUrl}`);
          }
        });
      }
      uploadArtifactToFileContainer(uploadUrl, filesToUpload, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const FILE_CONCURRENCY = config_variables_1.getUploadFileConcurrency();
          const MAX_CHUNK_SIZE = config_variables_1.getUploadChunkSize();
          core10.debug(`File Concurrency: ${FILE_CONCURRENCY}, and Chunk Size: ${MAX_CHUNK_SIZE}`);
          const parameters = [];
          let continueOnError = true;
          if (options) {
            if (options.continueOnError === false) {
              continueOnError = false;
            }
          }
          for (const file of filesToUpload) {
            const resourceUrl = new url_1.URL(uploadUrl);
            resourceUrl.searchParams.append("itemPath", file.uploadFilePath);
            parameters.push({
              file: file.absoluteFilePath,
              resourceUrl: resourceUrl.toString(),
              maxChunkSize: MAX_CHUNK_SIZE,
              continueOnError
            });
          }
          const parallelUploads = [...new Array(FILE_CONCURRENCY).keys()];
          const failedItemsToReport = [];
          let currentFile = 0;
          let completedFiles = 0;
          let uploadFileSize = 0;
          let totalFileSize = 0;
          let abortPendingFileUploads = false;
          this.statusReporter.setTotalNumberOfFilesToProcess(filesToUpload.length);
          this.statusReporter.start();
          yield Promise.all(parallelUploads.map((index) => __awaiter(this, void 0, void 0, function* () {
            while (currentFile < filesToUpload.length) {
              const currentFileParameters = parameters[currentFile];
              currentFile += 1;
              if (abortPendingFileUploads) {
                failedItemsToReport.push(currentFileParameters.file);
                continue;
              }
              const startTime = perf_hooks_1.performance.now();
              const uploadFileResult = yield this.uploadFileAsync(index, currentFileParameters);
              if (core10.isDebug()) {
                core10.debug(`File: ${++completedFiles}/${filesToUpload.length}. ${currentFileParameters.file} took ${(perf_hooks_1.performance.now() - startTime).toFixed(3)} milliseconds to finish upload`);
              }
              uploadFileSize += uploadFileResult.successfulUploadSize;
              totalFileSize += uploadFileResult.totalSize;
              if (uploadFileResult.isSuccess === false) {
                failedItemsToReport.push(currentFileParameters.file);
                if (!continueOnError) {
                  core10.error(`aborting artifact upload`);
                  abortPendingFileUploads = true;
                }
              }
              this.statusReporter.incrementProcessedCount();
            }
          })));
          this.statusReporter.stop();
          this.uploadHttpManager.disposeAndReplaceAllClients();
          core10.info(`Total size of all the files uploaded is ${uploadFileSize} bytes`);
          return {
            uploadSize: uploadFileSize,
            totalSize: totalFileSize,
            failedItems: failedItemsToReport
          };
        });
      }
      uploadFileAsync(httpClientIndex, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
          const totalFileSize = (yield stat2(parameters.file)).size;
          let offset = 0;
          let isUploadSuccessful = true;
          let failedChunkSizes = 0;
          let uploadFileSize = 0;
          let isGzip = true;
          if (totalFileSize < 65536) {
            const buffer = yield upload_gzip_1.createGZipFileInBuffer(parameters.file);
            let openUploadStream;
            if (totalFileSize < buffer.byteLength) {
              openUploadStream = () => fs8.createReadStream(parameters.file);
              isGzip = false;
              uploadFileSize = totalFileSize;
            } else {
              openUploadStream = () => {
                const passThrough = new stream.PassThrough();
                passThrough.end(buffer);
                return passThrough;
              };
              uploadFileSize = buffer.byteLength;
            }
            const result = yield this.uploadChunk(httpClientIndex, parameters.resourceUrl, openUploadStream, 0, uploadFileSize - 1, uploadFileSize, isGzip, totalFileSize);
            if (!result) {
              isUploadSuccessful = false;
              failedChunkSizes += uploadFileSize;
              core10.warning(`Aborting upload for ${parameters.file} due to failure`);
            }
            return {
              isSuccess: isUploadSuccessful,
              successfulUploadSize: uploadFileSize - failedChunkSizes,
              totalSize: totalFileSize
            };
          } else {
            const tempFile = yield tmp.file();
            uploadFileSize = yield upload_gzip_1.createGZipFileOnDisk(parameters.file, tempFile.path);
            let uploadFilePath = tempFile.path;
            if (totalFileSize < uploadFileSize) {
              uploadFileSize = totalFileSize;
              uploadFilePath = parameters.file;
              isGzip = false;
            }
            let abortFileUpload = false;
            while (offset < uploadFileSize) {
              const chunkSize = Math.min(uploadFileSize - offset, parameters.maxChunkSize);
              if (uploadFileSize > 104857600) {
                this.statusReporter.updateLargeFileStatus(parameters.file, offset, uploadFileSize);
              }
              const start = offset;
              const end = offset + chunkSize - 1;
              offset += parameters.maxChunkSize;
              if (abortFileUpload) {
                failedChunkSizes += chunkSize;
                continue;
              }
              const result = yield this.uploadChunk(httpClientIndex, parameters.resourceUrl, () => fs8.createReadStream(uploadFilePath, {
                start,
                end,
                autoClose: false
              }), start, end, uploadFileSize, isGzip, totalFileSize);
              if (!result) {
                isUploadSuccessful = false;
                failedChunkSizes += chunkSize;
                core10.warning(`Aborting upload for ${parameters.file} due to failure`);
                abortFileUpload = true;
              }
            }
            yield tempFile.cleanup();
            return {
              isSuccess: isUploadSuccessful,
              successfulUploadSize: uploadFileSize - failedChunkSizes,
              totalSize: totalFileSize
            };
          }
        });
      }
      uploadChunk(httpClientIndex, resourceUrl, openStream, start, end, uploadFileSize, isGzip, totalFileSize) {
        return __awaiter(this, void 0, void 0, function* () {
          const headers = utils_1.getUploadHeaders("application/octet-stream", true, isGzip, totalFileSize, end - start + 1, utils_1.getContentRange(start, end, uploadFileSize));
          const uploadChunkRequest = () => __awaiter(this, void 0, void 0, function* () {
            const client = this.uploadHttpManager.getClient(httpClientIndex);
            return yield client.sendStream("PUT", resourceUrl, openStream(), headers);
          });
          let retryCount = 0;
          const retryLimit = config_variables_1.getRetryLimit();
          const incrementAndCheckRetryLimit = (response) => {
            retryCount++;
            if (retryCount > retryLimit) {
              if (response) {
                utils_1.displayHttpDiagnostics(response);
              }
              core10.info(`Retry limit has been reached for chunk at offset ${start} to ${resourceUrl}`);
              return true;
            }
            return false;
          };
          const backOff = (retryAfterValue) => __awaiter(this, void 0, void 0, function* () {
            this.uploadHttpManager.disposeAndReplaceClient(httpClientIndex);
            if (retryAfterValue) {
              core10.info(`Backoff due to too many requests, retry #${retryCount}. Waiting for ${retryAfterValue} milliseconds before continuing the upload`);
              yield new Promise((resolve2) => setTimeout(resolve2, retryAfterValue));
            } else {
              const backoffTime = utils_1.getExponentialRetryTimeInMilliseconds(retryCount);
              core10.info(`Exponential backoff for retry #${retryCount}. Waiting for ${backoffTime} milliseconds before continuing the upload at offset ${start}`);
              yield new Promise((resolve2) => setTimeout(resolve2, backoffTime));
            }
            core10.info(`Finished backoff for retry #${retryCount}, continuing with upload`);
            return;
          });
          while (retryCount <= retryLimit) {
            let response;
            try {
              response = yield uploadChunkRequest();
            } catch (error2) {
              core10.info(`An error has been caught http-client index ${httpClientIndex}, retrying the upload`);
              console.log(error2);
              if (incrementAndCheckRetryLimit()) {
                return false;
              }
              yield backOff();
              continue;
            }
            yield response.readBody();
            if (utils_1.isSuccessStatusCode(response.message.statusCode)) {
              return true;
            } else if (utils_1.isRetryableStatusCode(response.message.statusCode)) {
              core10.info(`A ${response.message.statusCode} status code has been received, will attempt to retry the upload`);
              if (incrementAndCheckRetryLimit(response)) {
                return false;
              }
              utils_1.isThrottledStatusCode(response.message.statusCode) ? yield backOff(utils_1.tryGetRetryAfterValueTimeInMilliseconds(response.message.headers)) : yield backOff();
            } else {
              core10.error(`Unexpected response. Unable to upload chunk to ${resourceUrl}`);
              utils_1.displayHttpDiagnostics(response);
              return false;
            }
          }
          return false;
        });
      }
      patchArtifactSize(size, artifactName) {
        return __awaiter(this, void 0, void 0, function* () {
          const headers = utils_1.getUploadHeaders("application/json", false);
          const resourceUrl = new url_1.URL(utils_1.getArtifactUrl());
          resourceUrl.searchParams.append("artifactName", artifactName);
          const parameters = { Size: size };
          const data = JSON.stringify(parameters, null, 2);
          core10.debug(`URL is ${resourceUrl.toString()}`);
          const client = this.uploadHttpManager.getClient(0);
          const response = yield client.patch(resourceUrl.toString(), data, headers);
          const body = yield response.readBody();
          if (utils_1.isSuccessStatusCode(response.message.statusCode)) {
            core10.debug(`Artifact ${artifactName} has been successfully uploaded, total size in bytes: ${size}`);
          } else if (response.message.statusCode === 404) {
            throw new Error(`An Artifact with the name ${artifactName} was not found`);
          } else {
            utils_1.displayHttpDiagnostics(response);
            core10.info(body);
            throw new Error(`Unable to finish uploading artifact ${artifactName} to ${resourceUrl}`);
          }
        });
      }
    };
    exports.UploadHttpClient = UploadHttpClient;
  }
});

// node_modules/@actions/artifact/lib/internal/download-http-client.js
var require_download_http_client = __commonJS({
  "node_modules/@actions/artifact/lib/internal/download-http-client.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs8 = __importStar(require("fs"));
    var core10 = __importStar(require_core());
    var zlib2 = __importStar(require("zlib"));
    var utils_1 = require_utils5();
    var url_1 = require("url");
    var status_reporter_1 = require_status_reporter();
    var perf_hooks_1 = require("perf_hooks");
    var http_manager_1 = require_http_manager();
    var config_variables_1 = require_config_variables();
    var DownloadHttpClient = class {
      constructor() {
        this.downloadHttpManager = new http_manager_1.HttpManager(config_variables_1.getDownloadFileConcurrency(), "@actions/artifact-download");
        this.statusReporter = new status_reporter_1.StatusReporter(1e3);
      }
      listArtifacts() {
        return __awaiter(this, void 0, void 0, function* () {
          const artifactUrl = utils_1.getArtifactUrl();
          const client = this.downloadHttpManager.getClient(0);
          const headers = utils_1.getDownloadHeaders("application/json");
          const response = yield client.get(artifactUrl, headers);
          const body = yield response.readBody();
          if (utils_1.isSuccessStatusCode(response.message.statusCode) && body) {
            return JSON.parse(body);
          }
          utils_1.displayHttpDiagnostics(response);
          throw new Error(`Unable to list artifacts for the run. Resource Url ${artifactUrl}`);
        });
      }
      getContainerItems(artifactName, containerUrl) {
        return __awaiter(this, void 0, void 0, function* () {
          const resourceUrl = new url_1.URL(containerUrl);
          resourceUrl.searchParams.append("itemPath", artifactName);
          const client = this.downloadHttpManager.getClient(0);
          const headers = utils_1.getDownloadHeaders("application/json");
          const response = yield client.get(resourceUrl.toString(), headers);
          const body = yield response.readBody();
          if (utils_1.isSuccessStatusCode(response.message.statusCode) && body) {
            return JSON.parse(body);
          }
          utils_1.displayHttpDiagnostics(response);
          throw new Error(`Unable to get ContainersItems from ${resourceUrl}`);
        });
      }
      downloadSingleArtifact(downloadItems) {
        return __awaiter(this, void 0, void 0, function* () {
          const DOWNLOAD_CONCURRENCY = config_variables_1.getDownloadFileConcurrency();
          core10.debug(`Download file concurrency is set to ${DOWNLOAD_CONCURRENCY}`);
          const parallelDownloads = [...new Array(DOWNLOAD_CONCURRENCY).keys()];
          let currentFile = 0;
          let downloadedFiles = 0;
          core10.info(`Total number of files that will be downloaded: ${downloadItems.length}`);
          this.statusReporter.setTotalNumberOfFilesToProcess(downloadItems.length);
          this.statusReporter.start();
          yield Promise.all(parallelDownloads.map((index) => __awaiter(this, void 0, void 0, function* () {
            while (currentFile < downloadItems.length) {
              const currentFileToDownload = downloadItems[currentFile];
              currentFile += 1;
              const startTime = perf_hooks_1.performance.now();
              yield this.downloadIndividualFile(index, currentFileToDownload.sourceLocation, currentFileToDownload.targetPath);
              if (core10.isDebug()) {
                core10.debug(`File: ${++downloadedFiles}/${downloadItems.length}. ${currentFileToDownload.targetPath} took ${(perf_hooks_1.performance.now() - startTime).toFixed(3)} milliseconds to finish downloading`);
              }
              this.statusReporter.incrementProcessedCount();
            }
          }))).catch((error2) => {
            throw new Error(`Unable to download the artifact: ${error2}`);
          }).finally(() => {
            this.statusReporter.stop();
            this.downloadHttpManager.disposeAndReplaceAllClients();
          });
        });
      }
      downloadIndividualFile(httpClientIndex, artifactLocation, downloadPath) {
        return __awaiter(this, void 0, void 0, function* () {
          let retryCount = 0;
          const retryLimit = config_variables_1.getRetryLimit();
          const destinationStream = fs8.createWriteStream(downloadPath);
          const headers = utils_1.getDownloadHeaders("application/json", true, true);
          const makeDownloadRequest = () => __awaiter(this, void 0, void 0, function* () {
            const client = this.downloadHttpManager.getClient(httpClientIndex);
            return yield client.get(artifactLocation, headers);
          });
          const isGzip = (incomingHeaders) => {
            return "content-encoding" in incomingHeaders && incomingHeaders["content-encoding"] === "gzip";
          };
          const backOff = (retryAfterValue) => __awaiter(this, void 0, void 0, function* () {
            retryCount++;
            if (retryCount > retryLimit) {
              return Promise.reject(new Error(`Retry limit has been reached. Unable to download ${artifactLocation}`));
            } else {
              this.downloadHttpManager.disposeAndReplaceClient(httpClientIndex);
              if (retryAfterValue) {
                core10.info(`Backoff due to too many requests, retry #${retryCount}. Waiting for ${retryAfterValue} milliseconds before continuing the download`);
                yield new Promise((resolve2) => setTimeout(resolve2, retryAfterValue));
              } else {
                const backoffTime = utils_1.getExponentialRetryTimeInMilliseconds(retryCount);
                core10.info(`Exponential backoff for retry #${retryCount}. Waiting for ${backoffTime} milliseconds before continuing the download`);
                yield new Promise((resolve2) => setTimeout(resolve2, backoffTime));
              }
              core10.info(`Finished backoff for retry #${retryCount}, continuing with download`);
            }
          });
          while (retryCount <= retryLimit) {
            let response;
            try {
              response = yield makeDownloadRequest();
            } catch (error2) {
              core10.info("An error occurred while attempting to download a file");
              console.log(error2);
              yield backOff();
              continue;
            }
            if (utils_1.isSuccessStatusCode(response.message.statusCode)) {
              return this.pipeResponseToFile(response, destinationStream, isGzip(response.message.headers));
            } else if (utils_1.isRetryableStatusCode(response.message.statusCode)) {
              core10.info(`A ${response.message.statusCode} response code has been received while attempting to download an artifact`);
              utils_1.isThrottledStatusCode(response.message.statusCode) ? yield backOff(utils_1.tryGetRetryAfterValueTimeInMilliseconds(response.message.headers)) : yield backOff();
            } else {
              utils_1.displayHttpDiagnostics(response);
              return Promise.reject(new Error(`Unexpected http ${response.message.statusCode} during download for ${artifactLocation}`));
            }
          }
        });
      }
      pipeResponseToFile(response, destinationStream, isGzip) {
        return __awaiter(this, void 0, void 0, function* () {
          yield new Promise((resolve2, reject) => {
            if (isGzip) {
              const gunzip = zlib2.createGunzip();
              response.message.pipe(gunzip).pipe(destinationStream).on("close", () => {
                resolve2();
              }).on("error", (error2) => {
                core10.error(`An error has been encountered while decompressing and writing a downloaded file to ${destinationStream.path}`);
                reject(error2);
              });
            } else {
              response.message.pipe(destinationStream).on("close", () => {
                resolve2();
              }).on("error", (error2) => {
                core10.error(`An error has been encountered while writing a downloaded file to ${destinationStream.path}`);
                reject(error2);
              });
            }
          });
          return;
        });
      }
    };
    exports.DownloadHttpClient = DownloadHttpClient;
  }
});

// node_modules/@actions/artifact/lib/internal/download-specification.js
var require_download_specification = __commonJS({
  "node_modules/@actions/artifact/lib/internal/download-specification.js"(exports) {
    "use strict";
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var path8 = __importStar(require("path"));
    function getDownloadSpecification(artifactName, artifactEntries, downloadPath, includeRootDirectory) {
      const directories = /* @__PURE__ */ new Set();
      const specifications = {
        rootDownloadLocation: includeRootDirectory ? path8.join(downloadPath, artifactName) : downloadPath,
        directoryStructure: [],
        emptyFilesToCreate: [],
        filesToDownload: []
      };
      for (const entry of artifactEntries) {
        if (entry.path.startsWith(`${artifactName}/`) || entry.path.startsWith(`${artifactName}\\`)) {
          const normalizedPathEntry = path8.normalize(entry.path);
          const filePath = path8.join(downloadPath, includeRootDirectory ? normalizedPathEntry : normalizedPathEntry.replace(artifactName, ""));
          if (entry.itemType === "file") {
            directories.add(path8.dirname(filePath));
            if (entry.fileLength === 0) {
              specifications.emptyFilesToCreate.push(filePath);
            } else {
              specifications.filesToDownload.push({
                sourceLocation: entry.contentLocation,
                targetPath: filePath
              });
            }
          }
        }
      }
      specifications.directoryStructure = Array.from(directories);
      return specifications;
    }
    exports.getDownloadSpecification = getDownloadSpecification;
  }
});

// node_modules/@actions/artifact/lib/internal/artifact-client.js
var require_artifact_client = __commonJS({
  "node_modules/@actions/artifact/lib/internal/artifact-client.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var core10 = __importStar(require_core());
    var upload_specification_1 = require_upload_specification();
    var upload_http_client_1 = require_upload_http_client();
    var utils_1 = require_utils5();
    var download_http_client_1 = require_download_http_client();
    var download_specification_1 = require_download_specification();
    var config_variables_1 = require_config_variables();
    var path_1 = require("path");
    var DefaultArtifactClient = class {
      static create() {
        return new DefaultArtifactClient();
      }
      uploadArtifact(name, files, rootDirectory, options) {
        return __awaiter(this, void 0, void 0, function* () {
          utils_1.checkArtifactName(name);
          const uploadSpecification = upload_specification_1.getUploadSpecification(name, rootDirectory, files);
          const uploadResponse = {
            artifactName: name,
            artifactItems: [],
            size: 0,
            failedItems: []
          };
          const uploadHttpClient = new upload_http_client_1.UploadHttpClient();
          if (uploadSpecification.length === 0) {
            core10.warning(`No files found that can be uploaded`);
          } else {
            const response = yield uploadHttpClient.createArtifactInFileContainer(name, options);
            if (!response.fileContainerResourceUrl) {
              core10.debug(response.toString());
              throw new Error("No URL provided by the Artifact Service to upload an artifact to");
            }
            core10.debug(`Upload Resource URL: ${response.fileContainerResourceUrl}`);
            const uploadResult = yield uploadHttpClient.uploadArtifactToFileContainer(response.fileContainerResourceUrl, uploadSpecification, options);
            yield uploadHttpClient.patchArtifactSize(uploadResult.totalSize, name);
            core10.info(`Finished uploading artifact ${name}. Reported size is ${uploadResult.uploadSize} bytes. There were ${uploadResult.failedItems.length} items that failed to upload`);
            uploadResponse.artifactItems = uploadSpecification.map((item) => item.absoluteFilePath);
            uploadResponse.size = uploadResult.uploadSize;
            uploadResponse.failedItems = uploadResult.failedItems;
          }
          return uploadResponse;
        });
      }
      downloadArtifact(name, path8, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const downloadHttpClient = new download_http_client_1.DownloadHttpClient();
          const artifacts = yield downloadHttpClient.listArtifacts();
          if (artifacts.count === 0) {
            throw new Error(`Unable to find any artifacts for the associated workflow`);
          }
          const artifactToDownload = artifacts.value.find((artifact3) => {
            return artifact3.name === name;
          });
          if (!artifactToDownload) {
            throw new Error(`Unable to find an artifact with the name: ${name}`);
          }
          const items = yield downloadHttpClient.getContainerItems(artifactToDownload.name, artifactToDownload.fileContainerResourceUrl);
          if (!path8) {
            path8 = config_variables_1.getWorkSpaceDirectory();
          }
          path8 = path_1.normalize(path8);
          path8 = path_1.resolve(path8);
          const downloadSpecification = download_specification_1.getDownloadSpecification(name, items.value, path8, (options === null || options === void 0 ? void 0 : options.createArtifactFolder) || false);
          if (downloadSpecification.filesToDownload.length === 0) {
            core10.info(`No downloadable files were found for the artifact: ${artifactToDownload.name}`);
          } else {
            yield utils_1.createDirectoriesForArtifact(downloadSpecification.directoryStructure);
            core10.info("Directory structure has been setup for the artifact");
            yield utils_1.createEmptyFilesForArtifact(downloadSpecification.emptyFilesToCreate);
            yield downloadHttpClient.downloadSingleArtifact(downloadSpecification.filesToDownload);
          }
          return {
            artifactName: name,
            downloadPath: downloadSpecification.rootDownloadLocation
          };
        });
      }
      downloadAllArtifacts(path8) {
        return __awaiter(this, void 0, void 0, function* () {
          const downloadHttpClient = new download_http_client_1.DownloadHttpClient();
          const response = [];
          const artifacts = yield downloadHttpClient.listArtifacts();
          if (artifacts.count === 0) {
            core10.info("Unable to find any artifacts for the associated workflow");
            return response;
          }
          if (!path8) {
            path8 = config_variables_1.getWorkSpaceDirectory();
          }
          path8 = path_1.normalize(path8);
          path8 = path_1.resolve(path8);
          let downloadedArtifacts = 0;
          while (downloadedArtifacts < artifacts.count) {
            const currentArtifactToDownload = artifacts.value[downloadedArtifacts];
            downloadedArtifacts += 1;
            const items = yield downloadHttpClient.getContainerItems(currentArtifactToDownload.name, currentArtifactToDownload.fileContainerResourceUrl);
            const downloadSpecification = download_specification_1.getDownloadSpecification(currentArtifactToDownload.name, items.value, path8, true);
            if (downloadSpecification.filesToDownload.length === 0) {
              core10.info(`No downloadable files were found for any artifact ${currentArtifactToDownload.name}`);
            } else {
              yield utils_1.createDirectoriesForArtifact(downloadSpecification.directoryStructure);
              yield utils_1.createEmptyFilesForArtifact(downloadSpecification.emptyFilesToCreate);
              yield downloadHttpClient.downloadSingleArtifact(downloadSpecification.filesToDownload);
            }
            response.push({
              artifactName: currentArtifactToDownload.name,
              downloadPath: downloadSpecification.rootDownloadLocation
            });
          }
          return response;
        });
      }
    };
    exports.DefaultArtifactClient = DefaultArtifactClient;
  }
});

// node_modules/@actions/artifact/lib/artifact-client.js
var require_artifact_client2 = __commonJS({
  "node_modules/@actions/artifact/lib/artifact-client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var artifact_client_1 = require_artifact_client();
    function create8() {
      return artifact_client_1.DefaultArtifactClient.create();
    }
    exports.create = create8;
  }
});

// node_modules/ejs/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/ejs/lib/utils.js"(exports) {
    "use strict";
    var regExpChars = /[|\\{}()[\]^$+*?.]/g;
    exports.escapeRegExpChars = function(string) {
      if (!string) {
        return "";
      }
      return String(string).replace(regExpChars, "\\$&");
    };
    var _ENCODE_HTML_RULES = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&#34;",
      "'": "&#39;"
    };
    var _MATCH_HTML = /[&<>'"]/g;
    function encode_char(c) {
      return _ENCODE_HTML_RULES[c] || c;
    }
    var escapeFuncStr = `var _ENCODE_HTML_RULES = {
      "&": "&amp;"
    , "<": "&lt;"
    , ">": "&gt;"
    , '"': "&#34;"
    , "'": "&#39;"
    }
  , _MATCH_HTML = /[&<>'"]/g;
function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
};
`;
    exports.escapeXML = function(markup) {
      return markup == void 0 ? "" : String(markup).replace(_MATCH_HTML, encode_char);
    };
    exports.escapeXML.toString = function() {
      return Function.prototype.toString.call(this) + ";\n" + escapeFuncStr;
    };
    exports.shallowCopy = function(to, from) {
      from = from || {};
      for (var p in from) {
        to[p] = from[p];
      }
      return to;
    };
    exports.shallowCopyFromList = function(to, from, list) {
      for (var i2 = 0; i2 < list.length; i2++) {
        var p = list[i2];
        if (typeof from[p] != "undefined") {
          to[p] = from[p];
        }
      }
      return to;
    };
    exports.cache = {
      _data: {},
      set: function(key, val) {
        this._data[key] = val;
      },
      get: function(key) {
        return this._data[key];
      },
      remove: function(key) {
        delete this._data[key];
      },
      reset: function() {
        this._data = {};
      }
    };
    exports.hyphenToCamel = function(str) {
      return str.replace(/-[a-z]/g, function(match) {
        return match[1].toUpperCase();
      });
    };
  }
});

// node_modules/ejs/package.json
var require_package = __commonJS({
  "node_modules/ejs/package.json"(exports, module2) {
    module2.exports = {
      name: "ejs",
      description: "Embedded JavaScript templates",
      keywords: [
        "template",
        "engine",
        "ejs"
      ],
      version: "3.1.5",
      author: "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)",
      license: "Apache-2.0",
      bin: {
        ejs: "./bin/cli.js"
      },
      main: "./lib/ejs.js",
      jsdelivr: "ejs.min.js",
      unpkg: "ejs.min.js",
      repository: {
        type: "git",
        url: "git://github.com/mde/ejs.git"
      },
      bugs: "https://github.com/mde/ejs/issues",
      homepage: "https://github.com/mde/ejs",
      dependencies: {
        jake: "^10.6.1"
      },
      devDependencies: {
        browserify: "^16.5.1",
        eslint: "^6.8.0",
        "git-directory-deploy": "^1.5.1",
        jsdoc: "^3.6.4",
        "lru-cache": "^4.0.1",
        mocha: "^7.1.1",
        "uglify-js": "^3.3.16"
      },
      engines: {
        node: ">=0.10.0"
      },
      scripts: {
        test: "mocha"
      }
    };
  }
});

// node_modules/ejs/lib/ejs.js
var require_ejs = __commonJS({
  "node_modules/ejs/lib/ejs.js"(exports) {
    "use strict";
    var fs8 = require("fs");
    var path8 = require("path");
    var utils = require_utils6();
    var scopeOptionWarned = false;
    var _VERSION_STRING = require_package().version;
    var _DEFAULT_OPEN_DELIMITER = "<";
    var _DEFAULT_CLOSE_DELIMITER = ">";
    var _DEFAULT_DELIMITER = "%";
    var _DEFAULT_LOCALS_NAME = "locals";
    var _NAME = "ejs";
    var _REGEX_STRING = "(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)";
    var _OPTS_PASSABLE_WITH_DATA = [
      "delimiter",
      "scope",
      "context",
      "debug",
      "compileDebug",
      "client",
      "_with",
      "rmWhitespace",
      "strict",
      "filename",
      "async"
    ];
    var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat("cache");
    var _BOM = /^\uFEFF/;
    exports.cache = utils.cache;
    exports.fileLoader = fs8.readFileSync;
    exports.localsName = _DEFAULT_LOCALS_NAME;
    exports.promiseImpl = new Function("return this;")().Promise;
    exports.resolveInclude = function(name, filename, isDir) {
      var dirname = path8.dirname;
      var extname = path8.extname;
      var resolve2 = path8.resolve;
      var includePath = resolve2(isDir ? filename : dirname(filename), name);
      var ext = extname(name);
      if (!ext) {
        includePath += ".ejs";
      }
      return includePath;
    };
    function resolvePaths(name, paths) {
      var filePath;
      if (paths.some(function(v) {
        filePath = exports.resolveInclude(name, v, true);
        return fs8.existsSync(filePath);
      })) {
        return filePath;
      }
    }
    function getIncludePath(path9, options) {
      var includePath;
      var filePath;
      var views = options.views;
      var match = /^[A-Za-z]+:\\|^\//.exec(path9);
      if (match && match.length) {
        path9 = path9.replace(/^\/*/, "");
        if (Array.isArray(options.root)) {
          includePath = resolvePaths(path9, options.root);
        } else {
          includePath = exports.resolveInclude(path9, options.root || "/", true);
        }
      } else {
        if (options.filename) {
          filePath = exports.resolveInclude(path9, options.filename);
          if (fs8.existsSync(filePath)) {
            includePath = filePath;
          }
        }
        if (!includePath && Array.isArray(views)) {
          includePath = resolvePaths(path9, views);
        }
        if (!includePath && typeof options.includer !== "function") {
          throw new Error('Could not find the include file "' + options.escapeFunction(path9) + '"');
        }
      }
      return includePath;
    }
    function handleCache(options, template2) {
      var func;
      var filename = options.filename;
      var hasTemplate = arguments.length > 1;
      if (options.cache) {
        if (!filename) {
          throw new Error("cache option requires a filename");
        }
        func = exports.cache.get(filename);
        if (func) {
          return func;
        }
        if (!hasTemplate) {
          template2 = fileLoader(filename).toString().replace(_BOM, "");
        }
      } else if (!hasTemplate) {
        if (!filename) {
          throw new Error("Internal EJS error: no file name or template provided");
        }
        template2 = fileLoader(filename).toString().replace(_BOM, "");
      }
      func = exports.compile(template2, options);
      if (options.cache) {
        exports.cache.set(filename, func);
      }
      return func;
    }
    function tryHandleCache(options, data, cb) {
      var result;
      if (!cb) {
        if (typeof exports.promiseImpl == "function") {
          return new exports.promiseImpl(function(resolve2, reject) {
            try {
              result = handleCache(options)(data);
              resolve2(result);
            } catch (err) {
              reject(err);
            }
          });
        } else {
          throw new Error("Please provide a callback function");
        }
      } else {
        try {
          result = handleCache(options)(data);
        } catch (err) {
          return cb(err);
        }
        cb(null, result);
      }
    }
    function fileLoader(filePath) {
      return exports.fileLoader(filePath);
    }
    function includeFile(path9, options) {
      var opts = utils.shallowCopy({}, options);
      opts.filename = getIncludePath(path9, opts);
      if (typeof options.includer === "function") {
        var includerResult = options.includer(path9, opts.filename);
        if (includerResult) {
          if (includerResult.filename) {
            opts.filename = includerResult.filename;
          }
          if (includerResult.template) {
            return handleCache(opts, includerResult.template);
          }
        }
      }
      return handleCache(opts);
    }
    function rethrow(err, str, flnm, lineno, esc) {
      var lines = str.split("\n");
      var start = Math.max(lineno - 3, 0);
      var end = Math.min(lines.length, lineno + 3);
      var filename = esc(flnm);
      var context2 = lines.slice(start, end).map(function(line, i2) {
        var curr = i2 + start + 1;
        return (curr == lineno ? " >> " : "    ") + curr + "| " + line;
      }).join("\n");
      err.path = filename;
      err.message = (filename || "ejs") + ":" + lineno + "\n" + context2 + "\n\n" + err.message;
      throw err;
    }
    function stripSemi(str) {
      return str.replace(/;(\s*$)/, "$1");
    }
    exports.compile = function compile(template2, opts) {
      var templ;
      if (opts && opts.scope) {
        if (!scopeOptionWarned) {
          console.warn("`scope` option is deprecated and will be removed in EJS 3");
          scopeOptionWarned = true;
        }
        if (!opts.context) {
          opts.context = opts.scope;
        }
        delete opts.scope;
      }
      templ = new Template(template2, opts);
      return templ.compile();
    };
    exports.render = function(template2, d, o) {
      var data = d || {};
      var opts = o || {};
      if (arguments.length == 2) {
        utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);
      }
      return handleCache(opts, template2)(data);
    };
    exports.renderFile = function() {
      var args = Array.prototype.slice.call(arguments);
      var filename = args.shift();
      var cb;
      var opts = { filename };
      var data;
      var viewOpts;
      if (typeof arguments[arguments.length - 1] == "function") {
        cb = args.pop();
      }
      if (args.length) {
        data = args.shift();
        if (args.length) {
          utils.shallowCopy(opts, args.pop());
        } else {
          if (data.settings) {
            if (data.settings.views) {
              opts.views = data.settings.views;
            }
            if (data.settings["view cache"]) {
              opts.cache = true;
            }
            viewOpts = data.settings["view options"];
            if (viewOpts) {
              utils.shallowCopy(opts, viewOpts);
            }
          }
          utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
        }
        opts.filename = filename;
      } else {
        data = {};
      }
      return tryHandleCache(opts, data, cb);
    };
    exports.Template = Template;
    exports.clearCache = function() {
      exports.cache.reset();
    };
    function Template(text, opts) {
      opts = opts || {};
      var options = {};
      this.templateText = text;
      this.mode = null;
      this.truncate = false;
      this.currentLine = 1;
      this.source = "";
      options.client = opts.client || false;
      options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;
      options.compileDebug = opts.compileDebug !== false;
      options.debug = !!opts.debug;
      options.filename = opts.filename;
      options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;
      options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
      options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;
      options.strict = opts.strict || false;
      options.context = opts.context;
      options.cache = opts.cache || false;
      options.rmWhitespace = opts.rmWhitespace;
      options.root = opts.root;
      options.includer = opts.includer;
      options.outputFunctionName = opts.outputFunctionName;
      options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;
      options.views = opts.views;
      options.async = opts.async;
      options.destructuredLocals = opts.destructuredLocals;
      options.legacyInclude = typeof opts.legacyInclude != "undefined" ? !!opts.legacyInclude : true;
      if (options.strict) {
        options._with = false;
      } else {
        options._with = typeof opts._with != "undefined" ? opts._with : true;
      }
      this.opts = options;
      this.regex = this.createRegex();
    }
    Template.modes = {
      EVAL: "eval",
      ESCAPED: "escaped",
      RAW: "raw",
      COMMENT: "comment",
      LITERAL: "literal"
    };
    Template.prototype = {
      createRegex: function() {
        var str = _REGEX_STRING;
        var delim = utils.escapeRegExpChars(this.opts.delimiter);
        var open = utils.escapeRegExpChars(this.opts.openDelimiter);
        var close = utils.escapeRegExpChars(this.opts.closeDelimiter);
        str = str.replace(/%/g, delim).replace(/</g, open).replace(/>/g, close);
        return new RegExp(str);
      },
      compile: function() {
        var src;
        var fn;
        var opts = this.opts;
        var prepended = "";
        var appended = "";
        var escapeFn = opts.escapeFunction;
        var ctor;
        if (!this.source) {
          this.generateSource();
          prepended += '  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n';
          if (opts.outputFunctionName) {
            prepended += "  var " + opts.outputFunctionName + " = __append;\n";
          }
          if (opts.destructuredLocals && opts.destructuredLocals.length) {
            var destructuring = "  var __locals = (" + opts.localsName + " || {}),\n";
            for (var i2 = 0; i2 < opts.destructuredLocals.length; i2++) {
              var name = opts.destructuredLocals[i2];
              if (i2 > 0) {
                destructuring += ",\n  ";
              }
              destructuring += name + " = __locals." + name;
            }
            prepended += destructuring + ";\n";
          }
          if (opts._with !== false) {
            prepended += "  with (" + opts.localsName + " || {}) {\n";
            appended += "  }\n";
          }
          appended += "  return __output;\n";
          this.source = prepended + this.source + appended;
        }
        if (opts.compileDebug) {
          src = "var __line = 1\n  , __lines = " + JSON.stringify(this.templateText) + "\n  , __filename = " + (opts.filename ? JSON.stringify(opts.filename) : "undefined") + ";\ntry {\n" + this.source + "} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n";
        } else {
          src = this.source;
        }
        if (opts.client) {
          src = "escapeFn = escapeFn || " + escapeFn.toString() + ";\n" + src;
          if (opts.compileDebug) {
            src = "rethrow = rethrow || " + rethrow.toString() + ";\n" + src;
          }
        }
        if (opts.strict) {
          src = '"use strict";\n' + src;
        }
        if (opts.debug) {
          console.log(src);
        }
        if (opts.compileDebug && opts.filename) {
          src = src + "\n//# sourceURL=" + opts.filename + "\n";
        }
        try {
          if (opts.async) {
            try {
              ctor = new Function("return (async function(){}).constructor;")();
            } catch (e2) {
              if (e2 instanceof SyntaxError) {
                throw new Error("This environment does not support async/await");
              } else {
                throw e2;
              }
            }
          } else {
            ctor = Function;
          }
          fn = new ctor(opts.localsName + ", escapeFn, include, rethrow", src);
        } catch (e2) {
          if (e2 instanceof SyntaxError) {
            if (opts.filename) {
              e2.message += " in " + opts.filename;
            }
            e2.message += " while compiling ejs\n\n";
            e2.message += "If the above error is not helpful, you may want to try EJS-Lint:\n";
            e2.message += "https://github.com/RyanZim/EJS-Lint";
            if (!opts.async) {
              e2.message += "\n";
              e2.message += "Or, if you meant to create an async function, pass `async: true` as an option.";
            }
          }
          throw e2;
        }
        var returnedFn = opts.client ? fn : function anonymous(data) {
          var include = function(path9, includeData) {
            var d = utils.shallowCopy({}, data);
            if (includeData) {
              d = utils.shallowCopy(d, includeData);
            }
            return includeFile(path9, opts)(d);
          };
          return fn.apply(opts.context, [data || {}, escapeFn, include, rethrow]);
        };
        if (opts.filename && typeof Object.defineProperty === "function") {
          var filename = opts.filename;
          var basename2 = path8.basename(filename, path8.extname(filename));
          try {
            Object.defineProperty(returnedFn, "name", {
              value: basename2,
              writable: false,
              enumerable: false,
              configurable: true
            });
          } catch (e2) {
          }
        }
        return returnedFn;
      },
      generateSource: function() {
        var opts = this.opts;
        if (opts.rmWhitespace) {
          this.templateText = this.templateText.replace(/[\r\n]+/g, "\n").replace(/^\s+|\s+$/gm, "");
        }
        this.templateText = this.templateText.replace(/[ \t]*<%_/gm, "<%_").replace(/_%>[ \t]*/gm, "_%>");
        var self2 = this;
        var matches = this.parseTemplateText();
        var d = this.opts.delimiter;
        var o = this.opts.openDelimiter;
        var c = this.opts.closeDelimiter;
        if (matches && matches.length) {
          matches.forEach(function(line, index) {
            var closing;
            if (line.indexOf(o + d) === 0 && line.indexOf(o + d + d) !== 0) {
              closing = matches[index + 2];
              if (!(closing == d + c || closing == "-" + d + c || closing == "_" + d + c)) {
                throw new Error('Could not find matching close tag for "' + line + '".');
              }
            }
            self2.scanLine(line);
          });
        }
      },
      parseTemplateText: function() {
        var str = this.templateText;
        var pat = this.regex;
        var result = pat.exec(str);
        var arr = [];
        var firstPos;
        while (result) {
          firstPos = result.index;
          if (firstPos !== 0) {
            arr.push(str.substring(0, firstPos));
            str = str.slice(firstPos);
          }
          arr.push(result[0]);
          str = str.slice(result[0].length);
          result = pat.exec(str);
        }
        if (str) {
          arr.push(str);
        }
        return arr;
      },
      _addOutput: function(line) {
        if (this.truncate) {
          line = line.replace(/^(?:\r\n|\r|\n)/, "");
          this.truncate = false;
        }
        if (!line) {
          return line;
        }
        line = line.replace(/\\/g, "\\\\");
        line = line.replace(/\n/g, "\\n");
        line = line.replace(/\r/g, "\\r");
        line = line.replace(/"/g, '\\"');
        this.source += '    ; __append("' + line + '")\n';
      },
      scanLine: function(line) {
        var self2 = this;
        var d = this.opts.delimiter;
        var o = this.opts.openDelimiter;
        var c = this.opts.closeDelimiter;
        var newLineCount = 0;
        newLineCount = line.split("\n").length - 1;
        switch (line) {
          case o + d:
          case o + d + "_":
            this.mode = Template.modes.EVAL;
            break;
          case o + d + "=":
            this.mode = Template.modes.ESCAPED;
            break;
          case o + d + "-":
            this.mode = Template.modes.RAW;
            break;
          case o + d + "#":
            this.mode = Template.modes.COMMENT;
            break;
          case o + d + d:
            this.mode = Template.modes.LITERAL;
            this.source += '    ; __append("' + line.replace(o + d + d, o + d) + '")\n';
            break;
          case d + d + c:
            this.mode = Template.modes.LITERAL;
            this.source += '    ; __append("' + line.replace(d + d + c, d + c) + '")\n';
            break;
          case d + c:
          case "-" + d + c:
          case "_" + d + c:
            if (this.mode == Template.modes.LITERAL) {
              this._addOutput(line);
            }
            this.mode = null;
            this.truncate = line.indexOf("-") === 0 || line.indexOf("_") === 0;
            break;
          default:
            if (this.mode) {
              switch (this.mode) {
                case Template.modes.EVAL:
                case Template.modes.ESCAPED:
                case Template.modes.RAW:
                  if (line.lastIndexOf("//") > line.lastIndexOf("\n")) {
                    line += "\n";
                  }
              }
              switch (this.mode) {
                case Template.modes.EVAL:
                  this.source += "    ; " + line + "\n";
                  break;
                case Template.modes.ESCAPED:
                  this.source += "    ; __append(escapeFn(" + stripSemi(line) + "))\n";
                  break;
                case Template.modes.RAW:
                  this.source += "    ; __append(" + stripSemi(line) + ")\n";
                  break;
                case Template.modes.COMMENT:
                  break;
                case Template.modes.LITERAL:
                  this._addOutput(line);
                  break;
              }
            } else {
              this._addOutput(line);
            }
        }
        if (self2.opts.compileDebug && newLineCount) {
          this.currentLine += newLineCount;
          this.source += "    ; __line = " + this.currentLine + "\n";
        }
      }
    };
    exports.escapeXML = utils.escapeXML;
    exports.__express = exports.renderFile;
    exports.VERSION = _VERSION_STRING;
    exports.name = _NAME;
    if (typeof window != "undefined") {
      window.ejs = exports;
    }
  }
});

// src/template/index.ts
var template_exports = {};
__export(template_exports, {
  default: () => template_default
});
var template, template_default;
var init_template = __esm({
  "src/template/index.ts"() {
    template = { "html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <title>Visual Snapshots</title>\n\n  <head>\n    <script>\n      const __images = <%- images %>\n    <\/script>\n\n    <style>\n      body {\n        margin: 0;\n        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',\n          Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n          'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n          'Noto Color Emoji';\n        color: #39012d;\n      }\n\n      .app {\n        display: flex;\n        flex-direction: column;\n        height: 100vh;\n        overflow: hidden;\n      }\n\n      main {\n        overflow-y: auto;\n        flex: 1;\n        background-color: #f7f7f7;\n      }\n\n      .snapshots {\n      }\n\n      header {\n        display: flex;\n      }\n\n      .top-nav {\n        display: flex;\n        justify-content: flex-start;\n        align-items: center;\n        flex: 1;\n      }\n\n      .top-nav a {\n        display: flex;\n        align-items: center;\n        height: 100%;\n        padding: 0 12px;\n        color: #39012d;\n        text-decoration: none;\n      }\n\n      .top-nav a.selected {\n        font-weight: bold;\n        background-color: rgb(244, 56, 47);#f7de54;\n      }\n\n      .no-changes {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        padding: 24px;\n        font-size: 3em;\n      }\n\n      .snapshot-header {\n        display: grid;\n        grid-auto-flow: column;\n        justify-content: space-between;\n        align-items: center;\n        grid-gap: 12px;\n        position: sticky;\n        top: 0;\n\n        color: #e2e2e2;\n        font-weight: normal;\n        margin: 0;\n        padding: 12px;\n        background-color: rgb(244, 56, 47);\n        box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.4);\n        z-index: 1;\n      }\n\n      .button-bar {\n        display: grid;\n        grid-auto-flow: column;\n        grid-gap: 6px;\n      }\n      .button {\n        cursor: pointer;\n        padding: 6px 12px;\n        border-color: #1c948e;\n        border-radius: 4px;\n        border-width: 1px;\n      }\n      .button.selected {\n        cursor: default;\n        color: white;\n        background-color: #1c948e;\n      }\n\n      .button.disabled {\n        cursor: default;\n        opacity: 0.2;\n      }\n\n      .image-wrapper {\n        padding: 12px;\n        background-color: #39012d;\n      }\n\n      .image {\n        max-width: 100%;\n      }\n    </style>\n\n    <script type=\"module\">\n      import {\n        html,\n        Component,\n        render,\n      } from 'https://unpkg.com/htm/preact/standalone.module.js';\n\n      function cleanSelector(str) {\n        return str.replace(/[^a-z-_]+/gi, '-');\n      }\n\n      const States = ['Diff', 'Original', 'New'];\n      const IMAGE_DIRS = ['diffs', 'original', 'changed', 'new'];\n\n      const Snapshot = props => html`\n        <div id=${cleanSelector(props.image)}>\n          <h3 class=\"snapshot-header\">\n            ${props.image}\n\n            <div class=\"button-bar\">\n              ${props.buttons}\n            </div>\n          </h3>\n          <div class=\"image-wrapper\">\n            <img\n              loading=\"lazy\"\n              tabindex=\"0\"\n              class=\"image\"\n              key=\"${props.image}\"\n              alt=\"${props.image}\"\n              src=\"${props.getSource(props)}\"\n              onLoad=\"${props.onLoad}\"\n              onClick=\"${props.onClick}\"\n              onKeyDown=\"${props.onKeyDown}\"\n              onFocus=\"${props.onFocus}\"\n            />\n          </div>\n        </div>\n      `;\n\n      class App extends Component {\n        state = {\n          images: {},\n          thresholds: {},\n          active: 0,\n        };\n\n        constructor() {\n          super();\n          window.addEventListener(\n            'load',\n            event => {\n              ['added', 'changed', 'missing'].forEach(type => {\n                const el = document.querySelector(`[data-type=\"${type}\"]`);\n                el && this.createObserver(el);\n              });\n              this.setActive(0);\n            },\n            false\n          );\n        }\n\n        createObserver = el => {\n          let observer;\n\n          let options = {\n            root: document.querySelector('.app'),\n            rootMargin: '0px',\n            threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1],\n          };\n\n          observer = new IntersectionObserver(this.handleIntersect, options);\n          observer.observe(el);\n        };\n\n        handleIntersect = (entries, observer) => {\n          const entry = entries.forEach(e => {\n            this.setState(s => ({\n              thresholds: {\n                ...s.thresholds,\n                [`${e.target.dataset.type}`]: !e.isIntersecting\n                  ? -1\n                  : e.intersectionRatio,\n              },\n            }));\n          });\n        };\n\n        handleImageLoaded = e => {\n          if (!this.state.width) {\n            this.setState({\n              width: e.target.width,\n            });\n          }\n        };\n\n        navigate(img, direction) {\n          this.setState(state => ({\n            images: {\n              ...state.images,\n              [img]: ((state.images[img] || 0) + direction) % 3,\n            },\n          }));\n        }\n\n        handleSelectState = (img, newViewState) => {\n          this.setState(state => ({\n            images: {\n              ...state.images,\n              [img]: States.indexOf(newViewState),\n            },\n          }));\n        };\n\n        handleImageClick = (img, i, e) => {\n          this.navigate(img, 1);\n          this.setActive(i, {noScroll: true});\n        };\n\n        handleMainKeyDown = e => {\n          if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {\n            e.preventDefault();\n            e.stopPropagation();\n            const {added, missing, changed} = __images;\n            const increment = e.key === 'ArrowDown' ? 1 : -1;\n\n            const all = [...changed, ...added, ...missing];\n            const active =\n              (this.state.active + increment + all.length) % all.length;\n            this.setActive(active);\n          }\n        };\n\n        handleKeyDown = (img, e) => {\n          const direction =\n            e.key === 'ArrowRight' ? 1 : e.key === 'ArrowLeft' ? -1 : null;\n\n          if (direction) {\n            e.preventDefault();\n            this.navigate(img, direction);\n          }\n\n          if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {\n            e.preventDefault();\n          }\n        };\n\n        setActive(active, {noScroll} = {}) {\n          const {added, missing, changed} = __images;\n          const all = [...changed, ...added, ...missing];\n          this.setState({\n            active,\n          });\n          const target = document.querySelector(\n            `#${cleanSelector(all[active])}`\n          );\n\n          if (target) {\n            target.querySelector('img')?.focus();\n            if (!noScroll) {\n              target.scrollIntoView({\n                block: 'start',\n                inline: 'nearest',\n                behavior: 'smooth',\n              });\n            }\n          }\n        }\n\n        render({page}, {todos = []}) {\n          const {added, missing, changed} = __images;\n          const active = Object.entries(this.state.thresholds).reduce(\n            (acc, [type, value]) => (value > acc[1] ? [type, value] : acc),\n            [null, -1]\n          );\n          const hasNoChanges =\n            !added.length && !changed.length && !missing.length;\n          return html`\n            <div class=\"app\">\n              <header>\n                <img\n                  height=\"60\"\n                  src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpMwidZAAAoeElEQVR4Ae1dC5hcRZU+/ZqedyYzmUwmL0ISwBAgQMIzEBAFFHBXZPGx3/pg15Vd1l1fKAoBowFE3Ygrqy5CZL/d1WVVdHHxgfIMIIEoAiEREkhCHjN5T+Y906/Z/9yZDklIp+/tqupbt++pfJ3u6a5bdeqvqr+qTp06RSRBEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBCoFgYiJgmzcuLGpuro6YSJtSVMQ0InApEmTOLl9kUgkrTPdoKSljQBGRkYifX19700kEh/OZrPzcrlcQ1BAEDnDiwAGqsjQ0ND9y5Yt+8iSJUsyYUNCCwE8+uij1fPnz78DYH40Ho9TKpUiEELYsJTyBhQBDFo0ODi4uKGh4ZaAFqFksbUQQH9//9La2trFAFE6fslVIQ/6hUA0GqVYLIaJwNAHGhsb/9cvOfzIV5kAuru7Z2P99IeqqqpGTP39KIPkKQgoI8CzgHQ63QkSeHtLS8ta5QQDkkBUg5wXY/SXzq8BSEnCPwTQ+SmZTLbj9f0tW7Y0+ydJeXNWJgBMnWbiVV6pJTdBwAACw8PDhMHsjObm5tuhw1LuGwZE1J6kciEx/a/SLpUkKAj4hACWAITlwIeg1/qMTyKUNVtlAoC0ou4va5VJZiYR4N0rbGETdrO+vGfPnotN5mVD2soEAMCEAGyoSZFBGwKszMbOQHVNTc2dO3fuPEZbwhYmpEwAFpZJRBIElBEYUwoeBRK4G2NcxRq1CQEoNxVJoFIRYH1AfX39ooGBga+DBJS3zG3ESQjAxloRmaxBgI3boBS8uqen5xprhNIoiDIBYK0kOgCNFSJJ2YUAq7hYKQj7gNv27dt3gV3SqUujTADqIkgKgoDdCLBSELYu9ZgJ3NXV1TXDbmm9SScE4A0viR1SBPiAGw67zcRMYPnLL79cMUpBIYCQNmgptncEWCkIErhg2rRpt3p/2s4n4qpileMAUCwSoWgkihcRLA9VRZbnKxyBDNbs/DIRxiwFr4E+4KWmpqY7TeRRzjSVCcCUsNzNq8bOGGzv76dN3ftoa28vDWTSMD0UvaMp3IOebg5Ku7MmT6Vjx7dQOqf/dOqYUjAKfcDX9u7duxbnBp4IMmbKBIARWXtvTOB8dhYV+eCmDfTTdS/Ts50d6Pw9lBvJ4RVkuEV20wikszk6c/IUuvfP3kPjk0nKGDBU5VkvH3/HDthdIIGLQAKbTZfLVPrKBKBbsGp4FHpx10667Zmn6DcbN9BgOkOJWJTiIIX8MkB3npJe5SDA7WRlxzZa8tTj9M23XUw8k+RRW3dgpSCsBI/DFuG/If33YCAc0p1HOdJTVgLqBJen/L947VV638/vo/vXrXPKX5OIO52/HGBIHpWBALeZH6x9ie5Z/QIlDR5VZyMhKAXfifelQUVOmQB0FZxH/l9teJWufvAB6uzrI65ECYJAqQhww7716Sfoqa1bjJIA+xCAjcCn4BD3I6XK6udzygSgQweQiMboxZ076XOPPUR98MzC0zgJgoAKAuznbw+27T73+MO0A0pkU21qbAYcQ37fwPHhM1Vk9uNZ33sar9EyUO7xmn9jT7exivIDXMnTXwR4+v/8jh3QB6yAOe+IsS3kTCbDSkHoHJPf37179xR/S+0td2UCYDtplcDr/kdf30S/gca/Ni53iahgKc++GQFHH/DyGrp79fOUxEzTVBhzJzYHLsW+i1lBYLxkKROADkDvW/cnR9uvIy1JQxA4FIEEjMduW/kkrdj6OiWhazIVWCmIWcC7cHJwsak8dKergwBK3mNhC7/O/j5atb3D2erTXThJTxBgBKJoZ11Q1l33+CO0DfYkpvQBnNfYmYEv9Pb2vo//tj3oIICSy8j7+hth4be5x2yllCygPFgxCLA+gBXNi594zDETNmVSzktipA2XgvE7cHLwZNsBNDcfclFytu1n814232SWdhM4blpR7+AmH4ljHwI8Y1QZvVkfcB8sS0+e2EafnH8GDWXNXAU45k6sFWSwvLOz8x3t7e277ENzVCIdBFDyEoBZuB8WVW4Dd/7J9fU0b6Jzo6vbxyReBSDAA0RnXy89v3OHUmnYzPxrzz5Nx7e00kVHz6QhaPBNBFYKwlLwVKTNSsEPoK1befuwDgJQws8Le/DhjgXtU+h7F13imHd6eVZJSHnYdwR4Cv+z9a/Qxx78hZIsTCQDGHS+sOIROmZ8M01vbDQ2o+STg1AKXgGl4PUQ+ktKght62FcdQKll4sWCvMKJQalt5sDn4iCTdV176PonHnFmAG6Xnwem4eYzGwnxcgAzAVYKXuHmmXLHCSQB8Mgvr3BioKuDJGNxeuC19fStP67CDpQ5+wBWCoIIklgCfBvmwifqkl9XOsoEAG2nzMR11YakU1YE2AT99t8/Q78EEfBZFFOBLQVxaKgNJLC8o6Njgql8SklXmQBKyVSeEQRsQICn/il0zutXPErru/YanQmMKQVPa2xs5ItHzU05PAKrTACqpsAe5ZXogoBWBOKYBbza1UWfh5HQANbrpvQBLPSYUvCvoA/4rNZCKCSmTAAKecujgoAVCLB9wG82vUbLVq0k3iY0FVgpyMsB7Ax8EbcPX2YqHy/pKpdWLgbxArfEtRUB1gd854+/d7YaTeoDxiwFq6EP+C6ODx/vNx7KBOB3ASR/QUAHAo4+AL7+boSp8Nrdu/Y7pNWR9qFpjFkKToVi8C7MCsYd+ns5/1YmAJ7SSBAEKgEBNjPe3NsNxzQPUw97+oGS0FRgfQDsA86GPuD2K6+80jeloDIBmAJI0hUEVBHgDs3m414C2wc8jmPDX4GDGvYqZI4CRpWCmAVctXz58k94kVFnXGUCEDsAndUhaelCgC8GOWFCKy2Y1E7DmNp7CawPWP7i8/QzHBwy6T+AlYKsE4BScGl3d/fFXmTUFVeZAHQJIukIAjoR4HslGnEvwG3nvY3a6+o93RTE+gAmkBueeJRegov6/AU1OuXLp8V3DEAhWIvZxl07duyYmf++XO/K5k9B1wHwNC+ObaAozEEjRid85arSysyHp+JV1d48baVwSci81jb64sJz6R8fetDTsXNePnTg9CE7Ff3Bpe+m+qoq57IaE+iyUhCuxKahLd65Zs2ay+fOndtnIp/DpalMAIdLNAjfgXUpkUzQns499OKTf6TNazdQf+9AEEQPpYxxMMDqJPxPsiGth2X9MM78/+WcE2j1rl30bWzz8alCt8HRB2zeTDc//SR99fy3UQSzCg9Zu83GiTemFHz71KlTv44v/t7TwwqRQ0kAUdw0lMPo8ONv/pB+/K//Tdu3dVJ6JIURQs3BqUI9yKNFEIhQmvpmzia6+vwiMQ/+mTssLwc+f8bZ9NLunfT46/AL6OHOiWQ8Rve89AKdBCciHz7hJGP+A1jqMRK4GjsDqxsaGr5zcEnM/BU6AuCRP5vJ0h2fWEb3/cePiCf+8UickpHk6PlaMzhLqooIRKiKUklvS4B8lnl9wFehD3jv/ffRNkzt3XoWyusDvvy7FTQXSsX5bZM8KxXzchR7H1MKRnDRyFdBAmtBAo8Ve0b1dx1KQFOzItWyHfb5BBrRT+/4H3T+eymBjs+dX0LlI5CCso078NJzz3c6v5ftQSaLnQMDzsU1u+D5NwZflqYCKwVx83A90r8bPgVnmMonn665kuRzsOg9hunc9k0dmPr/wOn4Znd5LSq4iOIgMAyjtXcfcxz9w6kLiG8R9hJYd/BMRwfxTICDSfsA9ixcV1c3C0TwPcwKar3I6TVuyAggTn94ZBXt2LsDU3/3yiCvoEp8OxFw9AHY3rv2tDPpwhlHe76Lgg8N/dea1fTv0AmYtA9g9PiOAewMXAh3YreCBIzxTagIgLf8Nry4jnL4JyGcCLA+oDZRBfuAC2jW+Cbs93szEuIOcwt2BZ7u2IodBbPLR1YKggQ+Dn3A35iqLWUCCJIlINNo775eI/fFm6ogSVc/Ammss49rbqFbF10AI5+4J3NhHkT2DA065wU6+90rE0spxZhSMIZ7B/957969C0tJo9gzygRQLAPrfg+UytI69CpGoEHoAy7FtiLfD+D1ngnWBzy3fTsteXKFs8XIO0umAhvaYVdgHEjgbhwfnqY7H2UCYAGZqSQIAkFDgDv+JxacTpeBCAbT3k61sj7gR6+spbtf/KPRS0cZU1YKYinwFpwZ4DsGqnXirEwAOoWRtASBciLAW4HVGM1vWfRWOq6lhYZBCF4C32z1lZVPOacHvVgYeskjH5eVgjg+fCnev5T/Tse7MgFgeiLDv46akDR8QYBnATObxtNt0AfUwTOwF/sAvtuyG34D2H/AVlw6atKdGIPDMwHoIK7FycEP6gJLmQB0CSLpCAJ+IcDXg104YyZ99vSzStIHvIRzBouffAzPjvDJPmPFGHMnFoXi/ZsggdN1ZCQEoANFSSPwCPC1c9ecvIAuh6FQKfqAn657BT4FV0EfYLZLsc4NuoBmzLyX4/hwmyrwZqVVlU6eFwTKhABP/atwSOzmc8+nua2tnu39efr/z7h09KHXN0KvYNY+gO8YgFLwhPr6elYK4hBL6UEHAYgOwAX+rF7K4jBpGq9hNLYhvAbHXvyZv8N+imOi5E0V5SJzieIKAdYHTG9opGVvfTuNgzMRb/oAXDqKc/3XQh+wqWefcX0AGwlhJnA5jISWuCpcgUhmqapApmH6mjt9BhRZg7Vhc3OCps+qoikzEjR+QpyqayPEJ5AH+nO0e3uWtm5M0dYNw9SFv5kQEnhGB0OHCW/Vsg7BSOicqdPphrPOoS/gshAvF4XwpaPr9+51bhq6+x2XeT505EV23nof8y58LUjgOZwc/LGX5/NxhQDySGh+59Gcw4wpVXTOO+ppwbl1NGtOkuob2QNRBMYdOFDC+0iIxiNNFrfHZ8AUe3elad3qFD39cD+tfLiXtndncXCJnGPLmkWU5AogwCcH//rEefT7zg66909riff83QaO+3+4a/CO51bR56BU9OqP0G0+HI+VgtAFxKF4/PoLL7zwy3nz5vV7eZ7jui9ZgZSxLSFLgAOwyU/15xxbTe/5SBOdc1EDjWseHcczaXiUAVr8nkGHP9S1DeuPWtsTNHl6FS16Zz1t3zqefntfL93/g27atjstM4IDcDb5kUdXPgK89Jzz6eW98BgFv4Be9vlZH7AMl46e2DqRLoGREe8ymAp8fBjyNkInUNLpNplhaqwZXt/XVUXpHz7TSrffO40u+0AT1TXgAsrhEefFdiZMAIUC/8ZnU4aHML1LjdDE9ir68Kda6I6fTKX3XNnkLAd4SSHBPALsFLS9vp6+Bldg46urndHWba7OJSPo9LyEcC4dhZdhw4HHnZKCMgHwNEQCOi1671sw6n/9P6fQX328mWrrIujIOHeoAE82C+UgyKBtahVde1sbLV42iSaMizmKRMHcPAI8fV84ZRotPvMcz+dHeQaRv3R0ENM9L7oE8yV7IwdlAngjqfB+4s6/8Ox6uu2eKXTiaTVOp1Xp+IcimYVugJcNF18xjm5dPpVmgBA4TwnmEWAnIledeLLjWLQU+4DfbNzgXDrq1gWZ+RIdnIMyAYRdB8Ad8dyF9XTTv2J0bos7U/2DIdb319Bgjo4/tZqW3jmZjgYJ8JJDglkEHIShhF2ycBGd3j7Zs1IvAdsC9kZ8//pXyOSlo6WioEwApWZcCc9xBzzp+Gq6blkbNWBqzqO06cD6hFnHJ+mG2ydRS2MMtgUSTCOQxXSutbbW0QdMxDvrB9wGRx+ApcRi59LR3UYvGXEr04HxlAkgrDoAbgLNdTH69C1tzshfjs6fr7gU9AInnV5D11zf6vimc98c8ynIu1cEWB9wGmYAN529yPN6nqf/m7q76TpcMtIznDJ66ajXcikTgNcMKyU+a+M/9E8TaA6m5DwqlzuwcvCiKxrp4ssacKdB+fMvd3lLyY8P5vA9f7pebK9xFe4G+Nt5p3heCrB9wCOvb6KvPvs7EIg97miV7QBKqZigP8NT/5NPqMU2XyOlfej8jB/3eW7gH/ynFnp2RT919eTEavCAhsVXe/emhum5HZ3Onj7v7esIMRhvXTRjFj38+kba0NXl3CDsNl2+ZOTO5/9AJ+OSkfe/5Xhir0R+ByGAEmqALxP5i4/yHn/U0fiXkISWR3jZcdQxVXTpe5vonrv24HITc0dRtQhcxkR42r129y5cBPIT7bnyCJ6BDTf7B/QSWB/A+oObnnyM5jRPoBNw6IitDv0MOghAD7X6iYKHvHn0n4v9/jMvqPNl6n+oqDkMIhdf2Ug/+4991J+SWcCB+PCUvQ8HdEyEUvf1mZhGLx19iH542eXUYPDSUTfl9kZhblKs8Djw+UCLLmlwRn9Ns0olxPj8wNSjE3TymTWiCzgMktxRTbwOk5Xrr9id+BNbtjj6AH7Iz3mbEIDraoOZLuI2xqO0YFEt+TxzO0jqRCKKGUk9tMujMh70o/xhJQIJVNbvtm2FniJl1ItQscILARRD6IDfc5j+80EdPtLL1nm2hEwmRyedVk115m3ObSlyRchR6jJCZ+F1EIA9PUEnModJC6b5NANKt9q66BEP9RzmUaNfsV3KBJwibJsCp5YgKQmCgFsEdBCA27wqIt60WQmc47esKOjz1TURHBpK4KIKy2QTcaxGQLkps5PCsATuWy1tCX+1NocBm5WRiaoINcHvgPT/wwAkXxVEQJkACqZcoT/wMV8/tbaFYI1BqVRdK9VZCB/5/vAIKLcYPg2oy8rq8CJa9q2NvZ8hslUuy6pPxDkYAR2GQAenWOF/DfbDrZeFZeRdCT4uXNEBw9UIW9+ZqAAQ6Ai0qbls6Riyi0e2EgxSUCaAMJ0G5EF27y7oPEw0QIVWwxbAbBbc05Wr4IlAlKIpXIqxq8cI/mw1WNdYR+MntmCHxzsJ8MKQff/t7O/z7D1IoeqVH1UmAGUJApbA1g0pq7YAHfhAAEMDI7RjW9oxBgoYpK7ExaVbVPvaTjr6Ww+7iu810vDIMEyqL6VPf/KDwHLI6+POOf9nOrfRR3/9AGVgJWbDHr+bQigTQJg8ArGl3evrUzQ4kKMEXHvbYArMlcxTz707M/AinMGJQPxRoSGKsTWS8t453cCRzg1RLWZRrTV1NFzCucoq+HlvSmq9uduN2MpxlAlAWYIAJcCda+smvrwjRbPnVpfFA5AbeOIwBV79+0Hqh0Vg5Xb/USR4JmAmgNCRNGt4siUwOz/Dy4igBWWNRZh0AAzWPpy4e37lkHOxhy2VzQeCnn28H0dUR0oYu2wphcjhBwLKBOCH0H7mydPtxx7oddbcNhy/53sod2xN0XNPDjgXh/iJjeQdPASUCSBMOgCuXnYGsmb1ID33FDocrO/8DnHcG/bQ//bS7n4onvwWRvIPHALSZjxWGQPGrsB/dFeXc/GHn7MA3ApH2zan6P7/7Mb9gf6TkUcoJboFCAgBlFAJ7Hpr1aoB+u1Pe6mq2qeOh2zZJube7+yjbXuw/VdCOeQRQUAHAQRP9aml3kfo+9/YQxtfTvmyFEiCeFb8qo9+/j+4i15Gfy01GsZEdBBAGHFzdAEdGHlvX7yD+nCFNyvjyhUSyQi9tmaY7vjiTud2IKnEciFfeflI21GoU14KPIOlwDeu3wkHoVAQYk1uOrDicTvW/bd8ajttxZXhcWP74qZLIunbgIAQgGItMAk8+Ose+tpnt1N/b9bociBZHaXNr6boxr/rpDWvDIkbcMW6k8ehR9IAQkh1AG8gBx9B9Ktf9tCNH+ugTeuGidfnOpfl7OqPlY0rH+mjz1+1jV76k3T+N9CXTyoI6CAAlfwr5tn8cuDTf7mN/u+HPThWik6LtboKEbCWn8mkd1+OvveV3XQDCGZzR0pG/oppNf4XpIyqK/8La1oCJoFdXRm67YZOevjnPXTFVU204Jw6qoEXIXYjzmf2i5mLc6dnXQK/d+3J0opf9NFP7umidRuHHW2/bWt+WNAD1uCfQUANUUTBF4DptmUqfSEAzciO7sdH6OmV/fTcMwM0Z24NnXdpA51yVjVNgzvxGrjt4lkBd/D9+jv0Ifbsy8fQe/ZlaeMrw/TMYwP05K/7aONWaBcRmFxsCtxhoPGg4bYmyjZUjzrqsElAj7IM0hANTxqHSgjXilYIwGNDcRudOyy7lXhxzQA9/9IAjcOJvfZpVc5dftNwk09TaxxkgDiIxF6GdnWmaQtOGfJx4x2dGRoAG/DxY9tG/FFvHBHqmj+b9px9LKVaGyhXjWbkMJpbdOyLN4Bru7vbpoduFiAEYLAt8iDvnM9HRx7A9H/9xiF6ecPoefZDxxke3x2XUnhn7zK2jfijMOHIKywgOq9YQPvOmOWMlhHclRbBMeSg30kUg7chWQKM1rLX/w9ty16fD0X8PBmUwVTAKJ673jmP9p01G445wuMO3iigPifO7VKCIFAUAVb2Dba30N6F6Pxpf6+0LiqsRHCNgBCAa6gkYs+86Vjv42KUkCnKKrnmhQAquXY1lo1dcQ0c1TK6XaExXUnKXwSUlYDhuhXE38ryM3fe6c/WJYOu6zMKISvD2C+gG9+AtvgQVCYAo4hK4nYhYJcpgl3YQJoEtkJbamoo7cIteBr7v+xF2G9IhQCsa0YiUBAR4E5/woRWeuCK90NF4m5jLAFX4tWJhKsZgylMhABMISvphgoB7vJJdOjpjbAmdBtAFKW4IHebvJt4ygSQSCTc0Z0baSSOIBBgBLgjZNm0M0BBdgECVFkiqiCgGwFlAkin067XPLqFl/QEAUFADQFlAlDLXp4WBAQBPxFQJoBK1gEE/4iLn01L8g4CAsoEEIRCliojzF5oHDZq5dhLqQjKc7YjoEwArAOoxMCjfwPQuW5mlFpBApVZykqsOSmTFwSUCcBLZkGLiyP8NL+J6KZjojRRZgJBqz6R1wUCygRQ6ZeDDmMqML8pSotBAi0yE3DRpCRKkBBQJoAgFbZUWYdh3LEAJMAzgQkyEygVRnnOQgSEAFxWSp4ElhwTo1b47hKdgEvgJJrVCOgggNCYAjMJnNIUoZtmj+oEhASsbtsinAsEdBCAi2wqJ0oKJHAqSOBGzARYMSgkUDl1G8aSCAGUUOs8E5gPElgMEmCdgJBACSDKI1YgIARQYjXkSeAmIYESEZTHbEBAmQByGA3DGng5sIB1AmO7AzITCGtLCG65lQkguEXXI3l+d0BIQA+efqbixpefn/KZyFuZAOLxeGh2AQpVwOhyAHYCx47qBOTsQCGk7P1+BFu7DePqQ+fyXJkA7K3S8krmLAdwcohnAuPFWKi84GvIDRatNG5ic+h8WygTQJh1AIe2u/xy4EbYCTTL7sCh8Fj/d4bvcPfdT295YVImgPKKa39uTAJnjI8SkwCfHZDlgP11NirhCGVcevMNSoncyKlMAJgBhF4HcCjQTAKnMwlgOcAzASGBQxGy72/ezMryTcf2iWZUImUCMCpdgBN3SAAHiHgmIDqBYFRkdgQsEDIGEAIw2Db3zwSEBAyirC/pDBNAyIIQgOEKz+sEFoMEYDMkywHDeKskHzSf/iplzT+rgwBEB5BHs8B7ngT4KHFzJCIkUAAnv79mHUDYgg4CCBtmJZWX7QROc04Rik6gJAAVH8rf2lvoPUs54gs7wxaUrwZjwNxehhg2cA8t737FIGYCN6/P0h4MOIlDI8nf2hGIYtbVXI2beCOFx7vhTJpqE3EK2xxACwFor7EKTjBPAotnx2jpq1nqQouTSjBX4Tzi11VV0b9f8ud0FC7uzBQY5UfQ9WvjCRqqUC/XhRDW0fbCRpqFsHT9PS8HHDsBKAaXvpoTEnCNXGkRedyfWFtHk+vrCxIAp8wNOWwHggrPiRgRCcYQYBJgi0HeHRA7AWMw70+YOzZfxX2kV9g6P4MjBLC/iZT/Q353QEig/NhLjqMICAH43BJ4JnDm2NkBmQn4XBkhzF6ZALADIDoAxYaTnwmw2bAYCymCKY97QkCZADzlJpELIpAngRtmCQkUBEl+0I6AEIB2SEtPkEng7OYoCQmUjqEvT8LOAEYG7l++CHn4TIUADo+Lb98KCfgGfWkZ8wo4gwPfMCQq+mIbA45rUVC2A0gkEqID0Fyh+0kAg8rNsBPoBsLKFaVZRkkOCMRiRK9vIvryjUT9/aMzgCMBgxketbURLbmFqLkFDgjYA5G/QdqVv/gXzN0hAewO3DCb6BYhgYI4Fd27xwhtTE/N034e1Ts7iHr7sKmOv48UnA4PNmcisCTIEsCSijicGEwCCx0SgMNKtC27Jo+Hk7i837EjzyqMwkd6xcd+L9I1SxecSYBnAjF0paIvjoeXRUHHDECWAAYrND8TuGl2xDk7sE+WA0Cbm1yEvrzwPFrQNumIp/g4ZgyddGJdnWMFaLCqApm0DgIIZMGDJHTeWOgG2AmITuCNmpvTMoFOnzKV0kdYS/PI7+jpcllzS4E3RArcJ1kCBKTKeCZwFp8dmBWT5cBYnfHJviw6PxNAoVeKf+POH5B6LreYQgDlRlwhP54JnAU3w4thLCQ6AQUg5dH9CCgTQDpk56f3I+fTByYBx1gIywEhAZ8qoYKyVSaACsIiMEXJKwZZJyAkEJhqs1JQZQIQQyB/6tWZCcgWoT/gV1CuygRQQVgErihMAmwnwDqBBkgvdgKBq0LfBVbeBmQdAGYBvhckrAI4ywHnABEsBl/LUS+AUK7UAmCy1R1r3iN4+RtG7QDcafaxEXgEZ6AHlSO/ZxiiC0JMtZWDcJU/zCLAJHBuC8yG0YDZbBhGqaTb3iyKjbR/OeM8mn36XMr6rPgd7f5EM5vGE8+CCoZognI7X6ShVbePGgMUu/crl6Zoy7FUfcZnASAGNTYgqPCgTACiA7CjhTgkYHgmcHxTM81rn0yZFOzfLQg8GzniWQBYAI6k+ii7azU6MxMFD/FHCLkU7Pm5S1R+x8+joEwA+YTk3X8E9s8EIIqJ5QBfnMGGNRm8AhPYVj9ahT7NMhchAC5UVPfcyW6klJWAbIklwR4E8iRwvSgG7akUiyVRJgCLyxZa0ZgEFkEnICQQ2ibguuA6CCA8CybXsPofMU8CX5CZgP+VYbEEOgjA4uKFWzQmgfMwE+B7B8ROINxtoVDphQAKIVMh3zMJLOTdASGBCqlRvcUQAtCLp5Wp8V75OWPehmUmYGUV+SaUDgKQu0F8qz73GTMJsLGQKAbdYxaGmDoIIAw4VUQZ84pBIYGKqE4thRAC0AJjcBIREghOXZVDUrEELIJyFSiyCt5ng7LXOYKpfrqIqe4wyryIlQHTcnTLFiJ2NOrCRg7WtEFBoUilys/7EdBBABXbKgZRss+vGYFX2WD4lIOHPJo2czpd/vH37a/gQh+4w0/Df5/pH6G9MO13YwDbPmsq5cTysxCkgfxeBwEEsuDFhOa1ER95WTUUHH7Lwt59qGYCTf/Q+0eHdBeiTwcJFLvPIo8Vzyxy2SOcvstHlPfAICAEUKSqkkV+t+lnJiwceyFK4VQbD/EuCECciDBg4Q2iBAxv3UvJBQFSJgDxByCtSBAILgLKBBDcoovkgoAgoEwAci+ANCJBILgIKBNAcIsukgsCgoAQgLQBQSDECOggABebTSFGWIouCFiMgNgB+FQ5OTeb9B5lg4/c4Jnr5p12eiyrq+gx2DfCNbiEwggoE4A4BS0MbqFfoth9TbLfec0hPhKjqlr96WoW843kcGHHyHA3ZTaveOM7nZ/g4jvX9ao7l+A68w1QWsoEEKCyWiFqeiRNc+bOpU/ecZ1bYz3XcsMxA9U21I7GD8LCjAlgYCcNPbUUMrPpooHAyUakmRdCVhmZWCwWhKZWqPxl/54t6Wsb6mjumSdShC+u0Hz7DF+UkU0HycCXDyNwMzREAGWv4WBlqEwAwSquHdJyp+eDNSYIwI4SihRBQUB5F0B0AEGpapFTEHgzAsoE8OYk5RtBQBAICgLKBCA6gKBUtcgpCLwZAWUCeHOS8o0gIAgEBQEhgKDUlMgpCBhAQAjAAKiSpCAQFASUCYBvBUEISnlFTkFAEDgAAbEDOAAM+egHAhg8suyoXHksUhc+B6+K/ApRCB0B5OA3n91n8z8/Qm4kQznxrz8KPWaOkUQ9xWe8HX9bYAkIr8rRcTMgCmQJyaQ2VATAS5XG5nE0sXUSJfHPj5CGs/Gm1iY/srYvT3S4SF0b1Zz/FftkCwkD6CCAwHDl0OAQffTma+ivv3Q1GpxfIw5GPdw0xEF0Jw4M+M+vusjnf+h7YJr0oYJ7/lsHAXjO1M8HElV8XNb/I7PS+Q9sBeHpcAeW2obPoSMA6Xg2NDuRwRYELFC92gKFyCEIhA8BZQKQswDhazRS4spBQJkAKgcKKYkgED4ElAlA/AGEr9FIiSsHAWUCqBwopCSCQPgQUCYA0QGEr9FIiSsHAWUCqBwopCSCQPgQCJwdQAx22lW48IH384uZj3CcNGz/JZQJAbahjweuSZUOTgIGZVzmnJdzJXZZPQartgD2roF+emLLZnT+IxMA+j6NSybpLS0TrDM0Lb3FWfwkdwTUDa1fN9opLBZVj2gobxSv3z5I1Idyx1xMprlRMkHyiz9bEAJFAMlojFZ2bKUrf35fUehS2SydN3U6/de7Lqc4bO/FArAoZGoRuFFv2UL0mX9EZwhUsyq93NyJUyl0aFxB5iZwn6+vJ6rDq1IIAB2rrFTGJ2kzLqZc6UyW0uUVzU0TqOw4jDdwL7o2qyQU3HZ+LvMIlqMYlKi6BsTBPhD8D4Gk6ihPN4sFTM9cxCqWivzuFQGuGwG+MGqnnIrfyjpmFpYFv7hYuBzxeflREBAE3CCQxejfNonolAXwgORFaegm8dLjCAGUjp08KQi4RyCD+xrfcQnRlCkVRwD2zGfcV4fEFATKhwDrRaZOI3r3FVZ1fgZAZgDlawaSUxgRYK012wt87BqiSe1CAGFsA1LmkCLgbFlh6v+RvyG68OLRLUPLoAjkLoBlGIo4gsCbEUhj2p+sIvrbvyN6/wexPQoisDAoEwDcbIsOwMKKFZF8QoC1/dzZZxyNzv/3RG+7kCiNuwYstUlRJgBVmHMAJs2gaQ58BiAj5wA0o1okOccQCI1/xKVlXJHkAvEzD39s4MNlxxkVap9MdMm7iP7s3UQTWq2c9h+Iq68EwEaEzbCKOmniRMdc90DBVD+zteCspvGqycjzbhHgDlBdTXTscVAth0W3DIunOBR8jQ3Y3ptKNO8UopPmEU1sG1X2sZmw5cFXAhiGQcRFR8+k86ZPNwJTLBIlPj1YZmtlI2WxPlGe9k4/iuhb/2a9qNoEZItHnE9xiA8Hz3DlU2A6fh4DZQJIJBI8CSo5VGG0SMYAnqHASwwJZUKAR34+7BK2wG1saCiQpVYmANVSc/eUEVoVRYueF72LRZVRXBTlxRo7BZUOXBxoiSEI2IiAMgHYWCiRSRAQBNwhoIMAZJHtDmuJJQhYh4AOArCuUCKQICAIuENAmQDkYhB3QEssQcBGBJQJwMZCiUyCgCDgDgFlApCLQdwBLbEEARsRUCYAGwslMgkCgoA7BIQA3OEksQSBikRACKAiq1UKJQi4Q0CZAGQXwB3QEksQsBEBZQKwsVAikyAgCLhDQJkAZBfAHdASSxCwEQFlArCxUCKTICAIuENACMAdThJLEKhIBJT9AcApaDzJ3lAkCAKCgC8IDA4O1kWjfFe591DSQwdm09vbOycSibwLRHDg1/JZEBAEyoAAOj5cMEYHa2pq7kQ/tN8JYRkwkSwEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEgZAj8P/o5jLoPMld0wAAAABJRU5ErkJggg==\"\n                />\n                <nav class=\"top-nav\">\n                  <a\n                    class=\"${active[0] === 'changed' ? 'selected' : ''}\"\n                    href=\"#${changed.length ? cleanSelector(changed[0]) : ''}\"\n                    >Changed (${changed.length})</a\n                  >\n                  <a\n                    class=\"${active[0] === 'added' ? 'selected' : ''}\"\n                    href=\"#${added.length ? cleanSelector(added[0]) : ''}\"\n                    >Added (${added.length})</a\n                  >\n                  <a\n                    class=\"${active[0] === 'missing' ? 'selected' : ''}\"\n                    href=\"#${missing.length ? cleanSelector(missing[0]) : ''}\"\n                    >Missing (${missing.length})</a\n                  >\n                </nav>\n              </header>\n\n              <main tabindex=\"-1\" onKeyDown=${this.handleMainKeyDown}>\n                ${hasNoChanges &&\n                  html`\n                    <h1 class=\"no-changes\">No Changes</h1>\n                  `}\n                ${!!changed.length &&\n                  html`\n                    <div data-type=\"changed\" class=\"snapshots\">\n                      ${changed.map((img, i) => {\n                        const typeIndex = this.state.images[img] || 0;\n                        const getSource = p =>\n                          `results/${IMAGE_DIRS[typeIndex]}/${p.image}`;\n                        const buttons = States.map(\n                          (state, i) => html`\n                            <button\n                              class=\"${`button${\n                                i === typeIndex ? ' selected' : ''\n                              }`}\"\n                              type=\"button\"\n                              onKeyDown=\"${e => this.handleKeyDown(img, e)}\"\n                              onClick=\"${() =>\n                                this.handleSelectState(img, state)}\"\n                            >\n                              ${state}\n                            </button>\n                          `\n                        );\n\n                        return html`\n                          <${Snapshot}\n                            buttons=${buttons}\n                            image=${img}\n                            index=${i}\n                            getSource=${getSource}\n                            onLoad=\"${this.handleImageLoaded}\"\n                            onClick=\"${e => this.handleImageClick(img, i, e)}\"\n                            onKeyDown=\"${e => this.handleKeyDown(img, e)}\"\n                          />\n                        `;\n                      })}\n                    </div>\n                  `}\n                ${!!added.length &&\n                  html`\n                    <div data-type=\"added\" class=\"snapshots\">\n                      ${added.map((img, i) => {\n                        const getSource = p =>\n                          `results/${IMAGE_DIRS[IMAGE_DIRS.indexOf('new')]}/${\n                            p.image\n                          }`;\n                        const buttons = States.map(\n                          state => html`\n                            <button\n                              class=\"${`button${\n                                state === 'New' ? ' selected' : ''\n                              }${state !== 'New' ? ' disabled' : ''}`}\"\n                              type=\"button\"\n                            >\n                              ${state}\n                            </button>\n                          `\n                        );\n                        return html`\n                          <${Snapshot}\n                            buttons=${buttons}\n                            image=${img}\n                            index=${i}\n                            getSource=${getSource}\n                          />\n                        `;\n                      })}\n                    </div>\n                  `}\n                ${!!missing.length &&\n                  html`\n                    <div data-type=\"missing\" class=\"snapshots\">\n                      ${missing.map((img, i) => {\n                        const getSource = p =>\n                          `results/${\n                            IMAGE_DIRS[IMAGE_DIRS.indexOf('original')]\n                          }/${p.image}`;\n                        const buttons = States.map(\n                          state => html`\n                            <button\n                              class=\"${`button${\n                                state === 'Original' ? ' selected' : ''\n                              }${state !== 'Original' ? ' disabled' : ''}`}\"\n                              type=\"button\"\n                            >\n                              ${state}\n                            </button>\n                          `\n                        );\n                        return html`\n                          <${Snapshot}\n                            buttons=${buttons}\n                            image=${img}\n                            index=${i}\n                            getSource=${getSource}\n                          />\n                        `;\n                      })}\n                    </div>\n                  `}\n              </main>\n            </div>\n          `;\n        }\n      }\n\n      render(\n        html`\n          <${App} page=\"All\" />\n        `,\n        document.body\n      );\n    <\/script>\n  </head>\n\n  <body></body>\n</html>\n" };
    template_default = template;
  }
});

// node_modules/uuid/dist/rng.js
var require_rng2 = __commonJS({
  "node_modules/uuid/dist/rng.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rng;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, poolPtr += 16);
    }
  }
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS({
  "node_modules/uuid/dist/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS({
  "node_modules/uuid/dist/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate2(uuid2) {
      return typeof uuid2 === "string" && _regex.default.test(uuid2);
    }
    var _default = validate2;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS({
  "node_modules/uuid/dist/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i2 = 0; i2 < 256; ++i2) {
      byteToHex.push((i2 + 256).toString(16).substr(1));
    }
    function stringify2(arr, offset = 0) {
      const uuid2 = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid2;
    }
    var _default = stringify2;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/v1.js
var require_v12 = __commonJS({
  "node_modules/uuid/dist/v1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng2());
    var _stringify = _interopRequireDefault(require_stringify());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v12(options, buf, offset) {
      let i2 = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i2++] = tl >>> 24 & 255;
      b[i2++] = tl >>> 16 & 255;
      b[i2++] = tl >>> 8 & 255;
      b[i2++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i2++] = tmh >>> 8 & 255;
      b[i2++] = tmh & 255;
      b[i2++] = tmh >>> 24 & 15 | 16;
      b[i2++] = tmh >>> 16 & 255;
      b[i2++] = clockseq >>> 8 | 128;
      b[i2++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i2 + n] = node[n];
      }
      return buf || (0, _stringify.default)(b);
    }
    var _default = v12;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS({
  "node_modules/uuid/dist/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse2(uuid2) {
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse2;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/v35.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _default;
    exports.URL = exports.DNS = void 0;
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        bytes.push(str.charCodeAt(i2));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = URL2;
    function _default(name, version2, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (namespace.length !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version2;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i2 = 0; i2 < 16; ++i2) {
            buf[offset + i2] = bytes[i2];
          }
          return buf;
        }
        return (0, _stringify.default)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  }
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/md5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("md5").update(bytes).digest();
    }
    var _default = md5;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/v3.js
var require_v32 = __commonJS({
  "node_modules/uuid/dist/v3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v32 = (0, _v.default)("v3", 48, _md.default);
    var _default = v32;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/v4.js
var require_v43 = __commonJS({
  "node_modules/uuid/dist/v4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng2());
    var _stringify = _interopRequireDefault(require_stringify());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v42(options, buf, offset) {
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i2 = 0; i2 < 16; ++i2) {
          buf[offset + i2] = rnds[i2];
        }
        return buf;
      }
      return (0, _stringify.default)(rnds);
    }
    var _default = v42;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({
  "node_modules/uuid/dist/sha1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("sha1").update(bytes).digest();
    }
    var _default = sha1;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/v5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v52 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v52;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS({
  "node_modules/uuid/dist/nil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports.default = _default;
  }
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS({
  "node_modules/uuid/dist/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version2(uuid2) {
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid2.substr(14, 1), 16);
    }
    var _default = version2;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/index.js
var require_dist = __commonJS({
  "node_modules/uuid/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: function() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function() {
        return _version.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function() {
        return _parse.default;
      }
    });
    var _v = _interopRequireDefault(require_v12());
    var _v2 = _interopRequireDefault(require_v32());
    var _v3 = _interopRequireDefault(require_v43());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// src/main.ts
var core9 = __toESM(require_core());
var github = __toESM(require_github());
var glob5 = __toESM(require_glob());
var io4 = __toESM(require_io());

// node_modules/@chunkd/core/build/bytes.js
var ByteSize;
(function(ByteSize2) {
  ByteSize2[ByteSize2["UInt8"] = 1] = "UInt8";
  ByteSize2[ByteSize2["UInt16"] = 2] = "UInt16";
  ByteSize2[ByteSize2["UInt32"] = 4] = "UInt32";
  ByteSize2[ByteSize2["UInt64"] = 8] = "UInt64";
  ByteSize2[ByteSize2["Double"] = 8] = "Double";
  ByteSize2[ByteSize2["Float"] = 4] = "Float";
})(ByteSize || (ByteSize = {}));

// node_modules/@chunkd/core/build/chunk.source.js
var POW_32 = 2 ** 32;
var setNext = typeof setImmediate === "undefined" ? setTimeout : setImmediate;
var NotImplemented = () => {
  throw new Error("Method not implemented.");
};
var ChunkSourceBase = class {
  constructor() {
    this.isLittleEndian = true;
    this.delayMs = ChunkSourceBase.DefaultDelayMs;
    this.maxChunkCount = 10;
    this.chunks = ChunkSourceBase.DefaultChunkCache();
    this.blankFillCount = 16;
    this.maxConcurrentRequests = 50;
    this.toFetch = /* @__PURE__ */ new Set();
    this.toFetchPromise = null;
    this.byteOffset = 0;
    this.getFloat32 = NotImplemented;
    this.getFloat64 = NotImplemented;
    this.getInt8 = NotImplemented;
    this.getInt16 = NotImplemented;
    this.getInt32 = NotImplemented;
    this.setFloat32 = NotImplemented;
    this.setFloat64 = NotImplemented;
    this.setInt8 = NotImplemented;
    this.setInt16 = NotImplemented;
    this.setInt32 = NotImplemented;
    this.setUint8 = NotImplemented;
    this.setUint16 = NotImplemented;
    this.setUint32 = NotImplemented;
    this.setBigInt64 = NotImplemented;
    this.setBigUint64 = NotImplemented;
  }
  static getByteRanges(ranges, chunkCount = 32, blankFillCount = 16) {
    if (ranges.size === 0)
      return { chunks: [], blankFill: [] };
    const sortedRange = [...ranges.values()].sort((a, b) => a - b);
    const chunks = [];
    let current = [];
    chunks.push(current);
    const blankFill = [];
    for (let i2 = 0; i2 < sortedRange.length; ++i2) {
      const currentValue = sortedRange[i2];
      const lastValue = sortedRange[i2 - 1];
      if (current.length >= chunkCount) {
        current = [currentValue];
        chunks.push(current);
      } else if (i2 === 0 || currentValue === lastValue + 1) {
        current.push(currentValue);
      } else if (currentValue < lastValue + blankFillCount) {
        for (let x2 = lastValue; x2 < currentValue; x2++) {
          current.push(x2 + 1);
          blankFill.push(x2 + 1);
        }
        blankFill.pop();
      } else {
        current = [currentValue];
        chunks.push(current);
      }
    }
    return { chunks, blankFill };
  }
  async fetchData() {
    if (this.toFetch.size === 0)
      return;
    const chunkIds = this.toFetch;
    this.toFetch = /* @__PURE__ */ new Set();
    this.toFetchPromise = null;
    const ranges = ChunkSourceBase.getByteRanges(chunkIds, this.maxChunkCount, this.blankFillCount);
    const chunkData = [];
    for (const chunkRange of ranges.chunks) {
      const firstChunk = chunkRange[0];
      const lastChunk = chunkRange[chunkRange.length - 1];
      const offset = firstChunk * this.chunkSize;
      const length = lastChunk * this.chunkSize + this.chunkSize - offset;
      const buffer = await this.fetchBytes(offset, length);
      if (chunkRange.length === 1) {
        chunkData[firstChunk] = buffer;
        this.chunks.set(firstChunk, new DataView(buffer));
        continue;
      }
      const rootOffset = firstChunk * this.chunkSize;
      for (const chunkId of chunkRange) {
        const chunkOffset = chunkId * this.chunkSize - rootOffset;
        const chunkBuffer = buffer.slice(chunkOffset, chunkOffset + this.chunkSize);
        chunkData[chunkId] = chunkBuffer;
        this.chunks.set(chunkId, new DataView(chunkBuffer));
      }
    }
  }
  async loadBytes(offset, length) {
    if (offset < 0)
      throw new Error("Offset must be positive");
    const startChunk = Math.floor(offset / this.chunkSize);
    const endChunk = Math.ceil((offset + length) / this.chunkSize) - 1;
    for (let i2 = startChunk; i2 <= endChunk; i2++) {
      if (this.chunks.has(i2))
        continue;
      this.toFetch.add(i2);
    }
    if (this.toFetch.size === 0)
      return;
    if (this.toFetchPromise == null) {
      this.toFetchPromise = new Promise((resolve2) => setNext(resolve2, this.delayMs)).then(() => {
        return this.fetchData();
      });
    }
    if (this.toFetch.size > this.maxConcurrentRequests)
      throw new Error("Too many outstanding requests");
    await this.toFetchPromise;
  }
  getChunkId(offset) {
    return Math.floor(offset / this.chunkSize);
  }
  getUint(offset, bs) {
    switch (bs) {
      case ByteSize.UInt8:
        return this.getUint8(offset);
      case ByteSize.UInt16:
        return this.getUint16(offset);
      case ByteSize.UInt32:
        return this.getUint32(offset);
      case ByteSize.UInt64:
        return this.getUint64(offset);
    }
  }
  bytes(offset, count) {
    const firstChunkId = this.isOneChunk(offset, count);
    if (firstChunkId) {
      const chunk = this.getView(firstChunkId);
      const startOffset = offset - firstChunkId * this.chunkSize;
      return new Uint8Array(chunk.buffer.slice(startOffset, startOffset + count));
    }
    const output = new Uint8Array(count);
    const endOffset = offset + count;
    const startChunk = Math.floor(offset / this.chunkSize);
    const endChunk = Math.ceil((offset + count) / this.chunkSize) - 1;
    let outputOffset = 0;
    for (let chunkId = startChunk; chunkId <= endChunk; chunkId++) {
      const startRead = offset + outputOffset;
      const chunkOffset = chunkId * this.chunkSize;
      const view = this.getView(chunkId);
      const endRead = Math.min(endOffset, chunkOffset + this.chunkSize);
      const chunkBuffer = view.buffer.slice(startRead - chunkOffset, endRead - chunkOffset);
      output.set(new Uint8Array(chunkBuffer), outputOffset);
      outputOffset += chunkBuffer.byteLength;
    }
    return output;
  }
  getView(chunkId) {
    const view = this.chunks.get(chunkId);
    if (view == null)
      throw new Error(`Chunk:${chunkId} is not ready`);
    return view;
  }
  isOneChunk(offset, byteCount) {
    const endOffset = offset + byteCount - 1;
    const startChunk = Math.floor(offset / this.chunkSize);
    const endChunk = Math.floor(endOffset / this.chunkSize);
    if (endChunk - startChunk < 1)
      return startChunk;
    return null;
  }
  hasBytes(offset, length = 1) {
    const startChunk = Math.floor(offset / this.chunkSize);
    const endChunk = Math.ceil((offset + length) / this.chunkSize) - 1;
    for (let chunkId = startChunk; chunkId <= endChunk; chunkId++) {
      if (!this.chunks.has(chunkId))
        return false;
    }
    return true;
  }
  toRange(offset, length) {
    if (length == null)
      return `bytes=${offset}`;
    if (offset < 0)
      throw new Error("Cannot read from remote source with negative offset and length");
    return `bytes=${offset}-${offset + length}`;
  }
  parseContentRange(range) {
    const [unit, chunks] = range.split(" ");
    if (unit !== "bytes")
      throw new Error("Failed to parse content-range: " + range);
    if (chunks == null)
      throw new Error("Failed to parse content-range: " + range);
    const [, size] = chunks.split("/");
    const result = Number(size);
    if (isNaN(result))
      throw new Error("Failed to parse content-range: " + range);
    return result;
  }
  get buffer() {
    throw new Error("Method not implemented.");
  }
  get byteLength() {
    if (this._byteLength)
      return this._byteLength;
    throw Error(".size() has not been fetched.");
  }
  getUint8(byteOffset) {
    const chunkId = Math.floor(byteOffset / this.chunkSize);
    const view = this.chunks.get(chunkId);
    if (view == null)
      throw new Error(`Chunk:${chunkId} is not ready`);
    return view.getUint8(byteOffset - chunkId * this.chunkSize);
  }
  getUint16(byteOffset) {
    const chunkId = this.isOneChunk(byteOffset, ByteSize.UInt16);
    if (chunkId != null) {
      const chunk = this.getView(chunkId);
      return chunk.getUint16(byteOffset - chunkId * this.chunkSize, this.isLittleEndian);
    }
    const intA = this.getUint8(byteOffset);
    const intB = this.getUint8(byteOffset + ByteSize.UInt8);
    if (this.isLittleEndian)
      return intA + (intB << 8);
    return (intA << 8) + intB;
  }
  getUint32(byteOffset) {
    const chunkId = this.isOneChunk(byteOffset, ByteSize.UInt32);
    if (chunkId != null) {
      const chunk = this.getView(chunkId);
      return chunk.getUint32(byteOffset - chunkId * this.chunkSize, this.isLittleEndian);
    }
    const intA = this.getUint16(byteOffset);
    const intB = this.getUint16(byteOffset + ByteSize.UInt16);
    if (this.isLittleEndian)
      return intA + intB * 65536;
    return intA * 65536 + intB;
  }
  getUint64(offset) {
    const chunkId = this.isOneChunk(offset, ByteSize.UInt64);
    if (chunkId != null) {
      const chunk = this.getView(chunkId);
      return Number(chunk.getBigUint64(offset - chunkId * this.chunkSize, this.isLittleEndian));
    }
    const intA = this.getUint32(offset);
    const intB = this.getUint32(offset + ByteSize.UInt32);
    if (this.isLittleEndian)
      return intA + intB * POW_32;
    return intA * POW_32 + intB;
  }
  getBigUint64(byteOffset) {
    const chunkId = this.isOneChunk(byteOffset, ByteSize.UInt64);
    if (chunkId != null) {
      const chunk = this.getView(chunkId);
      return chunk.getBigUint64(byteOffset - chunkId * this.chunkSize, this.isLittleEndian);
    }
    const intA = BigInt(this.getUint32(byteOffset));
    const intB = BigInt(this.getUint32(byteOffset + ByteSize.UInt32));
    if (this.isLittleEndian)
      return intA + (intB << BigInt(32));
    return (intA << BigInt(32)) + intB;
  }
  getBigInt64() {
    throw new Error("Not implemented.");
  }
};
ChunkSourceBase.DefaultChunkCache = () => /* @__PURE__ */ new Map();
ChunkSourceBase.DefaultDelayMs = 1;

// node_modules/@chunkd/core/build/composite.js
var CompositeError = class extends Error {
  constructor(msg, code, reason) {
    super(msg);
    this.name = "CompositeError";
    this.code = code;
    this.reason = reason;
  }
  static isCompositeError(e2) {
    if (typeof e2 !== "object" || e2 == null)
      return false;
    return e2.name === "CompositeError";
  }
};

// node_modules/@chunkd/core/build/index.js
function isRecord(value) {
  return typeof value === "object" && value !== null;
}

// node_modules/@chunkd/source-aws/build/type.js
function toPromise(req) {
  if ("promise" in req)
    return req.promise();
  return req;
}

// node_modules/@chunkd/source-aws/build/s3.source.js
function getCompositeError(e2, msg) {
  if (!isRecord(e2))
    return new CompositeError(msg, 500, e2);
  if (typeof e2.statusCode !== "number")
    return new CompositeError(msg, 500, e2);
  return new CompositeError(msg, e2.statusCode, e2);
}
var SourceAwsS3 = class extends ChunkSourceBase {
  constructor(bucket, key, remote) {
    super();
    this.type = SourceAwsS3.type;
    this.protocol = "s3";
    this.chunkSize = SourceAwsS3.DefaultChunkSize;
    this.maxChunkCount = SourceAwsS3.DefaultMaxChunkCount;
    this.bucket = bucket;
    this.key = key;
    this.remote = remote;
  }
  get uri() {
    return this.name;
  }
  get name() {
    return `s3://${this.bucket}/${this.key}`;
  }
  static isSource(source) {
    return source.type === SourceAwsS3.type;
  }
  get size() {
    if (this._size)
      return this._size;
    this._size = Promise.resolve().then(async () => {
      const res = await toPromise(this.remote.headObject({ Bucket: this.bucket, Key: this.key }));
      return res.ContentLength || -1;
    });
    return this._size;
  }
  static parse(uri) {
    if (!uri.startsWith("s3://"))
      return null;
    const parts = uri.split("/");
    const bucket = parts[2];
    if (bucket == null || bucket.trim() === "")
      return null;
    const key = parts.slice(3).join("/");
    if (key == null || key.trim() === "")
      return null;
    return { key, bucket };
  }
  static fromUri(uri, remote) {
    const res = SourceAwsS3.parse(uri);
    if (res == null)
      return null;
    return new SourceAwsS3(res.bucket, res.key, remote);
  }
  async fetchBytes(offset, length) {
    const fetchRange = this.toRange(offset, length);
    try {
      const resp = await this.remote.getObject({ Bucket: this.bucket, Key: this.key, Range: fetchRange }).promise();
      if (!Buffer.isBuffer(resp.Body))
        throw new Error("Failed to fetch object, Body is not a buffer");
      if (resp.ContentRange != null && this._size == null) {
        this._size = Promise.resolve(this.parseContentRange(resp.ContentRange));
      }
      const buffer = resp.Body;
      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    } catch (err) {
      throw getCompositeError(err, `Failed to fetch ${this.name} ${fetchRange}`);
    }
  }
};
SourceAwsS3.type = "aws:s3";
SourceAwsS3.DefaultChunkSize = 64 * 1024;
SourceAwsS3.DefaultMaxChunkCount = 32;

// node_modules/@chunkd/source-aws/build/s3.fs.js
var FsAwsS3 = class {
  constructor(s3) {
    this.protocol = FsAwsS3.protocol;
    this.parse = FsAwsS3.parse;
    this.s3 = s3;
  }
  source(filePath) {
    const source = SourceAwsS3.fromUri(filePath, this.s3);
    if (source == null)
      throw new Error(`Failed to create aws s3 source from uri: ${filePath}`);
    return source;
  }
  static is(fs8) {
    return fs8.protocol === FsAwsS3.protocol;
  }
  static isPath(path8) {
    if (path8 == null)
      return false;
    return path8.startsWith("s3://");
  }
  static parse(uri) {
    if (!uri.startsWith("s3://"))
      throw new Error(`Unable to parse s3 uri: "${uri}"`);
    const parts = uri.split("/");
    const bucket = parts[2];
    if (bucket == null || bucket.trim() === "") {
      throw new Error(`Unable to parse s3 uri: "${uri}"`);
    }
    if (parts.length === 3)
      return { bucket };
    const key = parts.slice(3).join("/");
    if (key == null || key.trim() === "") {
      return { bucket };
    }
    return { key, bucket };
  }
  async *list(filePath) {
    for await (const obj of this.details(filePath))
      yield obj.path;
  }
  async *details(filePath) {
    const opts = this.parse(filePath);
    let ContinuationToken = void 0;
    const Bucket = opts.bucket;
    const Prefix = opts.key;
    let count = 0;
    try {
      while (true) {
        count++;
        const res = await toPromise(this.s3.listObjectsV2({ Bucket, Prefix, ContinuationToken }));
        if (res.Contents == null)
          break;
        for (const obj of res.Contents) {
          if (obj.Key == null)
            continue;
          yield { path: `s3://${Bucket}/${obj.Key}`, size: obj.Size };
        }
        if (!res.IsTruncated)
          break;
        if (count >= FsAwsS3.MaxListCount) {
          throw new Error(`Failed to finish listing within ${FsAwsS3.MaxListCount} list attempts`);
        }
        ContinuationToken = res.NextContinuationToken;
      }
    } catch (e2) {
      throw getCompositeError(e2, `Failed to list: "${filePath}"`);
    }
  }
  async read(filePath) {
    const opts = this.parse(filePath);
    if (opts.key == null)
      throw new Error(`Failed to read:  "${filePath}"`);
    try {
      const res = await this.s3.getObject({ Bucket: opts.bucket, Key: opts.key }).promise();
      return res.Body;
    } catch (e2) {
      throw getCompositeError(e2, `Failed to read: "${filePath}"`);
    }
  }
  async write(filePath, buf, ctx) {
    const opts = this.parse(filePath);
    if (opts.key == null)
      throw new Error(`Failed to write: "${filePath}"`);
    try {
      await toPromise(this.s3.upload({
        Bucket: opts.bucket,
        Key: opts.key,
        Body: buf,
        ContentEncoding: ctx === null || ctx === void 0 ? void 0 : ctx.contentEncoding,
        ContentType: ctx === null || ctx === void 0 ? void 0 : ctx.contentType
      }));
    } catch (e2) {
      throw getCompositeError(e2, `Failed to write: "${filePath}"`);
    }
  }
  exists(filePath) {
    return this.head(filePath).then((f3) => f3 != null);
  }
  stream(filePath) {
    const opts = this.parse(filePath);
    if (opts.key == null)
      throw new Error(`S3: Unable to read "${filePath}"`);
    return this.s3.getObject({ Bucket: opts.bucket, Key: opts.key }).createReadStream();
  }
  async head(filePath) {
    const opts = this.parse(filePath);
    if (opts.key == null)
      throw new Error(`Failed to exists: "${filePath}"`);
    try {
      const res = await toPromise(this.s3.headObject({ Bucket: opts.bucket, Key: opts.key }));
      return { size: res.ContentLength, path: filePath };
    } catch (e2) {
      if (isRecord(e2) && e2.code === "NotFound")
        return null;
      throw getCompositeError(e2, `Failed to exists: "${filePath}"`);
    }
  }
};
FsAwsS3.protocol = "s3";
FsAwsS3.MaxListCount = 100;

// node_modules/@chunkd/source-file/build/file.fs.js
var import_fs2 = __toESM(require("fs"), 1);
var import_path2 = __toESM(require("path"), 1);

// node_modules/@chunkd/source-file/build/file.source.js
var import_fs = require("fs");
var import_path = require("path");
var SourceFile = class extends ChunkSourceBase {
  constructor(fileName) {
    super();
    this.type = "file";
    this.protocol = "file";
    this.chunkSize = SourceFile.DefaultChunkSize;
    this.fd = null;
    this.closeAfterRead = false;
    this.fileName = fileName;
  }
  static isSource(source) {
    return source.type === "file";
  }
  async close() {
    const fd = await this.fd;
    if (fd == null)
      return;
    await fd.close();
    this.fd = null;
  }
  get uri() {
    return (0, import_path.resolve)(this.fileName);
  }
  get name() {
    return (0, import_path.basename)(this.fileName);
  }
  get size() {
    if (this._size)
      return this._size;
    this._size = Promise.resolve().then(async () => {
      const stat2 = await import_fs.promises.stat(this.fileName);
      return stat2.size;
    });
    return this._size;
  }
  async fetchBytes(offset, length) {
    if (offset < 0 && length != null)
      throw new Error("Cannot fetch negative offsets with length");
    if (offset < 0) {
      length = Math.abs(offset);
      const size = await this.size;
      offset = size + offset;
    }
    if (length == null)
      throw new Error("Length is required for reading from files");
    if (this.fd == null)
      this.fd = import_fs.promises.open(this.fileName, "r");
    const fd = await this.fd;
    const { buffer } = await fd.read(Buffer.allocUnsafe(length), 0, length, offset);
    if (this.closeAfterRead)
      await this.close();
    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
  }
};
SourceFile.DefaultChunkSize = 16 * 1024;

// node_modules/@chunkd/source-file/build/file.fs.js
function getCompositeError2(e2, msg) {
  if (!isRecord(e2))
    return new CompositeError(msg, 500, e2);
  if (e2.code === "ENOENT")
    return new CompositeError(msg, 404, e2);
  if (e2.code === "EACCES")
    return new CompositeError(msg, 403, e2);
  return new CompositeError(msg, 500, e2);
}
var FsFile = class {
  constructor() {
    this.protocol = FsFile.protocol;
  }
  static is(fs8) {
    return fs8.protocol === FsFile.protocol;
  }
  source(filePath) {
    return new SourceFile(filePath);
  }
  async *list(filePath) {
    try {
      const files = await import_fs2.default.promises.readdir(filePath, { withFileTypes: true });
      const resolve2 = import_path2.default.resolve(filePath);
      for (const file of files) {
        const targetPath = import_path2.default.join(resolve2, file.name);
        if (file.isDirectory())
          yield* this.list(targetPath);
        else
          yield targetPath;
      }
    } catch (e2) {
      throw getCompositeError2(e2, `Failed to list: ${filePath}`);
    }
  }
  async *details(filePath) {
    for await (const file of this.list(filePath)) {
      const res = await this.head(file);
      if (res == null)
        continue;
      yield res;
    }
  }
  async head(filePath) {
    try {
      const stat2 = await import_fs2.default.promises.stat(filePath);
      return { path: filePath, size: stat2.size, isDirectory: stat2.isDirectory() };
    } catch (e2) {
      if (isRecord(e2) && e2.code === "ENOENT")
        return null;
      throw getCompositeError2(e2, `Failed to stat: ${filePath}`);
    }
  }
  async read(filePath) {
    try {
      return await import_fs2.default.promises.readFile(filePath);
    } catch (e2) {
      throw getCompositeError2(e2, `Failed to read: ${filePath}`);
    }
  }
  exists(filePath) {
    return this.head(filePath).then((f3) => f3 != null);
  }
  async write(filePath, buf) {
    const folderPath = import_path2.default.dirname(filePath);
    await import_fs2.default.promises.mkdir(folderPath, { recursive: true });
    try {
      if (Buffer.isBuffer(buf) || typeof buf === "string") {
        await import_fs2.default.promises.writeFile(filePath, buf);
      } else {
        const st = import_fs2.default.createWriteStream(filePath);
        await new Promise((resolve2, reject) => {
          st.on("finish", resolve2);
          st.on("error", reject);
          buf.pipe(st);
        });
      }
    } catch (e2) {
      throw getCompositeError2(e2, `Failed to write: ${filePath}`);
    }
  }
  stream(filePath) {
    return import_fs2.default.createReadStream(filePath);
  }
};
FsFile.protocol = "file";

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/index.js
var import_node_http2 = __toESM(require("node:http"), 1);
var import_node_https = __toESM(require("node:https"), 1);
var import_node_zlib = __toESM(require("node:zlib"), 1);
var import_node_stream2 = __toESM(require("node:stream"), 1);
var import_node_buffer2 = require("node:buffer");

// node_modules/data-uri-to-buffer/dist/index.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var dist_default = dataUriToBuffer;

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/body.js
var import_node_stream = __toESM(require("node:stream"), 1);
var import_node_util = require("node:util");
var import_node_buffer = require("node:buffer");
init_fetch_blob();
init_esm_min();

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/errors/base.js
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/errors/fetch-error.js
var FetchError = class extends FetchBaseError {
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/utils/is.js
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob = (object) => {
  return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
var isAbortSignal = (object) => {
  return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
};
var isDomainOrSubdomain = (destination, original) => {
  const orig = new URL(original).hostname;
  const dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
};

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/body.js
var pipeline = (0, import_node_util.promisify)(import_node_stream.default.pipeline);
var INTERNALS = Symbol("Body internals");
var Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = import_node_buffer.Buffer.from(body.toString());
    } else if (isBlob(body)) {
    } else if (import_node_buffer.Buffer.isBuffer(body)) {
    } else if (import_node_util.types.isAnyArrayBuffer(body)) {
      body = import_node_buffer.Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = import_node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_node_stream.default) {
    } else if (body instanceof FormData) {
      body = formDataToBlob(body);
      boundary = body.type.split("=")[1];
    } else {
      body = import_node_buffer.Buffer.from(String(body));
    }
    let stream = body;
    if (import_node_buffer.Buffer.isBuffer(body)) {
      stream = import_node_stream.default.Readable.from(body);
    } else if (isBlob(body)) {
      stream = import_node_stream.default.Readable.from(body.stream());
    }
    this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof import_node_stream.default) {
      body.on("error", (error_) => {
        const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
        this[INTERNALS].error = error2;
      });
    }
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  async arrayBuffer() {
    const { buffer, byteOffset, byteLength } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    const ct = this.headers.get("content-type");
    if (ct.startsWith("application/x-www-form-urlencoded")) {
      const formData = new FormData();
      const parameters = new URLSearchParams(await this.text());
      for (const [name, value] of parameters) {
        formData.append(name, value);
      }
      return formData;
    }
    const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
    return toFormData2(this.body, ct);
  }
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "";
    const buf = await this.arrayBuffer();
    return new fetch_blob_default([buf], {
      type: ct
    });
  }
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  async text() {
    const buffer = await consumeBody(this);
    return new TextDecoder().decode(buffer);
  }
  buffer() {
    return consumeBody(this);
  }
};
Body.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true },
  data: { get: (0, import_node_util.deprecate)(() => {
  }, "data doesn't exist, use json(), text(), arrayBuffer(), or body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (response)") }
});
async function consumeBody(data) {
  if (data[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS].disturbed = true;
  if (data[INTERNALS].error) {
    throw data[INTERNALS].error;
  }
  const { body } = data;
  if (body === null) {
    return import_node_buffer.Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream.default)) {
    return import_node_buffer.Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return import_node_buffer.Buffer.from(accum.join(""));
      }
      return import_node_buffer.Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let { body } = instance[INTERNALS];
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_node_stream.default && typeof body.getBoundary !== "function") {
    p1 = new import_node_stream.PassThrough({ highWaterMark });
    p2 = new import_node_stream.PassThrough({ highWaterMark });
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].stream = p1;
    body = p2;
  }
  return body;
};
var getNonSpecFormDataBoundary = (0, import_node_util.deprecate)((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (import_node_buffer.Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body instanceof FormData) {
    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
  }
  if (body instanceof import_node_stream.default) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const { body } = request[INTERNALS];
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (import_node_buffer.Buffer.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  return null;
};
var writeToStream = async (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else {
    await pipeline(body, dest);
  }
};

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/headers.js
var import_node_util2 = require("node:util");
var import_node_http = __toESM(require("node:http"), 1);
var validateHeaderName = typeof import_node_http.default.validateHeaderName === "function" ? import_node_http.default.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
    throw error2;
  }
};
var validateHeaderValue = typeof import_node_http.default.validateHeaderValue === "function" ? import_node_http.default.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
    throw error2;
  }
};
var Headers = class extends URLSearchParams {
  constructor(init) {
    let result = [];
    if (init instanceof Headers) {
      const raw = init.raw();
      for (const [name, values] of Object.entries(raw)) {
        result.push(...values.map((value) => [name, value]));
      }
    } else if (init == null) {
    } else if (typeof init === "object" && !import_node_util2.types.isBoxedPrimitive(init)) {
      const method = init[Symbol.iterator];
      if (method == null) {
        result.push(...Object.entries(init));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result = [...init].map((pair) => {
          if (typeof pair !== "object" || import_node_util2.types.isBoxedPrimitive(pair)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair];
        }).map((pair) => {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : void 0;
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
            };
          case "delete":
          case "has":
          case "getAll":
            return (name) => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback, thisArg = void 0) {
    for (const name of this.keys()) {
      Reflect.apply(callback, thisArg, [this.get(name), name, this]);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
};
Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
  result[property] = { enumerable: true };
  return result;
}, {}));
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index, array) => {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/response.js
var INTERNALS2 = Symbol("Response internals");
var Response = class extends Body {
  constructor(body = null, options = {}) {
    super(body, options);
    const status = options.status != null ? options.status : 200;
    const headers = new Headers(options.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body, this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS2] = {
      type: "default",
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get type() {
    return this[INTERNALS2].type;
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  clone() {
    return new Response(clone(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
    });
  }
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new Response(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  static error() {
    const response = new Response(null, { status: 0, statusText: "" });
    response[INTERNALS2].type = "error";
    return response;
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response.prototype, {
  type: { enumerable: true },
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/request.js
var import_node_url = require("node:url");
var import_node_util3 = require("node:util");

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/utils/referrer.js
var import_node_net = require("node:net");
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
var ReferrerPolicy = /* @__PURE__ */ new Set([
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
]);
var DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_node_net.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (/^(.+\.)*localhost$/.test(url.host)) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token2 of policyTokens) {
    if (token2 && ReferrerPolicy.has(token2)) {
      policy = token2;
    }
  }
  return policy;
}

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/request.js
var INTERNALS3 = Symbol("Request internals");
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS3] === "object";
};
var doBadDataWarn = (0, import_node_util3.deprecate)(() => {
}, ".data is not a valid RequestInit property, use .body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (request)");
var Request = class extends Body {
  constructor(input, init = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    if (parsedURL.username !== "" || parsedURL.password !== "") {
      throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
    }
    let method = init.method || input.method || "GET";
    if (/^(delete|get|head|options|post|put)$/i.test(method)) {
      method = method.toUpperCase();
    }
    if ("data" in init) {
      doBadDataWarn();
    }
    if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init.size || input.size || 0
    });
    const headers = new Headers(init.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers.set("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init) {
      signal = init.signal;
    }
    if (signal != null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
    }
    let referrer = init.referrer == null ? input.referrer : init.referrer;
    if (referrer === "") {
      referrer = "no-referrer";
    } else if (referrer) {
      const parsedReferrer = new URL(referrer);
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
    } else {
      referrer = void 0;
    }
    this[INTERNALS3] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal,
      referrer
    };
    this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow;
    this.compress = init.compress === void 0 ? input.compress === void 0 ? true : input.compress : init.compress;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
    this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
  }
  get method() {
    return this[INTERNALS3].method;
  }
  get url() {
    return (0, import_node_url.format)(this[INTERNALS3].parsedURL);
  }
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  get signal() {
    return this[INTERNALS3].signal;
  }
  get referrer() {
    if (this[INTERNALS3].referrer === "no-referrer") {
      return "";
    }
    if (this[INTERNALS3].referrer === "client") {
      return "about:client";
    }
    if (this[INTERNALS3].referrer) {
      return this[INTERNALS3].referrer.toString();
    }
    return void 0;
  }
  get referrerPolicy() {
    return this[INTERNALS3].referrerPolicy;
  }
  set referrerPolicy(referrerPolicy) {
    this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
  }
  clone() {
    return new Request(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true },
  referrer: { enumerable: true },
  referrerPolicy: { enumerable: true }
});
var getNodeRequestOptions = (request) => {
  const { parsedURL } = request[INTERNALS3];
  const headers = new Headers(request[INTERNALS3].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (request.referrerPolicy === "") {
    request.referrerPolicy = DEFAULT_REFERRER_POLICY;
  }
  if (request.referrer && request.referrer !== "no-referrer") {
    request[INTERNALS3].referrer = determineRequestsReferrer(request);
  } else {
    request[INTERNALS3].referrer = "no-referrer";
  }
  if (request[INTERNALS3].referrer instanceof URL) {
    headers.set("Referer", request.referrer);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate,br");
  }
  let { agent } = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  const search = getSearch(parsedURL);
  const options = {
    path: parsedURL.pathname + search,
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return {
    parsedURL,
    options
  };
};

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/errors/abort-error.js
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};

// node_modules/@chunkd/source-http/node_modules/node-fetch/src/index.js
init_esm_min();
init_from();
var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
async function fetch2(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dist_default(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http2.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_node_stream2.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request.url);
        } catch {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (!isDomainOrSubdomain(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOptions.headers.delete(name);
              }
            }
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream2.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve2(fetch2(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error2) => {
        if (error2) {
          reject(error2);
        }
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), (error2) => {
          if (error2) {
            reject(error2);
          }
        });
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error2) => {
          if (error2) {
            reject(error2);
          }
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflate(), (error2) => {
              if (error2) {
                reject(error2);
              }
            });
          } else {
            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflateRaw(), (error2) => {
              if (error2) {
                reject(error2);
              }
            });
          }
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        raw.once("end", () => {
          if (!response) {
            response = new Response(body, responseOptions);
            resolve2(response);
          }
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), (error2) => {
          if (error2) {
            reject(error2);
          }
        });
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = import_node_buffer2.Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = import_node_buffer2.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = import_node_buffer2.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && import_node_buffer2.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}

// node_modules/@chunkd/source-http/build/http.source.js
var SourceHttp = class extends ChunkSourceBase {
  constructor(uri) {
    super();
    this.type = "url";
    this.protocol = "http";
    this.chunkSize = SourceHttp.DefaultChunkSize;
    this.uri = uri;
  }
  static isSource(source) {
    return source.type === "url";
  }
  get size() {
    if (this._size)
      return this._size;
    this._size = Promise.resolve().then(async () => {
      const res = await SourceHttp.fetch(this.uri, { method: "HEAD" });
      return Number(res.headers.get("content-length"));
    });
    return this._size;
  }
  async fetchBytes(offset, length) {
    const Range = this.toRange(offset, length);
    const headers = { Range };
    const response = await SourceHttp.fetch(this.uri, { headers });
    if (response.ok) {
      const contentRange = response.headers.get("content-range");
      if (this._size == null && contentRange != null) {
        this._size = Promise.resolve(this.parseContentRange(contentRange));
      }
      return response.arrayBuffer();
    }
    throw new Error("Failed to fetch");
  }
};
SourceHttp.DefaultChunkSize = 32 * 1024;
SourceHttp.fetch = (a, b) => fetch(a, b);

// node_modules/@chunkd/source-http/build/http.fs.js
function getCompositeError3(e2, msg) {
  if (!isRecord(e2))
    return new CompositeError(msg, 500, e2);
  if (e2.code === "ENOENT")
    return new CompositeError(msg, 404, e2);
  if (e2.code === "EACCES")
    return new CompositeError(msg, 403, e2);
  return new CompositeError(msg, 500, e2);
}
var FsHttp = class {
  constructor() {
    this.protocol = FsHttp.protocol;
  }
  static is(fs8) {
    return fs8.protocol === FsHttp.protocol;
  }
  source(filePath) {
    return new SourceHttp(filePath);
  }
  async *list(filePath) {
    throw new Error(`Unable to "list" on ${filePath}`);
  }
  async *details(filePath) {
    throw new Error(`Unable to "details" on ${filePath}`);
  }
  async head(filePath) {
    const res = await SourceHttp.fetch(filePath, { method: "HEAD" });
    if (!res.ok)
      throw getCompositeError3(new Error(res.statusText), `Failed to head: ${filePath}`);
    return { path: filePath, size: Number(res.headers.get("content-length")), isDirectory: false };
  }
  async read(filePath) {
    const res = await SourceHttp.fetch(filePath, { method: "GET" });
    if (!res.ok)
      throw getCompositeError3(new Error(res.statusText), `Failed to head: ${filePath}`);
    return Buffer.from(await res.arrayBuffer());
  }
  exists(filePath) {
    return this.head(filePath).then((f3) => f3 != null);
  }
  async write(filePath) {
    throw new Error(`Unable to "write" on ${filePath}`);
  }
  stream(filePath) {
    throw new Error(`Unable to "stream" on ${filePath}`);
  }
};
FsHttp.protocol = "http";

// node_modules/@chunkd/source-http/build/index.node.js
SourceHttp.fetch = fetch2;

// node_modules/@chunkd/fs/build/index.node.js
var import_s3 = __toESM(require_s33(), 1);

// node_modules/@chunkd/fs/build/fs.abstraction.js
function isRecord2(obj) {
  if (typeof obj !== "object")
    return false;
  if (obj == null)
    return false;
  return obj.constructor === Object;
}
var FileSystemAbstraction = class {
  constructor() {
    this.protocol = "abstract";
    this.isOrdered = true;
    this.systems = [];
  }
  register(path8, system) {
    for (let i2 = 0; i2 < this.systems.length; i2++) {
      const sys = this.systems[i2];
      if (sys.path === path8) {
        this.systems.splice(i2, 1, { path: path8, system });
        return;
      }
    }
    this.systems.push({ path: path8, system });
    this.isOrdered = false;
  }
  async toArray(generator) {
    const output = [];
    for await (const o of generator)
      output.push(o);
    return output;
  }
  read(filePath) {
    return this.get(filePath).read(filePath);
  }
  async readJson(filePath) {
    const obj = await this.read(filePath);
    return JSON.parse(obj.toString());
  }
  stream(filePath) {
    return this.get(filePath).stream(filePath);
  }
  write(filePath, buffer, opts) {
    if (Array.isArray(buffer) || isRecord2(buffer)) {
      const content = JSON.stringify(buffer, null, 2);
      return this.get(filePath).write(filePath, content, { contentType: "application/json", ...opts });
    }
    return this.get(filePath).write(filePath, buffer, opts);
  }
  list(filePath) {
    return this.get(filePath).list(filePath);
  }
  details(filePath) {
    return this.get(filePath).details(filePath);
  }
  exists(filePath) {
    return this.get(filePath).exists(filePath);
  }
  head(filePath) {
    return this.get(filePath).head(filePath);
  }
  join(filePathA, filePathB) {
    return filePathA.replace(/\/$/, "") + "/" + filePathB.replace(/^\//, "");
  }
  source(filePath) {
    return this.get(filePath).source(filePath);
  }
  sortSystems() {
    if (this.isOrdered)
      return;
    this.systems.sort((a, b) => b.path.length - a.path.length);
    this.isOrdered = true;
  }
  get(filePath) {
    this.sortSystems();
    for (const cfg of this.systems) {
      if (filePath.startsWith(cfg.path))
        return cfg.system;
    }
    throw new Error(`Unable to find file system for path:${filePath}`);
  }
};
var fsa = new FileSystemAbstraction();

// node_modules/@chunkd/fs/build/index.node.js
var fsFile = new FsFile();
fsa.register("", fsFile);
fsa.register("file://", fsFile);
var fsHttp = new FsHttp();
fsa.register("http://", fsHttp);
fsa.register("https://", fsHttp);
var fsAwsS3 = new FsAwsS3(new import_s3.default());
fsa.register("s3://", fsAwsS3);

// src/main.ts
var import_path8 = __toESM(require("path"));

// src/api/downloadOtherWorkflowArtifact.ts
var import_path3 = __toESM(require("path"));
var import_exec = __toESM(require_exec());
var core = __toESM(require_core());
var io = __toESM(require_io());
var glob = __toESM(require_glob());
var FILENAME = "visual-snapshots-base.zip";
async function download(url, file, dest) {
  core.startGroup(`download ${file}`);
  await (0, import_exec.exec)("wget", [
    "-nv",
    "--retry-connrefused",
    "--waitretry=1",
    "--read-timeout=20",
    "--timeout=15",
    "-t",
    "0",
    "-O",
    file,
    url
  ]);
  await (0, import_exec.exec)("unzip", ["-q", "-d", dest, file], {
    silent: true
  });
  await (0, import_exec.exec)("ls", [dest]);
  const tarGlobber = await glob.create(`${dest}/*.tar.gz`, {
    followSymbolicLinks: false
  });
  const tarFiles = await tarGlobber.glob();
  for (const tarFile of tarFiles) {
    await (0, import_exec.exec)("tar", ["zxf", tarFile, "-C", dest]);
  }
  await (0, import_exec.exec)("ls", ["-la", dest]);
  core.endGroup();
  return { downloadPath: dest, artifactName: file };
}
async function downloadOtherWorkflowArtifact(octokit2, { owner: owner2, repo: repo2, artifactId, downloadPath }) {
  const artifact3 = await octokit2.actions.downloadArtifact({
    owner: owner2,
    repo: repo2,
    artifact_id: artifactId,
    archive_format: "zip"
  });
  try {
    await io.mkdirP(downloadPath);
  } catch {
  }
  const downloadFile = import_path3.default.resolve(downloadPath, FILENAME);
  return await download(artifact3.url, downloadFile, downloadPath);
}

// src/api/failBuild.ts
async function failBuild({ octokit: octokit2, ...body }) {
  const failureBody = {
    status: "completed",
    conclusion: "failure",
    title: "Internal Error",
    summary: "There was an error processing the snapshots"
  };
  const { owner: owner2, repo: repo2, id } = body;
  const { title, summary, ...checkBody } = failureBody;
  return await octokit2.checks.update({
    check_run_id: id,
    owner: owner2,
    repo: repo2,
    ...checkBody,
    output: {
      title,
      summary
    }
  });
}

// src/api/finishBuild.ts
async function finishBuild(body) {
  const { owner: owner2, repo: repo2, galleryUrl, id, images, results, octokit: octokit2 } = body;
  const { baseFilesLength, changed, missing, added } = results;
  const unchanged = baseFilesLength - (changed.length + missing.length);
  const totalChanged = changed.length + missing.length;
  const conclusion = totalChanged > 0 ? "action_required" : added.length ? "neutral" : "success";
  const title = totalChanged > 0 ? `${totalChanged} snapshots need review` : added.length ? `${added.length} new snapshots` : "No snapshot changes detected";
  return await octokit2.checks.update({
    check_run_id: id,
    owner: owner2,
    repo: repo2,
    status: "completed",
    conclusion,
    output: {
      title,
      summary: `
${galleryUrl ? `[View Image Gallery](${galleryUrl})` : ""}

* **${changed.length}** changed snapshots (${unchanged} unchanged)
* **${missing.length}** missing snapshots
* **${added.length}** new snapshots`,
      text: `
${!changed.length && !missing.length && !added.length ? "## No changes" : ""}

${changed.length ? `## Changed snapshots
${[...changed].map((name) => `* ${name}`).join("\n")}
` : ""}

${missing.length ? `## Missing snapshots
${[...missing].map((name) => `* ${name}`).join("\n")}
` : ""}

${added.length ? `## New snapshots
${[...added].map((name) => `* ${name}`).join("\n")}
` : ""}`,
      images
    }
  });
}

// src/api/retrieveBaseSnapshots.ts
var import_async_retry = __toESM(require_lib3());
var core3 = __toESM(require_core());

// src/api/getArtifactsForBranchAndWorkflow.ts
var core2 = __toESM(require_core());
var MAX_PAGES = 10;
var PER_PAGE_LIMIT = 30;
async function getArtifactsForBranchAndWorkflow(octokit2, {
  owner: owner2,
  repo: repo2,
  workflow_id,
  branch,
  commit,
  artifactName
}) {
  core2.startGroup(`getArtifactsForBranchAndWorkflow - workflow:"${workflow_id}",  branch:"${branch}"${commit ? `,  commit:"${commit}"` : ""}`);
  let currentPage = 0;
  let completedWorkflowRuns = [];
  for await (const response of octokit2.paginate.iterator(octokit2.actions.listWorkflowRuns, {
    owner: owner2,
    repo: repo2,
    workflow_id,
    per_page: PER_PAGE_LIMIT
  })) {
    if (!response.data.length) {
      core2.warning(`Workflow ${workflow_id} not found in branch ${branch}`);
      core2.endGroup();
      return null;
    }
    const workflowRuns = response.data.filter((workflowRun) => workflowRun.head_repository.full_name === `${owner2}/${repo2}`).filter((workflowRun) => workflowRun.head_branch === branch && workflowRun.conclusion === "success");
    const workflowRunsForCommit = commit ? workflowRuns.filter((run2) => run2.head_sha === commit) : workflowRuns;
    if (workflowRunsForCommit.length) {
      completedWorkflowRuns = completedWorkflowRuns.concat(workflowRunsForCommit);
      break;
    }
    if (currentPage > MAX_PAGES) {
      core2.warning(`Workflow ${workflow_id} not found in branch: ${branch}${commit ? ` and commit: ${commit}` : ""}`);
      core2.endGroup();
      return null;
    }
    currentPage++;
  }
  for (const workflowRun of completedWorkflowRuns) {
    core2.debug(`Checking artifacts for workflow run: ${workflowRun.html_url}`);
    const {
      data: { artifacts }
    } = await octokit2.actions.listWorkflowRunArtifacts({
      owner: owner2,
      repo: repo2,
      run_id: workflowRun.id
    });
    if (!artifacts) {
      core2.debug(`Unable to fetch artifacts for branch: ${branch}, workflow: ${workflow_id}, workflowRunId: ${workflowRun.id}`);
    } else {
      const foundArtifact = artifacts.find(({ name }) => name === artifactName);
      if (foundArtifact) {
        core2.debug(`Found suitable artifact: ${foundArtifact.url}`);
        core2.endGroup();
        return {
          artifact: foundArtifact,
          workflowRun
        };
      }
    }
  }
  core2.warning(`Artifact not found: ${artifactName}`);
  core2.endGroup();
  return null;
}

// src/api/retrieveBaseSnapshots.ts
async function retrieveBaseSnapshots(octokit2, {
  owner: owner2,
  repo: repo2,
  artifactName,
  workflow_id,
  branch,
  basePath,
  mergeBasePath,
  mergeBaseSha
}) {
  const baseArtifacts = await getArtifactsForBranchAndWorkflow(octokit2, {
    owner: owner2,
    repo: repo2,
    workflow_id,
    branch,
    artifactName
  });
  if (!baseArtifacts) {
    core3.debug("Unable to find base artifacts");
    return [];
  }
  const {
    head_repository,
    repository,
    ...workflowRun
  } = baseArtifacts.workflowRun;
  await (0, import_async_retry.default)(async () => await downloadOtherWorkflowArtifact(octokit2, {
    owner: owner2,
    repo: repo2,
    artifactId: baseArtifacts.artifact.id,
    downloadPath: basePath
  }), {
    onRetry: (err) => {
      console.log(workflowRun);
      console.error(err);
    }
  });
  let mergeBaseArtifacts = null;
  core3.startGroup("workflowRun");
  core3.debug(`Merge base SHA: ${mergeBaseSha}`);
  core3.debug(`workflowRun head sha (i.e. latest master): ${workflowRun.head_sha}`);
  core3.debug(`!!! workflowRun:
${JSON.stringify(workflowRun, null, 2)}`);
  core3.endGroup();
  if (workflowRun.head_sha !== mergeBaseSha) {
    mergeBaseArtifacts = await getArtifactsForBranchAndWorkflow(octokit2, {
      owner: owner2,
      repo: repo2,
      workflow_id,
      branch,
      commit: mergeBaseSha,
      artifactName
    });
    if (mergeBaseArtifacts) {
      await (0, import_async_retry.default)(async () => await downloadOtherWorkflowArtifact(octokit2, {
        owner: owner2,
        repo: repo2,
        artifactId: mergeBaseArtifacts.artifact.id,
        downloadPath: mergeBasePath
      }), {
        onRetry: (err) => {
          console.log(workflowRun);
          console.error(err);
        }
      });
    }
  } else {
    core3.debug("Merge base is the same as base");
  }
  core3.endGroup();
  return [baseArtifacts, mergeBaseArtifacts];
}

// src/api/startBuild.ts
var core4 = __toESM(require_core());
async function startBuild(opt) {
  core4.startGroup("Starting build using GitHub API directly...");
  console.log("CreateCheck", `${opt.owner}/${opt.repo}#${opt.headSha}`, opt.name);
  const { data: check } = await opt.octokit.checks.create({
    owner: opt.owner,
    repo: opt.repo,
    head_sha: opt.headSha,
    name: opt.name,
    status: "in_progress"
  });
  core4.endGroup();
  return check.id;
}

// src/getPixelmatchOptions.ts
var core5 = __toESM(require_core());
var OPTIONS = ["threshold", "includeAA", "alpha", "diffMask"];
function getPixelmatchOptions() {
  const inputs = Object.fromEntries(OPTIONS.map((option) => [option, core5.getInput(option)]));
  return {
    ...inputs,
    ...!inputs.includeAA || inputs.includeAA === "false" ? { includeAA: false } : { includeAA: true }
  };
}

// src/util/diffSnapshots.ts
var import_path7 = __toESM(require("path"));
var core6 = __toESM(require_core());
var glob2 = __toESM(require_glob());
var io2 = __toESM(require_io());

// src/util/createDiff.ts
var import_fs4 = require("fs");
var import_path4 = __toESM(require("path"));
var import_pngjs4 = __toESM(require_png());

// src/util/getDiff.ts
var import_pngjs3 = __toESM(require_png());
var import_pixelmatch = __toESM(require_pixelmatch());

// src/util/fileToPng.ts
var import_fs3 = require("fs");
var import_pngjs = __toESM(require_png());
async function fileToPng(file) {
  return new Promise((resolve2, reject) => (0, import_fs3.createReadStream)(file).pipe(new import_pngjs.PNG({
    filterType: 4
  })).on("parsed", function() {
    resolve2(this);
  }).on("error", function(err) {
    reject(err);
  }));
}

// src/util/resizeImage.ts
var import_pngjs2 = __toESM(require_png());
function resizeImage(img, width, height) {
  const { width: sourceWidth, height: sourceHeight } = img;
  if (sourceWidth === width && sourceHeight === height) {
    return img;
  }
  const newImage = new import_pngjs2.PNG({ width, height });
  for (let y = 0; y < height; y++) {
    for (let x2 = 0; x2 < width; x2++) {
      const idx = width * y + x2 % width << 2;
      if (y >= img.height || x2 >= img.width) {
        newImage.data[idx] = 0;
        newImage.data[idx + 1] = 0;
        newImage.data[idx + 2] = 0;
        newImage.data[idx + 3] = 0;
      } else {
        const sourceIdx = sourceWidth * y + x2 % sourceWidth << 2;
        newImage.data[idx] = img.data[sourceIdx];
        newImage.data[idx + 1] = img.data[sourceIdx + 1];
        newImage.data[idx + 2] = img.data[sourceIdx + 2];
        newImage.data[idx + 3] = img.data[sourceIdx + 3];
      }
    }
  }
  return newImage;
}

// src/util/getDiff.ts
async function getDiff(file1, file2, { includeAA = true, threshold = 0.1, ...options } = {}) {
  let img1 = typeof file1 === "string" ? await fileToPng(file1) : file1;
  let img2 = typeof file2 === "string" ? await fileToPng(file2) : file2;
  const width = Math.max(img1.width, img2.width);
  const height = Math.max(img1.height, img2.height);
  const diff = new import_pngjs3.PNG({ width, height });
  if (img1.width !== img2.width || img1.height !== img2.height) {
    img1 = resizeImage(img1, width, height);
    img2 = resizeImage(img2, width, height);
  }
  const result = (0, import_pixelmatch.default)(img1.data, img2.data, diff.data, width, height, {
    includeAA,
    threshold,
    ...options
  });
  return {
    result,
    diff,
    img1,
    img2
  };
}

// src/util/createDiff.ts
async function createDiff(snapshotName, output, file1, file2, pixelmatchOptions) {
  const { result, diff } = await getDiff(file1, file2, pixelmatchOptions);
  console.log({ snapshotName, output, result });
  if (result > 0) {
    await import_fs4.promises.mkdir(output, { recursive: true });
    await import_fs4.promises.writeFile(import_path4.default.resolve(output, snapshotName), import_pngjs4.PNG.sync.write(diff));
  }
  return result;
}

// src/util/multiCompare.ts
var import_fs5 = require("fs");
var import_path5 = __toESM(require("path"));
var import_pngjs5 = __toESM(require_png());

// src/util/copyPixel.ts
function copyPixel(idx, from, to) {
  to.data[idx] = from.data[idx];
  to.data[idx + 1] = from.data[idx + 1];
  to.data[idx + 2] = from.data[idx + 2];
  to.data[idx + 3] = from.data[idx + 3];
}

// src/util/findChangedPixels.ts
function findChangedPixels(img) {
  const { height, width } = img;
  const locations = [];
  for (let y = 0; y < height; y++) {
    for (let x2 = 0; x2 < width; x2++) {
      const idx = width * y + x2 << 2;
      if (img.data[idx] !== 255 || img.data[idx + 1] !== 255 || img.data[idx + 2] !== 255) {
        locations.push(idx);
      }
    }
  }
  return locations;
}

// src/util/multiCompare.ts
async function multiCompare({
  snapshotName,
  branchBase,
  baseHead,
  branchHead,
  outputDiffPath,
  outputMergedPath,
  pixelmatchOptions
}) {
  const promises = [];
  const [
    baseHeadImage,
    branchHeadMergedImage,
    branchBaseImage
  ] = await Promise.all([
    fileToPng(baseHead),
    fileToPng(branchHead),
    fileToPng(branchBase)
  ]);
  try {
    const {
      result: baseDiffResult,
      diff: branchBaseBaseHeadDiffImage
    } = await getDiff(branchBaseImage, baseHeadImage, {
      ...pixelmatchOptions,
      alpha: 0
    });
    if (baseDiffResult > 0) {
      const changedPixels = findChangedPixels(branchBaseBaseHeadDiffImage);
      changedPixels.forEach((idx) => {
        copyPixel(idx, baseHeadImage, branchHeadMergedImage);
      });
      promises.push(import_fs5.promises.writeFile(import_path5.default.resolve(outputMergedPath, snapshotName), import_pngjs5.PNG.sync.write(branchHeadMergedImage)));
    }
  } catch (err) {
    console.log(err);
  }
  const { result, diff } = await getDiff(baseHeadImage, branchHeadMergedImage, pixelmatchOptions);
  if (result > 0) {
    promises.push(import_fs5.promises.writeFile(import_path5.default.resolve(outputDiffPath, snapshotName), import_pngjs5.PNG.sync.write(diff)));
  }
  await Promise.all(promises);
  return result;
}

// src/util/getDirectoriesToFile.ts
var import_path6 = __toESM(require("path"));
function getDirectoriesToFile(from, to) {
  return import_path6.default.relative(from, import_path6.default.dirname(to));
}

// src/util/getChildDirectories.ts
function getChildDirectories(targets) {
  return new Set(targets.reduce((acc, [base, files]) => acc.concat(files.map((file) => getDirectoriesToFile(base, file))), []).filter(Boolean));
}

// src/util/diffSnapshots.ts
var import_fs6 = require("fs");
var pngGlob = "/**/*.png";
async function diffSnapshots({
  basePath,
  mergeBasePath,
  currentPath,
  outputPath,
  diffDirName = "diffs",
  baseDirName = "original",
  mergedDirName = "merged",
  currentDirName = "changed",
  newDirName = "new",
  missingDirName = "missing",
  pixelmatchOptions
}) {
  const newSnapshots = /* @__PURE__ */ new Set([]);
  const changedSnapshots = /* @__PURE__ */ new Set([]);
  const missingSnapshots = /* @__PURE__ */ new Set([]);
  const currentSnapshots = /* @__PURE__ */ new Set([]);
  const baseSnapshots = /* @__PURE__ */ new Set([]);
  const potentialFlakes = /* @__PURE__ */ new Set([]);
  const [baseGlobber, currentGlobber, mergeBaseGlobber] = await Promise.all([
    glob2.create(`${basePath}${pngGlob}`, { followSymbolicLinks: false }),
    glob2.create(`${currentPath}${pngGlob}`, { followSymbolicLinks: false }),
    glob2.create(`${mergeBasePath}${pngGlob}`, { followSymbolicLinks: false })
  ]);
  const [baseFiles, currentFiles, mergeBaseFiles] = await Promise.all([
    baseGlobber.glob(),
    currentGlobber.glob(),
    mergeBaseGlobber.glob()
  ]);
  console.log({
    baseFiles,
    currentFiles,
    mergeBaseFiles
  });
  if (!baseFiles.length) {
    core6.warning("No snapshots found for base branch");
  }
  if (!mergeBaseFiles.length) {
    core6.debug("No snapshots found for merge base");
  }
  if (!currentFiles.length) {
    core6.warning("No snapshots found for current branch");
  }
  baseFiles.forEach((absoluteFile) => {
    const file = import_path7.default.relative(basePath, absoluteFile);
    baseSnapshots.add(file);
    missingSnapshots.add(file);
  });
  const mergeBaseSnapshots = new Set(mergeBaseFiles.map((absolute) => import_path7.default.relative(mergeBasePath, absolute)));
  const childPaths = getChildDirectories([
    [currentPath, currentFiles],
    [basePath, baseFiles]
  ]);
  const outputDiffPath = import_path7.default.resolve(outputPath, diffDirName);
  const outputBasePath = import_path7.default.resolve(outputPath, baseDirName);
  const outputCurrentPath = import_path7.default.resolve(outputPath, currentDirName);
  const outputMergedPath = import_path7.default.resolve(outputPath, mergedDirName);
  const outputNewPath = import_path7.default.resolve(outputPath, newDirName);
  const outputMissingPath = import_path7.default.resolve(outputPath, missingDirName);
  for (const base of [
    outputDiffPath,
    outputBasePath,
    outputCurrentPath,
    outputMergedPath,
    outputNewPath,
    outputMissingPath
  ]) {
    console.log("Mkdir", { base });
    await import_fs6.promises.mkdir(base, { recursive: true });
    for (const childPath of [...childPaths]) {
      console.log("Mkdir", import_path7.default.resolve(base, childPath));
      try {
        await io2.mkdirP(import_path7.default.resolve(base, childPath));
      } catch (err) {
        console.trace(err);
      }
    }
  }
  for (const absoluteFile of currentFiles) {
    const file = import_path7.default.relative(currentPath, absoluteFile);
    console.log("Diff", { absoluteFile, file });
    currentSnapshots.add(file);
    if (baseSnapshots.has(file)) {
      const baseHead = import_path7.default.resolve(basePath, file);
      const branchHead = import_path7.default.resolve(currentPath, file);
      try {
        let isDiff;
        if (mergeBaseSnapshots.has(file)) {
          console.log("CreateDiff:3way");
          isDiff = await multiCompare({
            branchBase: import_path7.default.resolve(mergeBasePath, file),
            baseHead,
            branchHead,
            outputDiffPath,
            outputMergedPath,
            snapshotName: file,
            pixelmatchOptions
          });
        } else {
          console.log("CreateDiff", {
            file,
            outputDiffPath,
            baseHead,
            branchHead,
            pixelmatchOptions
          });
          isDiff = await createDiff(file, outputDiffPath, baseHead, branchHead, pixelmatchOptions);
        }
        if (isDiff) {
          console.log("isDiff", isDiff);
          changedSnapshots.add(file);
          await Promise.all([
            io2.cp(baseHead, import_path7.default.resolve(outputBasePath, file)),
            io2.cp(branchHead, import_path7.default.resolve(outputCurrentPath, file))
          ]);
        }
        missingSnapshots.delete(file);
      } catch (err) {
        core6.debug(`Unable to diff: ${err.message}`);
        throw err;
      }
    } else {
      newSnapshots.add(file);
    }
    console.log("DiffDone", { absoluteFile, file });
  }
  missingSnapshots.forEach((file) => {
    if (mergeBaseFiles.length && !mergeBaseSnapshots.has(file)) {
      missingSnapshots.delete(file);
      potentialFlakes.add(file);
      return;
    }
  });
  newSnapshots.forEach((file) => {
    if (mergeBaseSnapshots.has(file)) {
      newSnapshots.delete(file);
      potentialFlakes.add(file);
      return;
    }
  });
  await Promise.all([...missingSnapshots].map(async (file) => await io2.cp(import_path7.default.resolve(basePath, file), import_path7.default.resolve(outputMissingPath, file))));
  await Promise.all([...newSnapshots].map(async (file) => await io2.cp(import_path7.default.resolve(currentPath, file), import_path7.default.resolve(outputNewPath, file))));
  return {
    baseFiles,
    missingSnapshots,
    newSnapshots,
    changedSnapshots,
    potentialFlakes
  };
}

// src/util/downloadSnapshots.ts
var core7 = __toESM(require_core());
var artifact = __toESM(require_artifact_client2());
var import_exec2 = __toESM(require_exec());
var glob3 = __toESM(require_glob());
async function downloadSnapshots({
  artifactName,
  rootDirectory
}) {
  const description = `downloadSnapshots: ${artifactName}`;
  core7.startGroup(description);
  const artifactClient = artifact.create();
  const resp = await artifactClient.downloadArtifact(artifactName, rootDirectory, {
    createArtifactFolder: true
  });
  await (0, import_exec2.exec)("ls", [rootDirectory]);
  const tarGlobber = await glob3.create(`${rootDirectory}/${artifactName}/snap*.tar.gz`, {
    followSymbolicLinks: false
  });
  const tarFiles = await tarGlobber.glob();
  for (const file of tarFiles) {
    await (0, import_exec2.exec)("tar", ["zxf", file, "-C", resp.downloadPath]);
  }
  await (0, import_exec2.exec)("ls", ["-la", resp.downloadPath]);
  core7.endGroup();
  return resp;
}

// src/util/generateImageGallery.ts
var import_fs7 = require("fs");
var import_ejs = __toESM(require_ejs());
async function generateImageGallery(target, data) {
  const template2 = (init_template(), __toCommonJS(template_exports)).default;
  const html = import_ejs.default.render(template2.html, {
    images: JSON.stringify(data)
  });
  await import_fs7.promises.writeFile(target, html);
}

// src/util/saveSnapshots.ts
var io3 = __toESM(require_io());
var core8 = __toESM(require_core());
var artifact2 = __toESM(require_artifact_client2());
var import_exec3 = __toESM(require_exec());
var glob4 = __toESM(require_glob());

// node_modules/uuid/wrapper.mjs
var import_dist = __toESM(require_dist(), 1);
var v1 = import_dist.default.v1;
var v3 = import_dist.default.v3;
var v4 = import_dist.default.v4;
var v5 = import_dist.default.v5;
var NIL = import_dist.default.NIL;
var version = import_dist.default.version;
var validate = import_dist.default.validate;
var stringify = import_dist.default.stringify;
var parse = import_dist.default.parse;

// src/util/saveSnapshots.ts
async function _save({ rootDirectory, artifactName }) {
  const artifactClient = artifact2.create();
  await io3.mkdirP("/tmp/snaps");
  await (0, import_exec3.exec)("tar", [
    "czf",
    `/tmp/snaps/snap-${v4()}.tar.gz`,
    "-C",
    rootDirectory,
    "."
  ]);
  const tarGlobber = await glob4.create("/tmp/snaps/*.tar.gz", {
    followSymbolicLinks: false
  });
  const tarFiles = await tarGlobber.glob();
  const result = await artifactClient.uploadArtifact(artifactName, tarFiles, "/tmp/snaps");
  return result;
}
async function saveSnapshots({
  artifactName,
  rootDirectory
}) {
  core8.startGroup("saveSnapshots");
  let retries = 5;
  while (retries > 0) {
    try {
      const result = await _save({ artifactName, rootDirectory });
      core8.endGroup();
      return result;
    } catch (err) {
      if (!err.message.includes("ECONNRESET")) {
        core8.endGroup();
        throw err;
      }
    } finally {
      retries--;
    }
  }
  core8.endGroup();
  throw new Error("Unable to save snapshots after 5 attempts");
}

// src/main.ts
fsa.list("s3://linz-basemaps");
var { owner, repo } = github.context.repo;
var token = core9.getInput("github-token");
var octokit = token && github.getOctokit(token);
var { GITHUB_WORKSPACE, GITHUB_WORKFLOW } = process.env;
var pngGlob2 = "/**/*.png";
var shouldSaveOnly = core9.getInput("save-only");
function handleError(error2) {
  console.trace(error2);
  core9.setFailed(error2.message);
}
async function run() {
  const resultsRootPath = core9.getInput("results-path");
  const baseBranch = core9.getInput("base-branch");
  const artifactName = core9.getInput("artifact-name");
  const storagePrefix = core9.getInput("storage-prefix");
  const publicUrl = core9.getInput("storage-url");
  const actionName = core9.getInput("action-name");
  const snapshotPath = core9.getInput("snapshot-path");
  const resultsPath = import_path8.default.resolve(resultsRootPath, "visual-snapshots-results");
  const basePath = import_path8.default.resolve("/tmp/visual-snapshots-base");
  const mergeBasePath = import_path8.default.resolve("/tmp/visual-snapshop-merge-base");
  const workflowRunPayload = github.context.payload.workflow_run;
  const pullRequestPayload = github.context.payload.pull_request;
  const workflowRunPullRequest = workflowRunPayload?.pull_requests?.[0];
  const headSha = pullRequestPayload?.head.sha || workflowRunPullRequest?.head.sha || workflowRunPayload?.head_sha;
  const headRef = pullRequestPayload?.head.ref || workflowRunPullRequest?.head.ref || workflowRunPayload?.head_branch && `${workflowRunPayload?.head_repository?.full_name}/${workflowRunPayload?.head_branch}`;
  const mergeBaseSha = core9.getInput("merge-base") || pullRequestPayload?.base?.sha || workflowRunPullRequest?.base.sha;
  core9.startGroup("Set outputs");
  core9.setOutput("results-path", resultsRootPath);
  core9.setOutput("base-images-path", basePath);
  core9.setOutput("merge-base-images-path", mergeBasePath);
  core9.endGroup();
  core9.startGroup("github context");
  core9.debug(`merge base: ${mergeBaseSha}`);
  core9.debug(JSON.stringify(github.context, null, 2));
  core9.endGroup();
  try {
    if (snapshotPath) {
      await saveSnapshots({
        artifactName,
        rootDirectory: snapshotPath
      });
    }
  } catch (error2) {
    handleError(error2);
  } finally {
    if (shouldSaveOnly !== "false") {
      return;
    }
  }
  if (!octokit) {
    const error2 = new Error("`github-token` missing");
    handleError(error2);
    throw error2;
  }
  if (workflowRunPayload?.event === "push") {
    core9.debug("Push event triggered `workflow_run`... skipping as this only works for PRs");
    return;
  }
  const buildId = await startBuild({
    octokit,
    owner,
    repo,
    headSha,
    headRef,
    name: actionName
  });
  try {
    const [
      didDownloadLatest,
      didDownloadMergeBase
    ] = await retrieveBaseSnapshots(octokit, {
      owner,
      repo,
      branch: baseBranch,
      workflow_id: `${workflowRunPayload?.name || GITHUB_WORKFLOW}.yml`,
      artifactName,
      basePath,
      mergeBasePath,
      mergeBaseSha
    });
    if (!didDownloadLatest) {
      core9.warning("Unable to download artifact from base branch");
    }
    if (!didDownloadMergeBase) {
      core9.debug("Unable to download artifact from merge base sha");
    }
    let downloadResp = null;
    if (!snapshotPath) {
      core9.debug("Downloading current snapshots");
      const rootDirectory = "/tmp/visual-snapshots";
      if (github.context.eventName === "workflow_run") {
        const { data } = await octokit.actions.listWorkflowRunArtifacts({
          owner,
          repo,
          run_id: workflowRunPayload?.id
        });
        const artifact3 = data.artifacts.find(({ name }) => name === artifactName);
        if (!artifact3) {
          throw new Error(`Unable to find artifact from ${workflowRunPayload?.html_url}`);
        }
        downloadResp = await downloadOtherWorkflowArtifact(octokit, {
          owner,
          repo,
          artifactId: artifact3.id,
          downloadPath: `${rootDirectory}/visual-snapshots`
        });
      } else {
        downloadResp = await downloadSnapshots({
          artifactName,
          rootDirectory
        });
      }
    }
    const current = snapshotPath || downloadResp?.downloadPath;
    if (!current) {
      const err = new Error(!snapshotPath ? "`snapshot-path` input not configured" : "Unable to download current snapshots");
      core9.error(err);
      throw err;
    }
    const currentPath = import_path8.default.resolve(GITHUB_WORKSPACE, current || "");
    core9.startGroup("Starting diff of snapshots...");
    const pixelmatchOptions = getPixelmatchOptions();
    await io4.mkdirP(resultsPath);
    const {
      baseFiles,
      changedSnapshots,
      missingSnapshots,
      newSnapshots
    } = await diffSnapshots({
      basePath,
      mergeBasePath,
      currentPath,
      outputPath: resultsPath,
      pixelmatchOptions
    });
    const resultsGlobber = await glob5.create(`${resultsPath}${pngGlob2}`, {
      followSymbolicLinks: false
    });
    const resultsFiles = await resultsGlobber.glob();
    const gcsDestination = `${owner}/${repo}/${headSha}`;
    const resultsArtifactUrls = await Promise.all(resultsFiles.map(async (file) => {
      const relativeFilePath = import_path8.default.relative(resultsPath, file);
      const target = fsa.join(storagePrefix, `${gcsDestination}/results/${relativeFilePath}`);
      const imageUrl = fsa.join(publicUrl, `${gcsDestination}/results/${relativeFilePath}`);
      console.log("Writing", { src: file, dest: target, public: imageUrl });
      await fsa.write(target, fsa.stream(file));
      return { image_url: imageUrl, alt: "" };
    }));
    const changedArray = [...changedSnapshots];
    const results = {
      baseFilesLength: baseFiles.length,
      changed: changedArray,
      missing: [...missingSnapshots],
      added: [...newSnapshots]
    };
    core9.endGroup();
    core9.startGroup("Generating image gallery...");
    await generateImageGallery(import_path8.default.resolve(resultsPath, "index.html"), results);
    await fsa.write(fsa.join(storagePrefix, `${gcsDestination}/index.html`), fsa.stream(import_path8.default.resolve(resultsPath, "index.html")));
    const galleryUrl = fsa.join(publicUrl, `${gcsDestination}/index.html`);
    core9.debug("Saving snapshots and finishing build...");
    await Promise.all([
      saveSnapshots({
        artifactName: `${artifactName}-results`,
        rootDirectory: resultsRootPath
      }),
      finishBuild({
        octokit,
        id: buildId,
        owner,
        repo,
        galleryUrl,
        images: resultsArtifactUrls,
        headSha,
        results
      })
    ]);
  } catch (error2) {
    handleError(error2);
    failBuild({
      octokit,
      id: buildId,
      owner,
      repo,
      headSha
    });
  }
}
run();
/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */
